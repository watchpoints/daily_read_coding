***************   Case 1   ***************

SQL: select * from t1 where c2 > 0 and c2 < 10; 

==========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST |
----------------------------------------------------------
|0 |PX COORDINATOR         |             |25000    |17859|
|1 | EXCHANGE OUT DISTR    |:EX10000     |25000    |15492|
|2 |  PX PARTITION ITERATOR|             |25000    |15492|
|3 |   TABLE SCAN          |t1(idx_t1_c2)|25000    |15492|
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(0,MAX ; 10,MIN), 
      range_cond([t1.c2 > ?], [t1.c2 < ?])

*************** Case 1(end)  ************** 

***************   Case 2   ***************

SQL: select/*+index(t1 idx_t1_c2)*/ * from t1 where c2 > 0 and c2 < 10; 

==========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST |
----------------------------------------------------------
|0 |PX COORDINATOR         |             |25000    |17859|
|1 | EXCHANGE OUT DISTR    |:EX10000     |25000    |15492|
|2 |  PX PARTITION ITERATOR|             |25000    |15492|
|3 |   TABLE SCAN          |t1(idx_t1_c2)|25000    |15492|
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(0,MAX ; 10,MIN), 
      range_cond([t1.c2 > ?], [t1.c2 < ?])

*************** Case 2(end)  ************** 

***************   Case 3   ***************

SQL: select c1 from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 3(end)  ************** 

***************   Case 4   ***************

SQL: select c2 from t1 order by c2; 

===============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500000   |1506236|
|1 | EXCHANGE OUT DISTR       |:EX10000     |500000   |1458906|
|2 |  SORT                    |             |500000   |1458906|
|3 |   PX PARTITION ITERATOR  |             |500000   |309262 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500000   |309262 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 4(end)  ************** 

***************   Case 5   ***************

SQL: select c1, c2 from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 5(end)  ************** 

***************   Case 6   ***************

SQL: select c1 + c2 from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + t1.c2]), filter(nil)
  1 - output([t1.c1 + t1.c2]), filter(nil), dop=1
  2 - output([t1.c1 + t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1 + t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 6(end)  ************** 

***************   Case 7   ***************

SQL: select c1 from t1 limit 100; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |100      |107 |
|1 | PX COORDINATOR         |        |100      |93  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|100      |88  |
|3 |   PX PARTITION ITERATOR|        |100      |88  |
|4 |    TABLE SCAN          |t1      |100      |88  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 7(end)  ************** 

***************   Case 8   ***************

SQL: select * from t1 limit 100; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |100      |113 |
|1 | PX COORDINATOR         |        |100      |100 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|100      |90  |
|3 |   PX PARTITION ITERATOR|        |100      |90  |
|4 |    TABLE SCAN          |t1      |100      |90  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 8(end)  ************** 

***************   Case 9   ***************

SQL: select * from t1 order by c1,c2 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |241 |
|1 | PX COORDINATOR MERGE SORT |        |100      |227 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |217 |
|3 |   SORT                    |        |100      |217 |
|4 |    PX PARTITION ITERATOR  |        |100      |90  |
|5 |     TABLE SCAN            |t1      |100      |90  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 9(end)  ************** 

***************   Case 10   ***************

SQL: select c1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |214 |
|1 | PX COORDINATOR MERGE SORT |        |100      |200 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |196 |
|3 |   SORT                    |        |100      |196 |
|4 |    PX PARTITION ITERATOR  |        |100      |88  |
|5 |     TABLE SCAN            |t1      |100      |88  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 10(end)  ************** 

***************   Case 11   ***************

SQL: select c1 from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |241 |
|1 | PX COORDINATOR MERGE SORT |             |100      |227 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |217 |
|3 |   SORT                    |             |100      |217 |
|4 |    PX PARTITION ITERATOR  |             |100      |90  |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |90  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 11(end)  ************** 

***************   Case 12   ***************

SQL: select c1 from t1 where c1 > 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |965 |
|1 | PX COORDINATOR MERGE SORT |             |100      |951 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |942 |
|3 |   SORT                    |             |100      |942 |
|4 |    PX PARTITION ITERATOR  |             |100      |815 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |815 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 12(end)  ************** 

***************   Case 13   ***************

SQL: select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |965 |
|1 | PX COORDINATOR MERGE SORT |             |100      |951 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |942 |
|3 |   SORT                    |             |100      |942 |
|4 |    PX PARTITION ITERATOR  |             |100      |815 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |815 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(NULL,MAX ; 0,MIN), 
      range_cond([t1.c2 < ?])

*************** Case 13(end)  ************** 

***************   Case 14   ***************

SQL: select c1 from t1 group by c1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 14(end)  ************** 

***************   Case 15   ***************

SQL: select c2, sum(c1) from t1 group by c2; 

===================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST  |
-------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |101      |584018|
|1 | EXCHANGE OUT DISTR            |:EX10001     |101      |584008|
|2 |  MERGE GROUP BY               |             |101      |584008|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |101      |446640|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |101      |446631|
|5 |     PX PARTITION ITERATOR     |             |101      |446631|
|6 |      MERGE GROUP BY           |             |101      |446631|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  1 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 15(end)  ************** 

***************   Case 16   ***************

SQL: select c2, avg(c1) from t1 group by c2; 

===================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST  |
-------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |101      |637008|
|1 | EXCHANGE OUT DISTR            |:EX10001     |101      |636999|
|2 |  MERGE GROUP BY               |             |101      |636999|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |101      |473135|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |101      |473126|
|5 |     PX PARTITION ITERATOR     |             |101      |473126|
|6 |      MERGE GROUP BY           |             |101      |473126|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 16(end)  ************** 

***************   Case 17   ***************

SQL: select c1, c1 + c2 from t1 where c1 > 0 limit 100; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |100      |113 |
|1 | PX COORDINATOR         |        |100      |100 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|100      |90  |
|3 |   PX PARTITION ITERATOR|        |100      |90  |
|4 |    TABLE SCAN          |t1      |100      |90  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 17(end)  ************** 

***************   Case 18   ***************

SQL: select c1 from t1 where c1 > 0; 

=====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST |
-----------------------------------------------------
|0 |PX COORDINATOR         |        |50000    |32212|
|1 | EXCHANGE OUT DISTR    |:EX10000|50000    |29845|
|2 |  PX PARTITION ITERATOR|        |50000    |29845|
|3 |   TABLE SCAN          |t1      |50000    |29845|
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 18(end)  ************** 

***************   Case 19   ***************

SQL: select c2 from t1 group by c2 order by c2 limit 100; 

=====================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------------
|0 |LIMIT                            |             |100      |531055|
|1 | PX COORDINATOR MERGE SORT       |             |100      |531041|
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |531032|
|3 |   LIMIT                         |             |100      |531032|
|4 |    MERGE GROUP BY               |             |100      |531018|
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |420145|
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |420135|
|7 |       PX PARTITION ITERATOR     |             |100      |420135|
|8 |        MERGE GROUP BY           |             |100      |420135|
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c2]), filter(nil), dop=1
  3 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  7 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 19(end)  ************** 

***************   Case 20   ***************

SQL: select sum(c1) from t1 group by c2 order by c2 limit 100; 

=====================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------------
|0 |LIMIT                            |             |100      |584046|
|1 | PX COORDINATOR MERGE SORT       |             |100      |584032|
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |584022|
|3 |   LIMIT                         |             |100      |584022|
|4 |    MERGE GROUP BY               |             |100      |584008|
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |446640|
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |446631|
|7 |       PX PARTITION ITERATOR     |             |100      |446631|
|8 |        MERGE GROUP BY           |             |100      |446631|
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 20(end)  ************** 

***************   Case 21   ***************

SQL: select sum(c1) from t1 where c1 > 0 group by c2 order by c2 limit 100; 

==============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST |
--------------------------------------------------------------
|0 |LIMIT                           |        |100      |69368|
|1 | PX COORDINATOR MERGE SORT      |        |100      |69355|
|2 |  EXCHANGE OUT DISTR            |:EX10001|100      |69345|
|3 |   LIMIT                        |        |100      |69345|
|4 |    TOP-N SORT                  |        |100      |69331|
|5 |     HASH GROUP BY              |        |101      |69225|
|6 |      EXCHANGE IN DISTR         |        |101      |50091|
|7 |       EXCHANGE OUT DISTR (HASH)|:EX10000|101      |50082|
|8 |        HASH GROUP BY           |        |101      |50082|
|9 |         PX PARTITION ITERATOR  |        |50000    |30948|
|10|          TABLE SCAN            |t1      |50000    |30948|
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100)
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 21(end)  ************** 

***************   Case 22   ***************

SQL: select count(c1) from t1 group by c2 order by c2 limit 100; 

=====================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------------
|0 |LIMIT                            |             |100      |584046|
|1 | PX COORDINATOR MERGE SORT       |             |100      |584032|
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |584022|
|3 |   LIMIT                         |             |100      |584022|
|4 |    MERGE GROUP BY               |             |100      |584008|
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |446640|
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |446631|
|7 |       PX PARTITION ITERATOR     |             |100      |446631|
|8 |        MERGE GROUP BY           |             |100      |446631|
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  5 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 22(end)  ************** 

***************   Case 23   ***************

SQL: select count(*) from t1 group by c2 order by c2 limit 100; 

=====================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------------
|0 |LIMIT                            |             |100      |584046|
|1 | PX COORDINATOR MERGE SORT       |             |100      |584032|
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |584022|
|3 |   LIMIT                         |             |100      |584022|
|4 |    MERGE GROUP BY               |             |100      |584008|
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |446640|
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |446631|
|7 |       PX PARTITION ITERATOR     |             |100      |446631|
|8 |        MERGE GROUP BY           |             |100      |446631|
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(*)])
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 23(end)  ************** 

***************   Case 24   ***************

SQL: select sum(c1), count(*) from t1 group by c2 order by c2 limit 100; 

=====================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------------
|0 |LIMIT                            |             |100      |637036|
|1 | PX COORDINATOR MERGE SORT       |             |100      |637022|
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |637013|
|3 |   LIMIT                         |             |100      |637013|
|4 |    MERGE GROUP BY               |             |100      |636999|
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |473135|
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |473126|
|7 |       PX PARTITION ITERATOR     |             |100      |473126|
|8 |        MERGE GROUP BY           |             |100      |473126|
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 24(end)  ************** 

***************   Case 25   ***************

SQL: select c2, count(c1) from t1 group by c2; 

===================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST  |
-------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |101      |584018|
|1 | EXCHANGE OUT DISTR            |:EX10001     |101      |584008|
|2 |  MERGE GROUP BY               |             |101      |584008|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |101      |446640|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |101      |446631|
|5 |     PX PARTITION ITERATOR     |             |101      |446631|
|6 |      MERGE GROUP BY           |             |101      |446631|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 25(end)  ************** 

***************   Case 26   ***************

SQL: select t1.c1 from t1, t2 limit 100; 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |LIMIT                      |        |100      |248407|
|1 | NESTED-LOOP JOIN CARTESIAN|        |100      |248393|
|2 |  PX COORDINATOR           |        |1        |36    |
|3 |   EXCHANGE OUT DISTR      |:EX10000|1        |36    |
|4 |    PX PARTITION ITERATOR  |        |1        |36    |
|5 |     TABLE SCAN            |t1      |1        |36    |
|6 |  MATERIAL                 |        |300000   |248287|
|7 |   PX COORDINATOR          |        |300000   |193161|
|8 |    EXCHANGE OUT DISTR     |:EX20000|300000   |178962|
|9 |     PX PARTITION ITERATOR |        |300000   |178962|
|10|      TABLE SCAN           |t2      |300000   |178962|
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), dop=1
  9 - output([1]), filter(nil), 
      force partition granule, asc.
  10 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 26(end)  ************** 

***************   Case 27   ***************

SQL: select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |LIMIT                          |        |100      |3799|
|1 | PX COORDINATOR                |        |100      |3785|
|2 |  EXCHANGE OUT DISTR           |:EX10001|100      |3776|
|3 |   LIMIT                       |        |100      |3776|
|4 |    NESTED-LOOP JOIN           |        |100      |3762|
|5 |     EXCHANGE IN DISTR         |        |100      |93  |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|7 |       PX PARTITION ITERATOR   |        |100      |88  |
|8 |        TABLE SCAN             |t2      |100      |88  |
|9 |     PX PARTITION ITERATOR     |        |1        |36  |
|10|      TABLE GET                |t1      |1        |36  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  5 - output([t2.c1], [PARTITION_ID]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 27(end)  ************** 

***************   Case 28   ***************

SQL: select t1.c1 from t1, t2, t3 where t1.c1=t2.c1       and t1.c2>t2.c2       and t2.c3=t3.c3       and t3.c1>10; 

=================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST    |
-----------------------------------------------------------------
|0 |HASH JOIN                       |        |19602000 |21002039|
|1 | PX COORDINATOR                 |        |20000    |17134   |
|2 |  EXCHANGE OUT DISTR            |:EX10000|20000    |12401   |
|3 |   PX PARTITION ITERATOR        |        |20000    |12401   |
|4 |    TABLE SCAN                  |t3      |20000    |12401   |
|5 | PX COORDINATOR                 |        |100000   |1702554 |
|6 |  EXCHANGE OUT DISTR            |:EX20001|100000   |1664690 |
|7 |   MERGE JOIN                   |        |100000   |1664690 |
|8 |    EXCHANGE IN MERGE SORT DISTR|        |500000   |356592  |
|9 |     EXCHANGE OUT DISTR (PKEY)  |:EX20000|500000   |309262  |
|10|      PX PARTITION ITERATOR     |        |500000   |309262  |
|11|       TABLE SCAN               |t1      |500000   |309262  |
|12|    SORT                        |        |300000   |1096510 |
|13|     PX PARTITION ITERATOR      |        |300000   |192197  |
|14|      TABLE SCAN                |t2      |300000   |192197  |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t3.c3]), filter(nil)
  2 - output([t3.c3]), filter(nil), dop=1
  3 - output([t3.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(10 ; MAX), 
      range_cond([t3.c1 > ?])
  5 - output([t1.c1], [t2.c3]), filter(nil)
  6 - output([t1.c1], [t2.c3]), filter(nil), dop=1
  7 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  8 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  14 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 28(end)  ************** 

***************   Case 29   ***************

SQL: select opt.t3.c2 from opt.t1,t2,t3 where t1.c1+t2.c1=t3.c1; 

=======================================================================
|ID|OPERATOR                       |NAME    |EST. ROWS   |COST        |
-----------------------------------------------------------------------
|0 |PX COORDINATOR                 |        |150000000000|303404194026|
|1 | EXCHANGE OUT DISTR            |:EX10003|150000000000|275006174015|
|2 |  HASH JOIN                    |        |150000000000|275006174015|
|3 |   PX PARTITION ITERATOR       |        |200000      |123720      |
|4 |    TABLE SCAN                 |t3      |200000      |123720      |
|5 |   EXCHANGE IN DISTR           |        |150000000000|120345570577|
|6 |    EXCHANGE OUT DISTR (PKEY)  |:EX10002|150000000000|106146560571|
|7 |     NESTED-LOOP JOIN CARTESIAN|        |150000000000|106146560571|
|8 |      MATERIAL                 |        |500000      |413775      |
|9 |       EXCHANGE IN DISTR       |        |500000      |321898      |
|10|        EXCHANGE OUT DISTR     |:EX10000|500000      |298233      |
|11|         PX PARTITION ITERATOR |        |500000      |298233      |
|12|          TABLE SCAN           |t1      |500000      |298233      |
|13|      MATERIAL                 |        |300000      |248287      |
|14|       EXCHANGE IN DISTR       |        |300000      |193161      |
|15|        EXCHANGE OUT DISTR     |:EX10001|300000      |178962      |
|16|         PX PARTITION ITERATOR |        |300000      |178962      |
|17|          TABLE SCAN           |t2      |300000      |178962      |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c2]), filter(nil)
  1 - output([t3.c2]), filter(nil), dop=1
  2 - output([t3.c2]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1 + t2.c1]), filter(nil), is_single, dop=1
  7 - output([t1.c1 + t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  13 - output([t2.c1]), filter(nil)
  14 - output([t2.c1]), filter(nil)
  15 - output([t2.c1]), filter(nil), dop=1
  16 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  17 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 29(end)  ************** 

***************   Case 30   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3; 

================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST   |
----------------------------------------------------------------
|0 |HASH JOIN                       |        |5763577  |8476387|
|1 | PX COORDINATOR                 |        |200000   |1316046|
|2 |  EXCHANGE OUT DISTR            |:EX10001|200000   |1249784|
|3 |   MERGE JOIN                   |        |200000   |1249784|
|4 |    EXCHANGE IN MERGE SORT DISTR|        |500000   |356592 |
|5 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262 |
|6 |      PX PARTITION ITERATOR     |        |500000   |309262 |
|7 |       TABLE SCAN               |t1      |500000   |309262 |
|8 |    SORT                        |        |200000   |677960 |
|9 |     PX PARTITION ITERATOR      |        |200000   |123720 |
|10|      TABLE SCAN                |t3      |200000   |123720 |
|11| PX COORDINATOR                 |        |300000   |277391 |
|12|  EXCHANGE OUT DISTR            |:EX20000|300000   |192197 |
|13|   PX PARTITION ITERATOR        |        |300000   |192197 |
|14|    TABLE SCAN                  |t2      |300000   |192197 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  5 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t3.c3], [t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  9 - output([t3.c1], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  11 - output([t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c2], [t2.c3]), filter(nil), dop=1
  13 - output([t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  14 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 30(end)  ************** 

***************   Case 31   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t2.c1 and t1.c1+t2.c1=t3.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |300000   |2556228|
|1 | EXCHANGE OUT DISTR               |:EX10002|300000   |2513631|
|2 |  HASH JOIN                       |        |300000   |2513631|
|3 |   PX PARTITION ITERATOR          |        |200000   |119308 |
|4 |    TABLE SCAN                    |t3      |200000   |119308 |
|5 |   EXCHANGE IN DISTR              |        |300000   |1860678|
|6 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300000   |1832279|
|7 |     MERGE JOIN                   |        |300000   |1832279|
|8 |      SORT                        |        |500000   |1350777|
|9 |       PX PARTITION ITERATOR      |        |500000   |298233 |
|10|        TABLE SCAN                |t1      |500000   |298233 |
|11|      EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|12|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|13|        PX PARTITION ITERATOR     |        |300000   |178962 |
|14|         TABLE SCAN               |t2      |300000   |178962 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c1 + t2.c1]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c1 + t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  12 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  13 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  14 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 31(end)  ************** 

***************   Case 32   ***************

SQL: select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

=========================================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST           |
-------------------------------------------------------------------------
|0 |NESTED-LOOP JOIN                 |        |588060000|1.075369e+14   |
|1 | HASH JOIN                       |        |980100000|583924112      |
|2 |  PX COORDINATOR                 |        |200000   |1831309        |
|3 |   EXCHANGE OUT DISTR            |:EX10001|200000   |1802911        |
|4 |    MERGE JOIN                   |        |200000   |1802911        |
|5 |     SORT                        |        |500000   |1458906        |
|6 |      PX PARTITION ITERATOR      |        |500000   |309262         |
|7 |       TABLE SCAN                |t1      |500000   |309262         |
|8 |     EXCHANGE IN MERGE SORT DISTR|        |200000   |128774         |
|9 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |119308         |
|10|       PX PARTITION ITERATOR     |        |200000   |119308         |
|11|        TABLE SCAN               |t3      |200000   |119308         |
|12|  PX COORDINATOR                 |        |500000   |356592         |
|13|   EXCHANGE OUT DISTR            |:EX20000|500000   |309262         |
|14|    PX PARTITION ITERATOR        |        |500000   |309262         |
|15|     TABLE SCAN                  |tt      |500000   |309262         |
|16| MATERIAL                        |        |300000   |248287         |
|17|  PX COORDINATOR                 |        |300000   |193161         |
|18|   EXCHANGE OUT DISTR            |:EX30000|300000   |178962         |
|19|    PX PARTITION ITERATOR        |        |300000   |178962         |
|20|     TABLE SCAN                  |t2      |300000   |178962         |
=========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  9 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  10 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([tt.c1], [tt.c2]), filter(nil)
  13 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  14 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil)
  18 - output([t2.c1]), filter(nil), dop=1
  19 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  20 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 32(end)  ************** 

***************   Case 33   ***************

SQL: select t1.c1 from t1, (select * from t2) as t where t1.c1=t.c1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1860678|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1832279|
|2 |  MERGE JOIN                   |        |300000   |1832279|
|3 |   SORT                        |        |500000   |1350777|
|4 |    PX PARTITION ITERATOR      |        |500000   |298233 |
|5 |     TABLE SCAN                |t1      |500000   |298233 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|8 |     PX PARTITION ITERATOR     |        |300000   |178962 |
|9 |      TABLE SCAN               |t2      |300000   |178962 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 33(end)  ************** 

***************   Case 34   ***************

SQL: select t1.c1 from t1, (select * from t2 where c2>1 order by c1 limit 10) as t where t1.c1=t.c1; 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |10       |479 |
|1 | EXCHANGE OUT DISTR                |:EX10002|10       |478 |
|2 |  NESTED-LOOP JOIN                 |        |10       |478 |
|3 |   EXCHANGE IN DISTR               |        |10       |111 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10001|10       |111 |
|5 |     SUBPLAN SCAN                  |t       |10       |111 |
|6 |      LIMIT                        |        |10       |109 |
|7 |       EXCHANGE IN MERGE SORT DISTR|        |10       |108 |
|8 |        EXCHANGE OUT DISTR         |:EX10000|10       |107 |
|9 |         PX PARTITION ITERATOR     |        |10       |107 |
|10|          TABLE SCAN               |t2      |10       |107 |
|11|   PX PARTITION ITERATOR           |        |1        |36  |
|12|    TABLE GET                      |t1      |1        |36  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t.c1]), batch_join=false
  3 - output([t.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t.c1]), output([t.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  5 - output([t.c1]), filter(nil), 
      access([t.c1])
  6 - output([t2.c1]), filter(nil), limit(10), offset(nil)
  7 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      limit(10), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 34(end)  ************** 

***************   Case 35   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 order by c2 + c1; 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |50000    |136739|
|1 | EXCHANGE OUT DISTR       |:EX10000|50000    |132006|
|2 |  SORT                    |        |50000    |132006|
|3 |   PX PARTITION ITERATOR  |        |50000    |30948 |
|4 |    TABLE SCAN            |t1      |50000    |30948 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  1 - output([t1.c1], [t1.c1 + t1.c2], [t1.c2 + t1.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c1 + t1.c2], [t1.c2 + t1.c1]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t1.c2 + t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2], [t1.c2 + t1.c1]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 35(end)  ************** 

***************   Case 36   ***************

SQL: select * from t1,t2 where t1.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1855036|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1741444|
|2 |  MERGE JOIN                   |        |300000   |1741444|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500000   |356592 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262 |
|5 |     PX PARTITION ITERATOR     |        |500000   |309262 |
|6 |      TABLE SCAN               |t1      |500000   |309262 |
|7 |   SORT                        |        |300000   |1096510|
|8 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|9 |     TABLE SCAN                |t2      |300000   |192197 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 36(end)  ************** 

***************   Case 37   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1806143|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1706750|
|2 |  MERGE JOIN                   |        |300000   |1706750|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500000   |321898 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |298233 |
|5 |     PX PARTITION ITERATOR     |        |500000   |298233 |
|6 |      TABLE SCAN               |t1      |500000   |298233 |
|7 |   SORT                        |        |300000   |1096510|
|8 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|9 |     TABLE SCAN                |t2      |300000   |192197 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 37(end)  ************** 

***************   Case 38   ***************

SQL: select c2 from t1 order by c1; 

==========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST   |
----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500000   |1506236|
|1 | EXCHANGE OUT DISTR       |:EX10000|500000   |1458906|
|2 |  SORT                    |        |500000   |1458906|
|3 |   PX PARTITION ITERATOR  |        |500000   |309262 |
|4 |    TABLE SCAN            |t1      |500000   |309262 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c2], [t1.c1]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 38(end)  ************** 

***************   Case 39   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1 order by t1.c2; 

================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST   |
----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |        |300000   |2875869|
|1 | EXCHANGE OUT DISTR             |:EX10001|300000   |2762277|
|2 |  SORT                          |        |300000   |2762277|
|3 |   MERGE JOIN                   |        |300000   |1741444|
|4 |    EXCHANGE IN MERGE SORT DISTR|        |500000   |356592 |
|5 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262 |
|6 |      PX PARTITION ITERATOR     |        |500000   |309262 |
|7 |       TABLE SCAN               |t1      |500000   |309262 |
|8 |    SORT                        |        |300000   |1096510|
|9 |     PX PARTITION ITERATOR      |        |300000   |192197 |
|10|      TABLE SCAN                |t2      |300000   |192197 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  5 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 39(end)  ************** 

***************   Case 40   ***************

SQL: select /*+ INDEX(t1 INVALID_INDEX) */ c1 from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 40(end)  ************** 

***************   Case 41   ***************

SQL: select c1 from t1 as t order by c1; 

==========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST   |
----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500000   |1374442|
|1 | EXCHANGE OUT DISTR       |:EX10000|500000   |1350777|
|2 |  SORT                    |        |500000   |1350777|
|3 |   PX PARTITION ITERATOR  |        |500000   |298233 |
|4 |    TABLE SCAN            |t       |500000   |298233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil), sort_keys([t.c1, ASC])
  1 - output([t.c1]), filter(nil), dop=1
  2 - output([t.c1]), filter(nil), sort_keys([t.c1, ASC]), local merge sort
  3 - output([t.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 41(end)  ************** 

***************   Case 42   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 limit 1, 10; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |10       |41  |
|1 | PX COORDINATOR         |        |11       |39  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|11       |38  |
|3 |   PX PARTITION ITERATOR|        |11       |38  |
|4 |    TABLE SCAN          |t1      |11       |38  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(10), offset(?)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(10 + ?), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 42(end)  ************** 

***************   Case 43   ***************

SQL: select * from t1 where c1 in (3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |58  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |57  |
|2 |  PX PARTITION ITERATOR|        |2        |57  |
|3 |   TABLE GET           |t1      |2        |57  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[3-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?)])

*************** Case 43(end)  ************** 

***************   Case 44   ***************

SQL: select * from t1 where c1 in (3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 44(end)  ************** 

***************   Case 45   ***************

SQL: select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |22223    |1501552|
|1 | EXCHANGE OUT DISTR            |:EX10001|22223    |1488930|
|2 |  MERGE JOIN                   |        |22223    |1488930|
|3 |   SORT                        |        |300000   |1096510|
|4 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|5 |     TABLE SCAN                |t2      |300000   |192197 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|8 |     PX PARTITION ITERATOR     |        |200000   |128131 |
|9 |      TABLE SCAN               |t3      |200000   |128131 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  7 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 45(end)  ************** 

***************   Case 46   ***************

SQL: select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |30000    |1684634|
|1 | EXCHANGE OUT DISTR            |:EX10001|30000    |1680375|
|2 |  MERGE JOIN                   |        |30000    |1680375|
|3 |   SORT                        |        |500000   |1350777|
|4 |    PX PARTITION ITERATOR      |        |500000   |298233 |
|5 |     TABLE SCAN                |t1      |500000   |298233 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |30000    |238654 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|30000    |235814 |
|8 |     PX PARTITION ITERATOR     |        |30000    |235814 |
|9 |      TABLE SCAN               |t2      |30000    |235814 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 46(end)  ************** 

***************   Case 47   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500000   |1758205|
|1 | EXCHANGE OUT DISTR            |:EX10001|500000   |1568885|
|2 |  MERGE OUTER JOIN             |        |500000   |1568885|
|3 |   SORT                        |        |500000   |1458906|
|4 |    PX PARTITION ITERATOR      |        |500000   |309262 |
|5 |     TABLE SCAN                |t1      |500000   |309262 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |30000    |27765  |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|30000    |19245  |
|8 |     PX PARTITION ITERATOR     |        |30000    |19245  |
|9 |      TABLE SCAN               |t2      |30000    |19245  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > ?])
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(1 ; MAX), 
      range_cond([t2.c1 > ?])

*************** Case 47(end)  ************** 

***************   Case 48   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null; 

=============================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST       |
-------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |        |450000   |70334554091|
|1 | PX COORDINATOR          |        |500000   |356592     |
|2 |  EXCHANGE OUT DISTR     |:EX10000|500000   |309262     |
|3 |   PX PARTITION ITERATOR |        |500000   |309262     |
|4 |    TABLE SCAN           |t1      |500000   |309262     |
|5 | MATERIAL                |        |300000   |608147     |
|6 |  PX COORDINATOR         |        |300000   |277391     |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300000   |192197     |
|8 |    PX PARTITION ITERATOR|        |300000   |192197     |
|9 |     TABLE SCAN          |t2      |300000   |192197     |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 > ?]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 48(end)  ************** 

***************   Case 49   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1; 

==================================================================
|ID|OPERATOR                  |NAME    |EST. ROWS   |COST        |
------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000000000|107713419806|
|1 | PX COORDINATOR           |        |300000      |277391      |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300000      |192197      |
|3 |   PX PARTITION ITERATOR  |        |300000      |192197      |
|4 |    TABLE SCAN            |t2      |300000      |192197      |
|5 | MATERIAL                 |        |500000      |540346      |
|6 |  PX COORDINATOR          |        |500000      |356592      |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500000      |309262      |
|8 |    PX PARTITION ITERATOR |        |500000      |309262      |
|9 |     TABLE SCAN           |t1      |500000      |309262      |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 49(end)  ************** 

***************   Case 50   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |2721717|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |2693319|
|2 |  MERGE JOIN                      |        |200000   |2693319|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1713714|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1694782|
|5 |     MERGE JOIN                   |        |200000   |1694782|
|6 |      SORT                        |        |500000   |1350777|
|7 |       PX PARTITION ITERATOR      |        |500000   |298233 |
|8 |        TABLE SCAN                |t1      |500000   |298233 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |128774 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |119308 |
|11|        PX PARTITION ITERATOR     |        |200000   |119308 |
|12|         TABLE SCAN               |t3      |200000   |119308 |
|13|   SORT                           |        |300000   |791977 |
|14|    PX PARTITION ITERATOR         |        |300000   |178962 |
|15|     TABLE SCAN                   |t2      |300000   |178962 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  4 - (#keys=1, [t3.c1]), output([t1.c1], [t3.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  11 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  14 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 50(end)  ************** 

***************   Case 51   ***************

SQL: select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

=========================================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST           |
-------------------------------------------------------------------------
|0 |NESTED-LOOP JOIN                 |        |588060000|1.075369e+14   |
|1 | HASH JOIN                       |        |980100000|583924112      |
|2 |  PX COORDINATOR                 |        |200000   |1831309        |
|3 |   EXCHANGE OUT DISTR            |:EX10001|200000   |1802911        |
|4 |    MERGE JOIN                   |        |200000   |1802911        |
|5 |     SORT                        |        |500000   |1458906        |
|6 |      PX PARTITION ITERATOR      |        |500000   |309262         |
|7 |       TABLE SCAN                |t1      |500000   |309262         |
|8 |     EXCHANGE IN MERGE SORT DISTR|        |200000   |128774         |
|9 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |119308         |
|10|       PX PARTITION ITERATOR     |        |200000   |119308         |
|11|        TABLE SCAN               |t3      |200000   |119308         |
|12|  PX COORDINATOR                 |        |500000   |356592         |
|13|   EXCHANGE OUT DISTR            |:EX20000|500000   |309262         |
|14|    PX PARTITION ITERATOR        |        |500000   |309262         |
|15|     TABLE SCAN                  |tt      |500000   |309262         |
|16| MATERIAL                        |        |300000   |248287         |
|17|  PX COORDINATOR                 |        |300000   |193161         |
|18|   EXCHANGE OUT DISTR            |:EX30000|300000   |178962         |
|19|    PX PARTITION ITERATOR        |        |300000   |178962         |
|20|     TABLE SCAN                  |t2      |300000   |178962         |
=========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  9 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  10 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([tt.c1], [tt.c2]), filter(nil)
  13 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  14 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil)
  18 - output([t2.c1]), filter(nil), dop=1
  19 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  20 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 51(end)  ************** 

***************   Case 52   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

======================================================================
|ID|OPERATOR                              |NAME    |EST. ROWS|COST   |
----------------------------------------------------------------------
|0 |PX COORDINATOR                        |        |1961     |3859492|
|1 | EXCHANGE OUT DISTR                   |:EX10003|1961     |3858936|
|2 |  HASH JOIN                           |        |1961     |3858936|
|3 |   EXCHANGE IN DISTR                  |        |200000   |2995780|
|4 |    EXCHANGE OUT DISTR (PKEY)         |:EX10002|200000   |2957916|
|5 |     MATERIAL                         |        |200000   |2957916|
|6 |      MERGE JOIN                      |        |200000   |2810913|
|7 |       EXCHANGE IN MERGE SORT DISTR   |        |200000   |1831309|
|8 |        EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1802911|
|9 |         MERGE JOIN                   |        |200000   |1802911|
|10|          SORT                        |        |500000   |1458906|
|11|           PX PARTITION ITERATOR      |        |500000   |309262 |
|12|            TABLE SCAN                |t1      |500000   |309262 |
|13|          EXCHANGE IN MERGE SORT DISTR|        |200000   |128774 |
|14|           EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |119308 |
|15|            PX PARTITION ITERATOR     |        |200000   |119308 |
|16|             TABLE SCAN               |t3      |200000   |119308 |
|17|       SORT                           |        |300000   |791977 |
|18|        PX PARTITION ITERATOR         |        |300000   |178962 |
|19|         TABLE SCAN                   |t2      |300000   |178962 |
|20|   PX PARTITION ITERATOR              |        |500000   |309262 |
|21|    TABLE SCAN                        |tt      |500000   |309262 |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2], [t1.c1 + t2.c1 = tt.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t1.c1 + t2.c1]), filter(nil)
  4 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c2], [t1.c1 + t2.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t1.c1 + t2.c1]), filter(nil)
  6 - output([t1.c1], [t1.c2], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  7 - output([t1.c1], [t1.c2], [t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  8 - (#keys=1, [t3.c1]), output([t1.c1], [t1.c2], [t3.c1]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  14 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  15 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  16 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  17 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  18 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  20 - output([tt.c1], [tt.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  21 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true

*************** Case 52(end)  ************** 

***************   Case 53   ***************

SQL: select * from t1 where true; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 53(end)  ************** 

***************   Case 54   ***************

SQL: select * from t1 where 1=2; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 54(end)  ************** 

***************   Case 55   ***************

SQL: select * from t1, t2 where 1+1=2 and t1.c1=t2.c1+1; 

=============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------
|0 |PX COORDINATOR               |        |300000   |1662257|
|1 | EXCHANGE OUT DISTR          |:EX10001|300000   |1548665|
|2 |  HASH JOIN                  |        |300000   |1548665|
|3 |   PX PARTITION ITERATOR     |        |500000   |309262 |
|4 |    TABLE SCAN               |t1      |500000   |309262 |
|5 |   EXCHANGE IN DISTR         |        |300000   |277391 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300000   |192197 |
|7 |     PX PARTITION ITERATOR   |        |300000   |192197 |
|8 |      TABLE SCAN             |t2      |300000   |192197 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1 + ?]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil)
  6 - (#keys=1, [t2.c1 + ?]), output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 55(end)  ************** 

***************   Case 56   ***************

SQL: select * from t1 left join t2 t on t1.c1=t.c1 where false; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500000   |1930764|
|1 | EXCHANGE OUT DISTR            |:EX10001|500000   |1741444|
|2 |  MERGE OUTER JOIN             |        |500000   |1741444|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500000   |356592 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262 |
|5 |     PX PARTITION ITERATOR     |        |500000   |309262 |
|6 |      TABLE SCAN               |t1      |500000   |309262 |
|7 |   SORT                        |        |300000   |1096510|
|8 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|9 |     TABLE SCAN                |t       |300000   |192197 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), sort_keys([t.c1, ASC]), local merge sort
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      access([t.c1], [t.c2], [t.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 56(end)  ************** 

***************   Case 57   ***************

SQL: select * from t1 left join t2 t on 1=1 where false; 

=================================================================
|ID|OPERATOR                 |NAME    |EST. ROWS   |COST        |
-----------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |        |150000000000|126539013545|
|1 | PX COORDINATOR          |        |500000      |356592      |
|2 |  EXCHANGE OUT DISTR     |:EX10000|500000      |309262      |
|3 |   PX PARTITION ITERATOR |        |500000      |309262      |
|4 |    TABLE SCAN           |t1      |500000      |309262      |
|5 | MATERIAL                |        |300000      |608147      |
|6 |  PX COORDINATOR         |        |300000      |277391      |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300000      |192197      |
|8 |    PX PARTITION ITERATOR|        |300000      |192197      |
|9 |     TABLE SCAN          |t       |300000      |192197      |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      conds([1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t.c1], [t.c2], [t.c3]), filter(nil)
  6 - output([t.c1], [t.c2], [t.c3]), filter(nil)
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), dop=1
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      access([t.c1], [t.c2], [t.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 57(end)  ************** 

***************   Case 58   ***************

SQL: select usec_to_time(c1) as modify_time_us from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([usec_to_time(t1.c1)]), filter(nil)
  1 - output([usec_to_time(t1.c1)]), filter(nil), dop=1
  2 - output([usec_to_time(t1.c1)]), filter(nil), 
      force partition granule, asc.
  3 - output([usec_to_time(t1.c1)]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 58(end)  ************** 

***************   Case 59   ***************

SQL: select c1, repeat('ob', 2) as db_name from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |241 |
|1 | PX COORDINATOR MERGE SORT |             |100      |227 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |217 |
|3 |   SORT                    |             |100      |217 |
|4 |    PX PARTITION ITERATOR  |             |100      |90  |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |90  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 59(end)  ************** 

***************   Case 60   ***************

SQL: select 'ob' from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil), dop=1
  2 - output([?]), filter(nil), 
      force partition granule, asc.
  3 - output([?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 60(end)  ************** 

***************   Case 61   ***************

SQL: select c1, 'ob' from t1 where c1 > 100 order by c2; 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |50000    |136739|
|1 | EXCHANGE OUT DISTR       |:EX10000|50000    |132006|
|2 |  SORT                    |        |50000    |132006|
|3 |   PX PARTITION ITERATOR  |        |50000    |30948 |
|4 |    TABLE SCAN            |t1      |50000    |30948 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c1], [?], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [?], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 61(end)  ************** 

***************   Case 62   ***************

SQL: select c1, 1 + 1 from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil)
  1 - output([t1.c1], [?]), filter(nil), dop=1
  2 - output([t1.c1], [?]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 62(end)  ************** 

***************   Case 63   ***************

SQL: select c1, 1 + 1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |214 |
|1 | PX COORDINATOR MERGE SORT |        |100      |200 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |196 |
|3 |   SORT                    |        |100      |196 |
|4 |    PX PARTITION ITERATOR  |        |100      |88  |
|5 |     TABLE SCAN            |t1      |100      |88  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 63(end)  ************** 

***************   Case 64   ***************

SQL: select c1 from t1 union select c2 from t2; 

========================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST   |
--------------------------------------------------------
|0 |HASH UNION DISTINCT     |        |800000   |1371047|
|1 | PX COORDINATOR         |        |500000   |321898 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500000   |298233 |
|3 |   PX PARTITION ITERATOR|        |500000   |298233 |
|4 |    TABLE SCAN          |t1      |500000   |298233 |
|5 | PX COORDINATOR         |        |300000   |213977 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300000   |185579 |
|7 |   PX PARTITION ITERATOR|        |300000   |185579 |
|8 |    TABLE SCAN          |t2      |300000   |185579 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter(nil), dop=1
  7 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 64(end)  ************** 

***************   Case 65   ***************

SQL: select c1 from t1 union all select c2 from t2; 

=======================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST  |
-------------------------------------------------------
|0 |UNION ALL               |        |800000   |799102|
|1 | PX COORDINATOR         |        |500000   |321898|
|2 |  EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|3 |   PX PARTITION ITERATOR|        |500000   |298233|
|4 |    TABLE SCAN          |t1      |500000   |298233|
|5 | PX COORDINATOR         |        |300000   |213977|
|6 |  EXCHANGE OUT DISTR    |:EX20000|300000   |185579|
|7 |   PX PARTITION ITERATOR|        |300000   |185579|
|8 |    TABLE SCAN          |t2      |300000   |185579|
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter(nil), dop=1
  7 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 65(end)  ************** 

***************   Case 66   ***************

SQL: (select c1 from t1) except (select c2 from t2) order by c1; 

==============================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST   |
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |500000   |2505180|
|1 | EXCHANGE OUT DISTR           |:EX10001|500000   |2457850|
|2 |  MERGE EXCEPT DISTINCT       |        |500000   |2457850|
|3 |   SORT                       |        |500000   |1350777|
|4 |    PX PARTITION ITERATOR     |        |500000   |298233 |
|5 |     TABLE SCAN               |t1      |500000   |298233 |
|6 |   SORT                       |        |300000   |885253 |
|7 |    EXCHANGE IN DISTR         |        |300000   |213977 |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|300000   |185579 |
|9 |      PX PARTITION ITERATOR   |        |300000   |185579 |
|10|       TABLE SCAN             |t2      |300000   |185579 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])]), filter(nil), sort_keys([EXCEPT([1]), ASC])
  1 - output([EXCEPT([1])]), filter(nil), dop=1
  2 - output([EXCEPT([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  7 - output([t2.c2]), filter(nil)
  8 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 66(end)  ************** 

***************   Case 67   ***************

SQL: (select c1 from t1) intersect (select c2 from t2) order by c1 limit 100; 

================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST   |
----------------------------------------------------------------
|0 |LIMIT                           |        |100      |2430283|
|1 | PX COORDINATOR MERGE SORT      |        |100      |2430269|
|2 |  EXCHANGE OUT DISTR            |:EX10001|100      |2430260|
|3 |   LIMIT                        |        |100      |2430260|
|4 |    MERGE INTERSECT DISTINCT    |        |100      |2430246|
|5 |     SORT                       |        |500000   |1350777|
|6 |      PX PARTITION ITERATOR     |        |500000   |298233 |
|7 |       TABLE SCAN               |t1      |500000   |298233 |
|8 |     SORT                       |        |300000   |885253 |
|9 |      EXCHANGE IN DISTR         |        |300000   |213977 |
|10|       EXCHANGE OUT DISTR (PKEY)|:EX10000|300000   |185579 |
|11|        PX PARTITION ITERATOR   |        |300000   |185579 |
|12|         TABLE SCAN             |t2      |300000   |185579 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  1 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC])
  2 - output([INTERSECT([1])]), filter(nil), dop=1
  3 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  4 - output([INTERSECT([1])]), filter(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c2]), filter(nil)
  10 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  11 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 67(end)  ************** 

***************   Case 68   ***************

SQL: (select c1 from t1) union (select c2 from t1) union (select c2 from t2); 

=================================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST   |
-----------------------------------------------------------------
|0 |MERGE UNION DISTINCT        |             |1300000  |4522709|
|1 | MERGE UNION DISTINCT       |             |1000000  |3209712|
|2 |  PX COORDINATOR MERGE SORT |             |500000   |1374442|
|3 |   EXCHANGE OUT DISTR       |:EX10000     |500000   |1350777|
|4 |    SORT                    |             |500000   |1350777|
|5 |     PX PARTITION ITERATOR  |             |500000   |298233 |
|6 |      TABLE SCAN            |t1           |500000   |298233 |
|7 |  PX COORDINATOR MERGE SORT |             |500000   |1506236|
|8 |   EXCHANGE OUT DISTR       |:EX20000     |500000   |1458906|
|9 |    SORT                    |             |500000   |1458906|
|10|     PX PARTITION ITERATOR  |             |500000   |309262 |
|11|      TABLE SCAN            |t1(idx_t1_c2)|500000   |309262 |
|12| PX COORDINATOR MERGE SORT  |             |300000   |885253 |
|13|  EXCHANGE OUT DISTR        |:EX30000     |300000   |856854 |
|14|   SORT                     |             |300000   |856854 |
|15|    PX PARTITION ITERATOR   |             |300000   |185579 |
|16|     TABLE SCAN             |t2           |300000   |185579 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  8 - output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  10 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  11 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  12 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  13 - output([t2.c2]), filter(nil), dop=1
  14 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  15 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  16 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 68(end)  ************** 

***************   Case 69   ***************

SQL: (select /*+no_use_px*/ c1 from t1) union (select c2 from t1) union (select c2 from t2) order by c1 limit 100; 

=========================================================================
|ID|OPERATOR                             |NAME         |EST. ROWS|COST  |
-------------------------------------------------------------------------
|0 |LIMIT                                |             |100      |914254|
|1 | MERGE UNION DISTINCT                |             |100      |914241|
|2 |  LIMIT                              |             |100      |531348|
|3 |   MERGE UNION DISTINCT              |             |100      |531335|
|4 |    LIMIT                            |             |100      |214   |
|5 |     PX COORDINATOR MERGE SORT       |             |100      |200   |
|6 |      EXCHANGE OUT DISTR             |:EX10000     |100      |196   |
|7 |       SORT                          |             |100      |196   |
|8 |        PX PARTITION ITERATOR        |             |100      |88    |
|9 |         TABLE SCAN                  |t1           |100      |88    |
|10|    LIMIT                            |             |100      |531055|
|11|     PX COORDINATOR MERGE SORT       |             |100      |531041|
|12|      EXCHANGE OUT DISTR             |:EX20001     |100      |531032|
|13|       LIMIT                         |             |100      |531032|
|14|        MERGE DISTINCT               |             |100      |531018|
|15|         EXCHANGE IN MERGE SORT DISTR|             |100      |420145|
|16|          EXCHANGE OUT DISTR (HASH)  |:EX20000     |100      |420135|
|17|           PX PARTITION ITERATOR     |             |100      |420135|
|18|            MERGE DISTINCT           |             |100      |420135|
|19|             TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
|20|  LIMIT                              |             |100      |382827|
|21|   PX COORDINATOR MERGE SORT         |             |100      |382813|
|22|    EXCHANGE OUT DISTR               |:EX30001     |100      |382804|
|23|     LIMIT                           |             |100      |382804|
|24|      TOP-N SORT                     |             |100      |382790|
|25|       HASH DISTINCT                 |             |101      |382684|
|26|        EXCHANGE IN DISTR            |             |101      |284136|
|27|         EXCHANGE OUT DISTR (HASH)   |:EX30000     |101      |284127|
|28|          HASH DISTINCT              |             |101      |284127|
|29|           PX PARTITION ITERATOR     |             |300000   |185579|
|30|            TABLE SCAN               |t2           |300000   |185579|
=========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), limit(100), offset(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([UNION([1])]), filter(nil), limit(100), offset(nil)
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), dop=1
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  11 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  12 - output([t1.c2]), filter(nil), dop=1
  13 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  14 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  15 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  16 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  17 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  18 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  19 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  20 - output([t2.c2]), filter(nil), limit(100), offset(nil)
  21 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  22 - output([t2.c2]), filter(nil), dop=1
  23 - output([t2.c2]), filter(nil), limit(100), offset(nil)
  24 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(100)
  25 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  26 - output([t2.c2]), filter(nil)
  27 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  28 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  29 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  30 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 69(end)  ************** 

***************   Case 70   ***************

SQL: (select c1 from t1) union (select c2 from t1) intersect (select c2 from t2) order by c1 limit 100; 

==================================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |LIMIT                        |             |100      |4384700|
|1 | MERGE INTERSECT DISTINCT    |             |100      |4384687|
|2 |  MERGE UNION DISTINCT       |             |1000000  |3209712|
|3 |   PX COORDINATOR MERGE SORT |             |500000   |1374442|
|4 |    EXCHANGE OUT DISTR       |:EX10000     |500000   |1350777|
|5 |     SORT                    |             |500000   |1350777|
|6 |      PX PARTITION ITERATOR  |             |500000   |298233 |
|7 |       TABLE SCAN            |t1           |500000   |298233 |
|8 |   PX COORDINATOR MERGE SORT |             |500000   |1506236|
|9 |    EXCHANGE OUT DISTR       |:EX20000     |500000   |1458906|
|10|     SORT                    |             |500000   |1458906|
|11|      PX PARTITION ITERATOR  |             |500000   |309262 |
|12|       TABLE SCAN            |t1(idx_t1_c2)|500000   |309262 |
|13|  PX COORDINATOR MERGE SORT  |             |300000   |885253 |
|14|   EXCHANGE OUT DISTR        |:EX30000     |300000   |856854 |
|15|    SORT                     |             |300000   |856854 |
|16|     PX PARTITION ITERATOR   |             |300000   |185579 |
|17|      TABLE SCAN             |t2           |300000   |185579 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  1 - output([INTERSECT([1])]), filter(nil)
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  9 - output([t1.c2]), filter(nil), dop=1
  10 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  11 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  13 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  14 - output([t2.c2]), filter(nil), dop=1
  15 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  16 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 70(end)  ************** 

***************   Case 71   ***************

SQL: select distinct(c2) from t1; 

===================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST  |
-------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |101      |531027|
|1 | EXCHANGE OUT DISTR            |:EX10001     |101      |531018|
|2 |  MERGE DISTINCT               |             |101      |531018|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |101      |420145|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |101      |420135|
|5 |     PX PARTITION ITERATOR     |             |101      |420135|
|6 |      MERGE DISTINCT           |             |101      |420135|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 71(end)  ************** 

***************   Case 72   ***************

SQL: select distinct(c1) from t4; 

========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |MERGE DISTINCT|    |101      |84035|
|1 | TABLE SCAN   |t4  |100000   |61860|
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 72(end)  ************** 

***************   Case 73   ***************

SQL: select distinct c1, c2 from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 73(end)  ************** 

***************   Case 74   ***************

SQL: select distinct c1, c2 from t4; 

=============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST |
---------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100000   |47311|
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 74(end)  ************** 

***************   Case 75   ***************

SQL: select distinct(t1.c2), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

===================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------------
|0 |PX COORDINATOR                     |        |10001    |2211158|
|1 | EXCHANGE OUT DISTR                |:EX10002|10001    |2209265|
|2 |  HASH DISTINCT                    |        |10001    |2209265|
|3 |   EXCHANGE IN DISTR               |        |10001    |2086191|
|4 |    EXCHANGE OUT DISTR (HASH)      |:EX10001|10001    |2084298|
|5 |     HASH DISTINCT                 |        |10001    |2084298|
|6 |      MERGE JOIN                   |        |300000   |1961224|
|7 |       SORT                        |        |500000   |1458906|
|8 |        PX PARTITION ITERATOR      |        |500000   |309262 |
|9 |         TABLE SCAN                |t1      |500000   |309262 |
|10|       EXCHANGE IN MERGE SORT DISTR|        |300000   |213977 |
|11|        EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |185579 |
|12|         PX PARTITION ITERATOR     |        |300000   |185579 |
|13|          TABLE SCAN               |t2      |300000   |185579 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c2]), filter(nil)
  1 - output([t1.c2], [t2.c2]), filter(nil), dop=1
  2 - output([t1.c2], [t2.c2]), filter(nil), 
      distinct([t1.c2], [t2.c2])
  3 - output([t1.c2], [t2.c2]), filter(nil)
  4 - (#keys=2, [t1.c2], [t2.c2]), output([t1.c2], [t2.c2]), filter(nil), dop=1
  5 - output([t1.c2], [t2.c2]), filter(nil), 
      distinct([t1.c2], [t2.c2])
  6 - output([t1.c2], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  11 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2]), filter(nil), dop=1
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  13 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 75(end)  ************** 

***************   Case 76   ***************

SQL: select distinct(t1.c1), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1509691|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1467094|
|2 |  MERGE JOIN                   |        |300000   |1467094|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500000   |321898 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |298233 |
|5 |     PX PARTITION ITERATOR     |        |500000   |298233 |
|6 |      TABLE SCAN               |t1      |500000   |298233 |
|7 |   SORT                        |        |300000   |856854 |
|8 |    PX PARTITION ITERATOR      |        |300000   |185579 |
|9 |     TABLE SCAN                |t2      |300000   |185579 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2]), filter(nil)
  1 - output([t1.c1], [t2.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 76(end)  ************** 

***************   Case 77   ***************

SQL: select distinct t4.c1, t4.c2, t2.c2 from t4, t2 where t4.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------
|0 |PX COORDINATOR               |        |99000    |1060847|
|1 | EXCHANGE OUT DISTR          |:EX10001|99000    |1042104|
|2 |  MERGE JOIN                 |        |99000    |1042104|
|3 |   EXCHANGE IN DISTR         |        |100000   |71326  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100000   |61860  |
|5 |     TABLE SCAN              |t4      |100000   |61860  |
|6 |   SORT                      |        |300000   |856854 |
|7 |    PX PARTITION ITERATOR    |        |300000   |185579 |
|8 |     TABLE SCAN              |t2      |300000   |185579 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil)
  1 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [t4.c2]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 77(end)  ************** 

***************   Case 78   ***************

SQL: select distinct c1 as ali_name from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 78(end)  ************** 

***************   Case 79   ***************

SQL: select distinct c2 as ali_name from t1; 

===================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST  |
-------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |101      |531027|
|1 | EXCHANGE OUT DISTR            |:EX10001     |101      |531018|
|2 |  MERGE DISTINCT               |             |101      |531018|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |101      |420145|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |101      |420135|
|5 |     PX PARTITION ITERATOR     |             |101      |420135|
|6 |      MERGE DISTINCT           |             |101      |420135|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 79(end)  ************** 

***************   Case 80   ***************

SQL: select distinct c1 * c2 from t1; 

============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST  |
------------------------------------------------------------
|0 |PX COORDINATOR               |        |500000   |925905|
|1 | EXCHANGE OUT DISTR          |:EX10001|500000   |878575|
|2 |  HASH DISTINCT              |        |500000   |878575|
|3 |   EXCHANGE IN DISTR         |        |500000   |356592|
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|500000   |309262|
|5 |     PX PARTITION ITERATOR   |        |500000   |309262|
|6 |      TABLE SCAN             |t1      |500000   |309262|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 * t1.c2]), filter(nil)
  1 - output([t1.c1 * t1.c2]), filter(nil), dop=1
  2 - output([t1.c1 * t1.c2]), filter(nil), 
      distinct([t1.c1 * t1.c2])
  3 - output([t1.c1 * t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1 * t1.c2]), output([t1.c1 * t1.c2]), filter(nil), dop=1
  5 - output([t1.c1 * t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1 * t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 80(end)  ************** 

***************   Case 81   ***************

SQL: select distinct 1, 2 from t1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |1        |37  |
|1 | PX COORDINATOR         |        |1        |36  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|3 |   PX PARTITION ITERATOR|        |1        |36  |
|4 |    TABLE SCAN          |t1      |1        |36  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(1), offset(nil)
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), dop=1
  3 - output([1]), filter(nil), 
      force partition granule, asc.
  4 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 81(end)  ************** 

***************   Case 82   ***************

SQL: select distinct c2 from t4 order by c2 limit 3; 

=================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST|
-------------------------------------------------
|0 |LIMIT          |             |3        |2106|
|1 | MERGE DISTINCT|             |3        |2106|
|2 |  TABLE SCAN   |t4(idx_t4_c2)|3000     |1441|
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 82(end)  ************** 

***************   Case 83   ***************

SQL: select distinct c2 from t4 order by c2; 

=================================================
|ID|OPERATOR      |NAME         |EST. ROWS|COST |
-------------------------------------------------
|0 |MERGE DISTINCT|             |101      |69486|
|1 | TABLE SCAN   |t4(idx_t4_c2)|100000   |47311|
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  1 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 83(end)  ************** 

***************   Case 84   ***************

SQL: select distinct c2 from t4 order by c3; 

=====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST |
-----------------------------------------------------
|0 |SORT           |                |101      |86368|
|1 | MERGE DISTINCT|                |101      |86240|
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|100000   |64066|
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC])
  1 - output([t4.c2], [t4.c3]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 84(end)  ************** 

***************   Case 85   ***************

SQL: select distinct c1, c2 from t4 order by c3; 

=============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST |
---------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c3)|100000   |64066|
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 85(end)  ************** 

***************   Case 86   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

======================================================
|ID|OPERATOR        |NAME            |EST. ROWS|COST |
------------------------------------------------------
|0 |LIMIT           |                |3        |86287|
|1 | TOP-N SORT     |                |3        |86286|
|2 |  MERGE DISTINCT|                |101      |86240|
|3 |   TABLE SCAN   |t4(idx_t4_c2_c3)|100000   |64066|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      distinct([t4.c2])
  3 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 86(end)  ************** 

***************   Case 87   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

======================================================
|ID|OPERATOR        |NAME            |EST. ROWS|COST |
------------------------------------------------------
|0 |LIMIT           |                |3        |86287|
|1 | TOP-N SORT     |                |3        |86286|
|2 |  MERGE DISTINCT|                |101      |86240|
|3 |   TABLE SCAN   |t4(idx_t4_c2_c3)|100000   |64066|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      distinct([t4.c2])
  3 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 87(end)  ************** 

***************   Case 88   ***************

SQL: select distinct c2 from t5 order by c3 limit 3; 

======================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST  |
----------------------------------------------------------------------
|0 |LIMIT                             |             |3        |275038|
|1 | PX COORDINATOR MERGE SORT        |             |3        |275037|
|2 |  EXCHANGE OUT DISTR              |:EX10001     |3        |275037|
|3 |   LIMIT                          |             |3        |275037|
|4 |    TOP-N SORT                    |             |3        |275037|
|5 |     MERGE DISTINCT               |             |101      |274991|
|6 |      EXCHANGE IN MERGE SORT DISTR|             |101      |208467|
|7 |       EXCHANGE OUT DISTR (HASH)  |:EX10000     |101      |208457|
|8 |        PX PARTITION ITERATOR     |             |101      |208457|
|9 |         MERGE DISTINCT           |             |101      |208457|
|10|          TABLE SCAN              |t5(idx_t5_c2)|300000   |141933|
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3]), filter(nil), limit(3), offset(nil)
  4 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC]), topn(3)
  5 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  6 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  7 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3]), filter(nil), dop=1
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  10 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 88(end)  ************** 

***************   Case 89   ***************

SQL: select distinct c2 from t5 order by c3; 

====================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST  |
--------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |             |101      |275127|
|1 | EXCHANGE OUT DISTR             |:EX10001     |101      |275118|
|2 |  SORT                          |             |101      |275118|
|3 |   MERGE DISTINCT               |             |101      |274991|
|4 |    EXCHANGE IN MERGE SORT DISTR|             |101      |208467|
|5 |     EXCHANGE OUT DISTR (HASH)  |:EX10000     |101      |208457|
|6 |      PX PARTITION ITERATOR     |             |101      |208457|
|7 |       MERGE DISTINCT           |             |101      |208457|
|8 |        TABLE SCAN              |t5(idx_t5_c2)|300000   |141933|
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), sort_keys([t5.c3, ASC])
  1 - output([t5.c2], [t5.c3]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  3 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  4 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  5 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3]), filter(nil), dop=1
  6 - output([t5.c2], [t5.c3]), filter(nil), 
      force partition granule, asc.
  7 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 89(end)  ************** 

***************   Case 90   ***************

SQL: select * from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 90(end)  ************** 

***************   Case 91   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |58  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |57  |
|2 |  PX PARTITION ITERATOR|        |2        |57  |
|3 |   TABLE GET           |t1      |2        |57  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])

*************** Case 91(end)  ************** 

***************   Case 92   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7 or c1 = 8; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |3        |63  |
|1 | EXCHANGE OUT DISTR    |:EX10000|3        |63  |
|2 |  PX PARTITION ITERATOR|        |3        |63  |
|3 |   TABLE GET           |t1      |3        |63  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p[2-3]), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], [8 ; 8], 
      range_cond([(T_OP_OR, t1.c1 = ?, t1.c1 = ?, t1.c1 = ?)])

*************** Case 92(end)  ************** 

***************   Case 93   ***************

SQL: select c1 as alias_name from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 93(end)  ************** 

***************   Case 94   ***************

SQL: select * from t5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |300000   |234794|
|1 | EXCHANGE OUT DISTR    |:EX10000|300000   |192197|
|2 |  PX PARTITION ITERATOR|        |300000   |192197|
|3 |   TABLE SCAN          |t5      |300000   |192197|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 94(end)  ************** 

***************   Case 95   ***************

SQL: select * from t5 where c2 =3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2970     |2351|
|1 | EXCHANGE OUT DISTR    |:EX10000|2970     |1930|
|2 |  PX PARTITION ITERATOR|        |2970     |1930|
|3 |   TABLE SCAN          |t5      |2970     |1930|
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(3,MIN ; 3,MAX), 
      range_cond([t5.c2 = ?])

*************** Case 95(end)  ************** 

***************   Case 96   ***************

SQL: select * from t5 where c2 = 5 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t5  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[5,7 ; 5,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 96(end)  ************** 

***************   Case 97   ***************

SQL: select * from t5 where c2 = 6 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t5  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[6,7 ; 6,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 97(end)  ************** 

***************   Case 98   ***************

SQL: select * from t5 where c2 = 11 and c3 = 8; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t5  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[11,8 ; 11,8], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 98(end)  ************** 

***************   Case 99   ***************

SQL: select c1 from t6; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |300000   |193161|
|1 | EXCHANGE OUT DISTR    |:EX10000|300000   |178962|
|2 |  PX PARTITION ITERATOR|        |300000   |178962|
|3 |   TABLE SCAN          |t6      |300000   |178962|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1]), filter(nil)
  1 - output([t6.c1]), filter(nil), dop=1
  2 - output([t6.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 99(end)  ************** 

***************   Case 100   ***************

SQL: select * from t6 where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t6  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t6.c1]), range[3 ; 3], 
      range_cond([t6.c1 = ?])

*************** Case 100(end)  ************** 

***************   Case 101   ***************

SQL: select * from t6 where c1 = 10; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t6  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t6.c1]), range[10 ; 10], 
      range_cond([t6.c1 = ?])

*************** Case 101(end)  ************** 

***************   Case 102   ***************

SQL: select t1.c2 + t2.c1 from t1, t2 where t1.c1 = t2.c2 and t1.c1 and t1.c1 = 1 and t2.c1 = 2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |53  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t2      |1        |53  |
|4 | PX COORDINATOR           |        |1        |53  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |53  |
|6 |   TABLE GET              |t1      |1        |53  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1]), filter(nil)
  2 - output([t2.c1]), filter(nil), is_single, dop=1
  3 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2]), partitions(p2), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c2]), filter(nil)
  5 - output([t1.c2]), filter(nil), is_single, dop=1
  6 - output([t1.c2]), filter([t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 102(end)  ************** 

***************   Case 103   ***************

SQL: select t1.c1 from t1,t2 where t1.c1+1=t2.c1; 

=============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------
|0 |PX COORDINATOR               |        |300000   |1245919|
|1 | EXCHANGE OUT DISTR          |:EX10001|300000   |1217521|
|2 |  HASH JOIN                  |        |300000   |1217521|
|3 |   PX PARTITION ITERATOR     |        |300000   |178962 |
|4 |    TABLE SCAN               |t2      |300000   |178962 |
|5 |   EXCHANGE IN DISTR         |        |500000   |321898 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500000   |298233 |
|7 |     PX PARTITION ITERATOR   |        |500000   |298233 |
|8 |      TABLE SCAN             |t1      |500000   |298233 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c1 + ?]), filter(nil)
  6 - (#keys=1, [t1.c1 + ?]), output([t1.c1], [t1.c1 + ?]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      force partition granule, asc.
  8 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 103(end)  ************** 

***************   Case 104   ***************

SQL: select t1.c1, t2.c1 from t1, t2 where t1.c1 = 1 and t2.c1 = 1 and t1.c1 = t2.c1; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |105 |
|1 | EXCHANGE OUT REMOTE        |    |1        |105 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|3 |   TABLE GET                |t1  |1        |52  |
|4 |   TABLE GET                |t2  |1        |52  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil)
  1 - output([t1.c1], [t2.c1]), filter(nil)
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?], [t1.c1 = ?])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?], [t2.c1 = ?])

*************** Case 104(end)  ************** 

***************   Case 105   ***************

SQL: select /*+ leading(t2 t1 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |2896399|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |2763875|
|2 |  MERGE JOIN                      |        |200000   |2763875|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |300000   |1855036|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300000   |1741444|
|5 |     MERGE JOIN                   |        |300000   |1741444|
|6 |      SORT                        |        |300000   |1096510|
|7 |       PX PARTITION ITERATOR      |        |300000   |192197 |
|8 |        TABLE SCAN                |t2      |300000   |192197 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |500000   |356592 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262 |
|11|        PX PARTITION ITERATOR     |        |500000   |309262 |
|12|         TABLE SCAN               |t1      |500000   |309262 |
|13|   SORT                           |        |200000   |721212 |
|14|    PX PARTITION ITERATOR         |        |200000   |128131 |
|15|     TABLE SCAN                   |t3      |200000   |128131 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  10 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 105(end)  ************** 

***************   Case 106   ***************

SQL: select /*+ leading(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |3389317|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |3256793|
|2 |  MERGE JOIN                      |        |200000   |3256793|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1582656|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1469064|
|5 |     MERGE JOIN                   |        |200000   |1469064|
|6 |      SORT                        |        |300000   |1096510|
|7 |       PX PARTITION ITERATOR      |        |300000   |192197 |
|8 |        TABLE SCAN                |t2      |300000   |192197 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|11|        PX PARTITION ITERATOR     |        |200000   |128131 |
|12|         TABLE SCAN               |t3      |200000   |128131 |
|13|   SORT                           |        |500000   |1458906|
|14|    PX PARTITION ITERATOR         |        |500000   |309262 |
|15|     TABLE SCAN                   |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 106(end)  ************** 

***************   Case 107   ***************

SQL: select /*+ use_merge(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |3389317|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |3256793|
|2 |  MERGE JOIN                      |        |200000   |3256793|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1582656|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1469064|
|5 |     MERGE JOIN                   |        |200000   |1469064|
|6 |      SORT                        |        |300000   |1096510|
|7 |       PX PARTITION ITERATOR      |        |300000   |192197 |
|8 |        TABLE SCAN                |t2      |300000   |192197 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|11|        PX PARTITION ITERATOR     |        |200000   |128131 |
|12|         TABLE SCAN               |t3      |200000   |128131 |
|13|   SORT                           |        |500000   |1458906|
|14|    PX PARTITION ITERATOR         |        |500000   |309262 |
|15|     TABLE SCAN                   |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 107(end)  ************** 

***************   Case 108   ***************

SQL: select /*+ use_merge(t1)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |3389317|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |3256793|
|2 |  MERGE JOIN                      |        |200000   |3256793|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1582656|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1469064|
|5 |     MERGE JOIN                   |        |200000   |1469064|
|6 |      SORT                        |        |300000   |1096510|
|7 |       PX PARTITION ITERATOR      |        |300000   |192197 |
|8 |        TABLE SCAN                |t2      |300000   |192197 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|11|        PX PARTITION ITERATOR     |        |200000   |128131 |
|12|         TABLE SCAN               |t3      |200000   |128131 |
|13|   SORT                           |        |500000   |1458906|
|14|    PX PARTITION ITERATOR         |        |500000   |309262 |
|15|     TABLE SCAN                   |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 108(end)  ************** 

***************   Case 109   ***************

SQL: select /*+ use_merge(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |3389317|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |3256793|
|2 |  MERGE JOIN                      |        |200000   |3256793|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1582656|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1469064|
|5 |     MERGE JOIN                   |        |200000   |1469064|
|6 |      SORT                        |        |300000   |1096510|
|7 |       PX PARTITION ITERATOR      |        |300000   |192197 |
|8 |        TABLE SCAN                |t2      |300000   |192197 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|11|        PX PARTITION ITERATOR     |        |200000   |128131 |
|12|         TABLE SCAN               |t3      |200000   |128131 |
|13|   SORT                           |        |500000   |1458906|
|14|    PX PARTITION ITERATOR         |        |500000   |309262 |
|15|     TABLE SCAN                   |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 109(end)  ************** 

***************   Case 110   ***************

SQL: select /*+ use_nl(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |2896399|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |2763875|
|2 |  MERGE JOIN                      |        |200000   |2763875|
|3 |   SORT                           |        |200000   |721212 |
|4 |    PX PARTITION ITERATOR         |        |200000   |128131 |
|5 |     TABLE SCAN                   |t3      |200000   |128131 |
|6 |   EXCHANGE IN MERGE SORT DISTR   |        |300000   |1855036|
|7 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300000   |1741444|
|8 |     MERGE JOIN                   |        |300000   |1741444|
|9 |      SORT                        |        |300000   |1096510|
|10|       PX PARTITION ITERATOR      |        |300000   |192197 |
|11|        TABLE SCAN                |t2      |300000   |192197 |
|12|      EXCHANGE IN MERGE SORT DISTR|        |500000   |356592 |
|13|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262 |
|14|        PX PARTITION ITERATOR     |        |500000   |309262 |
|15|         TABLE SCAN               |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  7 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  13 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 110(end)  ************** 

***************   Case 111   ***************

SQL: select /*+ use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |3389317|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |3256793|
|2 |  MERGE JOIN                      |        |200000   |3256793|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1582656|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1469064|
|5 |     MERGE JOIN                   |        |200000   |1469064|
|6 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|8 |        PX PARTITION ITERATOR     |        |200000   |128131 |
|9 |         TABLE SCAN               |t3      |200000   |128131 |
|10|      SORT                        |        |300000   |1096510|
|11|       PX PARTITION ITERATOR      |        |300000   |192197 |
|12|        TABLE SCAN                |t2      |300000   |192197 |
|13|   SORT                           |        |500000   |1458906|
|14|    PX PARTITION ITERATOR         |        |500000   |309262 |
|15|     TABLE SCAN                   |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  7 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 111(end)  ************** 

***************   Case 112   ***************

SQL: select /*+ ordered, use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST    |
-------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |13008192|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |12875668|
|2 |  NESTED-LOOP JOIN                |        |200000   |12875668|
|3 |   EXCHANGE IN DISTR              |        |300000   |1855036 |
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300000   |1741444 |
|5 |     MERGE JOIN                   |        |300000   |1741444 |
|6 |      EXCHANGE IN MERGE SORT DISTR|        |500000   |356592  |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262  |
|8 |        PX PARTITION ITERATOR     |        |500000   |309262  |
|9 |         TABLE SCAN               |t1      |500000   |309262  |
|10|      SORT                        |        |300000   |1096510 |
|11|       PX PARTITION ITERATOR      |        |300000   |192197  |
|12|        TABLE SCAN                |t2      |300000   |192197  |
|13|   PX PARTITION ITERATOR          |        |1        |36      |
|14|    TABLE GET                     |t3      |1        |36      |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 112(end)  ************** 

***************   Case 113   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |3389317|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |3256793|
|2 |  MERGE JOIN                      |        |200000   |3256793|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1582656|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1469064|
|5 |     MERGE JOIN                   |        |200000   |1469064|
|6 |      SORT                        |        |300000   |1096510|
|7 |       PX PARTITION ITERATOR      |        |300000   |192197 |
|8 |        TABLE SCAN                |t2      |300000   |192197 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|11|        PX PARTITION ITERATOR     |        |200000   |128131 |
|12|         TABLE SCAN               |t3      |200000   |128131 |
|13|   SORT                           |        |500000   |1458906|
|14|    PX PARTITION ITERATOR         |        |500000   |309262 |
|15|     TABLE SCAN                   |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 113(end)  ************** 

***************   Case 114   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |3389317|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |3256793|
|2 |  MERGE JOIN                      |        |200000   |3256793|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200000   |1582656|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200000   |1469064|
|5 |     MERGE JOIN                   |        |200000   |1469064|
|6 |      SORT                        |        |300000   |1096510|
|7 |       PX PARTITION ITERATOR      |        |300000   |192197 |
|8 |        TABLE SCAN                |t2      |300000   |192197 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200000   |184927 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200000   |128131 |
|11|        PX PARTITION ITERATOR     |        |200000   |128131 |
|12|         TABLE SCAN               |t3      |200000   |128131 |
|13|   SORT                           |        |500000   |1458906|
|14|    PX PARTITION ITERATOR         |        |500000   |309262 |
|15|     TABLE SCAN                   |t1      |500000   |309262 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 114(end)  ************** 

***************   Case 115   ***************

SQL: select /*+ ordered, use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST    |
-------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200000   |21341108|
|1 | EXCHANGE OUT DISTR               |:EX10002|200000   |21208584|
|2 |  MERGE JOIN                      |        |200000   |21208584|
|3 |   SORT                           |        |300000   |20299745|
|4 |    EXCHANGE IN DISTR             |        |300000   |19278913|
|5 |     EXCHANGE OUT DISTR (PKEY)    |:EX10001|300000   |19165320|
|6 |      MATERIAL                    |        |300000   |19165320|
|7 |       NESTED-LOOP JOIN           |        |300000   |18724311|
|8 |        EXCHANGE IN DISTR         |        |500000   |356592  |
|9 |         EXCHANGE OUT DISTR (PKEY)|:EX10000|500000   |309262  |
|10|          PX PARTITION ITERATOR   |        |500000   |309262  |
|11|           TABLE SCAN             |t1      |500000   |309262  |
|12|        PX PARTITION ITERATOR     |        |1        |36      |
|13|         TABLE GET                |t2      |1        |36      |
|14|   SORT                           |        |200000   |721212  |
|15|    PX PARTITION ITERATOR         |        |200000   |128131  |
|16|     TABLE SCAN                   |t3      |200000   |128131  |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  8 - output([t1.c1], [t1.c2], [PARTITION_ID]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2], [PARTITION_ID]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  15 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  16 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 115(end)  ************** 

***************   Case 116   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

============================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST   |
------------------------------------------------------------
|0 |PX COORDINATOR         |             |5911     |1821489|
|1 | EXCHANGE OUT DISTR    |:EX10000     |5911     |1820650|
|2 |  PX PARTITION ITERATOR|             |5911     |1820650|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|5911     |1820650|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 116(end)  ************** 

***************   Case 117   ***************

SQL: select /*+ index(t5 idx_t5_c3) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

============================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST   |
------------------------------------------------------------
|0 |PX COORDINATOR         |             |5911     |1821489|
|1 | EXCHANGE OUT DISTR    |:EX10000     |5911     |1820650|
|2 |  PX PARTITION ITERATOR|             |5911     |1820650|
|3 |   TABLE SCAN          |t5(idx_t5_c3)|5911     |1820650|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 117(end)  ************** 

***************   Case 118   ***************

SQL: select /*+ index(t5 primary) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |5911     |218153|
|1 | EXCHANGE OUT DISTR    |:EX10000|5911     |217314|
|2 |  PX PARTITION ITERATOR|        |5911     |217314|
|3 |   TABLE SCAN          |t5      |5911     |217314|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 118(end)  ************** 

***************   Case 119   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ * from t5; 

============================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST   |
------------------------------------------------------------
|0 |PX COORDINATOR         |             |300000   |1838130|
|1 | EXCHANGE OUT DISTR    |:EX10000     |300000   |1795533|
|2 |  PX PARTITION ITERATOR|             |300000   |1795533|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|300000   |1795533|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 119(end)  ************** 

***************   Case 120   ***************

SQL: select /*+ full(t5) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |5911     |218153|
|1 | EXCHANGE OUT DISTR    |:EX10000|5911     |217314|
|2 |  PX PARTITION ITERATOR|        |5911     |217314|
|3 |   TABLE SCAN          |t5      |5911     |217314|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 120(end)  ************** 

***************   Case 121   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2) where c1 =2 or c2 = 5; 

============================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST   |
------------------------------------------------------------
|0 |PX COORDINATOR         |             |5911     |1821489|
|1 | EXCHANGE OUT DISTR    |:EX10000     |5911     |1820650|
|2 |  PX PARTITION ITERATOR|             |5911     |1820650|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|5911     |1820650|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 121(end)  ************** 

***************   Case 122   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2, primary) where c1 =2 or c2 = 5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |5911     |218153|
|1 | EXCHANGE OUT DISTR    |:EX10000|5911     |217314|
|2 |  PX PARTITION ITERATOR|        |5911     |217314|
|3 |   TABLE SCAN          |t5      |5911     |217314|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 122(end)  ************** 

***************   Case 123   ***************

SQL: select c1, c2 from t5 use index for order by (idx_t5_c2) where c1 =2 or c2 = 5; 

============================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST   |
------------------------------------------------------------
|0 |PX COORDINATOR         |             |5911     |1821489|
|1 | EXCHANGE OUT DISTR    |:EX10000     |5911     |1820650|
|2 |  PX PARTITION ITERATOR|             |5911     |1820650|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|5911     |1820650|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 123(end)  ************** 

***************   Case 124   ***************

SQL: select c1, c2 from t5 force index for group by (idx_t5_c2) where c1 =2 or c2 = 5; 

============================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST   |
------------------------------------------------------------
|0 |PX COORDINATOR         |             |5911     |1821489|
|1 | EXCHANGE OUT DISTR    |:EX10000     |5911     |1820650|
|2 |  PX PARTITION ITERATOR|             |5911     |1820650|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|5911     |1820650|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 124(end)  ************** 

***************   Case 125   ***************

SQL: select c1, c2 from t5 use index (primary) where c1 =2 or c2 = 5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |5911     |218153|
|1 | EXCHANGE OUT DISTR    |:EX10000|5911     |217314|
|2 |  PX PARTITION ITERATOR|        |5911     |217314|
|3 |   TABLE SCAN          |t5      |5911     |217314|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 125(end)  ************** 

***************   Case 126   ***************

SQL: select c1, c2 from t1 ignore index (idx_t1_c2) where c1 =2 or c2 = 5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |4951     |351593|
|1 | EXCHANGE OUT DISTR    |:EX10000|4951     |351124|
|2 |  PX PARTITION ITERATOR|        |4951     |351124|
|3 |   TABLE SCAN          |t1      |4951     |351124|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = ? OR t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 126(end)  ************** 

***************   Case 127   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2) where c1 =2 or c2 = 5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |5911     |218153|
|1 | EXCHANGE OUT DISTR    |:EX10000|5911     |217314|
|2 |  PX PARTITION ITERATOR|        |5911     |217314|
|3 |   TABLE SCAN          |t5      |5911     |217314|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 127(end)  ************** 

***************   Case 128   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2, idx_t5_c3) where c1 =2 or c2 = 5; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |5911     |218153|
|1 | EXCHANGE OUT DISTR    |:EX10000|5911     |217314|
|2 |  PX PARTITION ITERATOR|        |5911     |217314|
|3 |   TABLE SCAN          |t5      |5911     |217314|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 128(end)  ************** 

***************   Case 129   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c3, primary) where c1 =2 or c2 = 5; 

============================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST   |
------------------------------------------------------------
|0 |PX COORDINATOR         |             |5911     |1821489|
|1 | EXCHANGE OUT DISTR    |:EX10000     |5911     |1820650|
|2 |  PX PARTITION ITERATOR|             |5911     |1820650|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|5911     |1820650|
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 129(end)  ************** 

***************   Case 130   ***************

SQL: select max(c2) from t1 where c1 = 2; 

==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |EXCHANGE IN REMOTE  |     |1        |53  |
|1 | EXCHANGE OUT REMOTE|     |1        |53  |
|2 |  SCALAR GROUP BY   |     |1        |53  |
|3 |   SUBPLAN SCAN     |VIEW1|1        |53  |
|4 |    TABLE GET       |t1   |1        |53  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.c2)]), filter(nil)
  1 - output([T_FUN_MAX(VIEW1.c2)]), filter(nil)
  2 - output([T_FUN_MAX(VIEW1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.c2)])
  3 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  4 - output([t1.c2]), filter([(T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c2]), partitions(p2), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 130(end)  ************** 

***************   Case 131   ***************

SQL: select @@sql_mode, c1 from t1 limit 1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |1        |37  |
|1 | PX COORDINATOR         |        |1        |36  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|3 |   PX PARTITION ITERATOR|        |1        |36  |
|4 |    TABLE SCAN          |t1      |1        |36  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 131(end)  ************** 

***************   Case 132   ***************

SQL: select 1+2 from dual; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 132(end)  ************** 

***************   Case 133   ***************

SQL: select 1 + 2 from dual where 1 > 2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter([0])
      values({?})

*************** Case 133(end)  ************** 

***************   Case 134   ***************

SQL: select c1 from t1 where c1 = 0 and c2 = 2; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[0 ; 0], 
      range_cond([t1.c1 = ?])

*************** Case 134(end)  ************** 

***************   Case 135   ***************

SQL: select /*+ ordered, use_merge(t3) */ * from t2, t3 where t2.c2 = t3.c1 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |53  |
|1 | TABLE GET                |t2  |1        |53  |
|2 | TABLE GET                |t3  |1        |53  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])

*************** Case 135(end)  ************** 

***************   Case 136   ***************

SQL: select /*+ use_merge(t3) */ * from t2, t3 where t2.c1 = t3.c2 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |53  |
|1 | TABLE GET                |t3  |1        |53  |
|2 | TABLE GET                |t2  |1        |53  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter([t3.c2 = ?]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])

*************** Case 136(end)  ************** 

***************   Case 137   ***************

SQL: select c1 as c from t1 partition (p4, p3) as t where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t   |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil)
  1 - output([t.c1]), filter(nil)
  2 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t.c1]), range[3 ; 3], 
      range_cond([t.c1 = ?])

*************** Case 137(end)  ************** 

***************   Case 138   ***************

SQL: select c1 from t1 partition (p1) where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 138(end)  ************** 

***************   Case 139   ***************

SQL: select count(*) from t1 partition(p1); 

==============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST |
----------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |78755|
|1 | EXCHANGE OUT REMOTE|    |1        |78755|
|2 |  SCALAR GROUP BY   |    |1        |78755|
|3 |   TABLE SCAN       |t1  |100000   |59654|
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil)
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 139(end)  ************** 

***************   Case 140   ***************

SQL: select * from t1 partition(p1) join t2 partition(p2) on t1.c1 = t2.c1; 

===================================================
|ID|OPERATOR            |NAME    |EST. ROWS|COST  |
---------------------------------------------------
|0 |MERGE JOIN          |        |100001   |250702|
|1 | PX COORDINATOR     |        |100000   |71326 |
|2 |  EXCHANGE OUT DISTR|:EX10000|100000   |61860 |
|3 |   TABLE SCAN       |t1      |100000   |61860 |
|4 | PX COORDINATOR     |        |100000   |92464 |
|5 |  EXCHANGE OUT DISTR|:EX20000|100000   |64066 |
|6 |   TABLE SCAN       |t2      |100000   |64066 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), is_single, dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 140(end)  ************** 

***************   Case 141   ***************

SQL: explain select * from t1; 

=================================
|ID|OPERATOR|NAME|EST. ROWS|COST|
---------------------------------
|0 |VALUES  |    |0        |0   |
=================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil)

*************** Case 141(end)  ************** 

***************   Case 142   ***************

SQL: explain format = json select * from t1; 

=================================
|ID|OPERATOR|NAME|EST. ROWS|COST|
---------------------------------
|0 |VALUES  |    |0        |0   |
=================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil)

*************** Case 142(end)  ************** 

***************   Case 143   ***************

SQL: select sum(c1) from t1 where c1 = 3 group by c2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil)
  1 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil)
  2 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 143(end)  ************** 

***************   Case 144   ***************

SQL: select sum(1) as c from t1 where c1 = 3 group by c2 having c2 = 5 order by c1 limit 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t1  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil)
  2 - output([?]), filter([t1.c2 = ?]), 
      access([t1.c2]), partitions(p3), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 144(end)  ************** 

***************   Case 145   ***************

SQL: select sum(t7.c2) from t7, t8  where t7.c1 = t8.c1 and t7.c2 = 4 group by t7.c1 order by t7.c1 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |144 |
|1 | NESTED-LOOP JOIN|    |1        |144 |
|2 |  TABLE SCAN     |t7  |1        |107 |
|3 |  TABLE GET      |t8  |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t7.c2, DECIMAL(11, 0))]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  2 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 145(end)  ************** 

***************   Case 146   ***************

SQL: select c1, sum(c1+c2) from t2_no_part where c3 > 100 group by c2, c1; 

==========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST |
------------------------------------------
|0 |TABLE SCAN|t2_no_part|10000    |80811|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_no_part.c1], [cast(t2_no_part.c1 + t2_no_part.c2, DECIMAL(12, 0))]), filter([t2_no_part.c3 > ?]), 
      access([t2_no_part.c3], [t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 146(end)  ************** 

***************   Case 147   ***************

SQL: select * from t2_no_part X, t2_no_part Y where X.c1 = Y.c1; 

====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|X   |100000   |64066|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c3], [X.c1], [X.c2], [X.c3]), filter(nil), 
      access([X.c1], [X.c2], [X.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([X.c1]), range(MIN ; MAX)always true

*************** Case 147(end)  ************** 

***************   Case 148   ***************

SQL: select count(*) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil)
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 148(end)  ************** 

***************   Case 149   ***************

SQL: select sum(c2) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  1 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  2 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 149(end)  ************** 

***************   Case 150   ***************

SQL: select sum(c1) + count(c2) from t2_no_part; 

===============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST |
-----------------------------------------------
|0 |SCALAR GROUP BY|          |1        |86260|
|1 | TABLE SCAN    |t2_no_part|100000   |61860|
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1) + T_FUN_COUNT(t2_no_part.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2_no_part.c1)], [T_FUN_COUNT(t2_no_part.c2)])
  1 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 150(end)  ************** 

***************   Case 151   ***************

SQL: select sum(c1) from t2_no_part group by c2 order by sum(c1); 

===============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST  |
-----------------------------------------------
|0 |SORT          |          |101      |100239|
|1 | HASH GROUP BY|          |101      |100056|
|2 |  TABLE SCAN  |t2_no_part|100000   |61860 |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), sort_keys([T_FUN_SUM(t2_no_part.c1), ASC])
  1 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), 
      group([t2_no_part.c2]), agg_func([T_FUN_SUM(t2_no_part.c1)])
  2 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 151(end)  ************** 

***************   Case 152   ***************

SQL: select * from t4 where c2 = 3 and c3 = 4; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|10       |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3], [t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(3,4,MIN ; 3,4,MAX), 
      range_cond([t4.c2 = ?], [t4.c3 = ?])

*************** Case 152(end)  ************** 

***************   Case 153   ***************

SQL: select * from t4 where c1 = 2 and c2 = 3; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[2,3 ; 2,3], 
      range_cond([t4.c1 = ?], [t4.c2 = ?])

*************** Case 153(end)  ************** 

***************   Case 154   ***************

SQL: select * from t4, t7 where t4.c1 + 2 + 2 = t7.c1; 

======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |HASH JOIN  |    |100001   |359571|
|1 | TABLE SCAN|t7  |100000   |61860 |
|2 | TABLE SCAN|t4  |100000   |64066 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 + ? + ? = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3], [t4.c1 + ? + ?]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 154(end)  ************** 

***************   Case 155   ***************

SQL: select sum(c1 + 1) from t4 group by c1, c2; 

=============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST |
---------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100000   |47311|
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t4.c1 + ?, DECIMAL(12, 0))]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 155(end)  ************** 

***************   Case 156   ***************

SQL: select /*+ frozen_version(10) */ * from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      hint(frozen_version:"10-0-0", read_consistency:1), 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 156(end)  ************** 

***************   Case 157   ***************

SQL: select /*+index(t4 idx_t4_c2_c3)*/ c2, c3 from t4 where c2 = 3 and c3 = 4 and c1 = 5; 

==============================================
|ID|OPERATOR |NAME            |EST. ROWS|COST|
----------------------------------------------
|0 |TABLE GET|t4(idx_t4_c2_c3)|1        |53  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range[3,4,5 ; 3,4,5], 
      range_cond([t4.c2 = ?], [t4.c3 = ?], [t4.c1 = ?])

*************** Case 157(end)  ************** 

***************   Case 158   ***************

SQL: select * from t4 where c1 = 1 and c2 > 5 and c3 > 8; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |10       |109 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c3 > ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(1,5 ; 1,MAX), 
      range_cond([t4.c1 = ?], [t4.c2 > ?])

*************** Case 158(end)  ************** 

***************   Case 159   ***************

SQL: select * from t4 where c1 in (1) and c2 in (1, 2, 3, 4, 5); 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |5        |73  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[1,1 ; 1,1], [1,2 ; 1,2], [1,3 ; 1,3], [1,4 ; 1,4], [1,5 ; 1,5], 
      range_cond([t4.c1 = ?], [t4.c2 IN (?, ?, ?, ?, ?)])

*************** Case 159(end)  ************** 

***************   Case 160   ***************

SQL: select * from t1 where c1 in (c1, 2, 3, 4); 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |398455|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |351124|
|2 |  PX PARTITION ITERATOR|        |500000   |351124|
|3 |   TABLE SCAN          |t1      |500000   |351124|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 IN (t1.c1, ?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 160(end)  ************** 

***************   Case 161   ***************

SQL: select * from t1 where (1+ 1) in (2); 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 161(end)  ************** 

***************   Case 162   ***************

SQL: select * from t1 where 1 in (c1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])

*************** Case 162(end)  ************** 

***************   Case 163   ***************

SQL: select * from t1 where 1 in (c1, c2); 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |4951     |351593|
|1 | EXCHANGE OUT DISTR    |:EX10000|4951     |351124|
|2 |  PX PARTITION ITERATOR|        |4951     |351124|
|3 |   TABLE SCAN          |t1      |4951     |351124|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([? IN (t1.c1, t1.c2)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 163(end)  ************** 

***************   Case 164   ***************

SQL: select * from t1 where c1 = 1 or c2 = 1; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |UNION ALL               |             |2476     |4729|
|1 | PX COORDINATOR         |             |1        |53  |
|2 |  EXCHANGE OUT DISTR    |:EX10000     |1        |52  |
|3 |   TABLE GET            |t1           |1        |52  |
|4 | PX COORDINATOR         |             |2475     |3731|
|5 |  EXCHANGE OUT DISTR    |:EX20000     |2475     |3497|
|6 |   PX PARTITION ITERATOR|             |2475     |3497|
|7 |    TABLE SCAN          |t1(idx_t1_c2)|2475     |3497|
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter([lnnvl(t1.c1 = ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 164(end)  ************** 

***************   Case 165   ***************

SQL: select * from t1 where (1+ 1) in (1); 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 165(end)  ************** 

***************   Case 166   ***************

SQL: select * from t1 where c1 in (1, 2, 3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |4        |68  |
|1 | EXCHANGE OUT DISTR    |:EX10000|4        |68  |
|2 |  PX PARTITION ITERATOR|        |4        |68  |
|3 |   TABLE GET           |t1      |4        |68  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[1-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], [2 ; 2], [3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?, ?, ?)])

*************** Case 166(end)  ************** 

***************   Case 167   ***************

SQL: select * from t1 where exists (select * from t2 limit 0); 

========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST  |
--------------------------------------------------------
|0 |SUBPLAN FILTER           |        |250000   |425603|
|1 | PX COORDINATOR          |        |500000   |356592|
|2 |  EXCHANGE OUT DISTR     |:EX10000|500000   |309262|
|3 |   PX PARTITION ITERATOR |        |500000   |309262|
|4 |    TABLE SCAN           |t1      |500000   |309262|
|5 | LIMIT                   |        |0        |0     |
|6 |  PX COORDINATOR         |        |0        |0     |
|7 |   EXCHANGE OUT DISTR    |:EX20000|0        |0     |
|8 |    PX PARTITION ITERATOR|        |0        |0     |
|9 |     TABLE SCAN          |t2      |0        |0     |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), limit(0), offset(nil)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), dop=1
  8 - output([1]), filter(nil), 
      force partition granule, asc.
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(0), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 167(end)  ************** 

***************   Case 168   ***************

SQL: select * from t7,t8 where t7.c1=t8.c1 order by t7.c1,t7.c2; 

======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |MERGE JOIN |    |100001   |210632|
|1 | TABLE SCAN|t7  |100000   |61860 |
|2 | TABLE SCAN|t8  |100000   |61860 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 168(end)  ************** 

***************   Case 169   ***************

SQL: select * from t7,t8 where t7.c1=t8.c2 order by t7.c1,t7.c2; 

=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |MERGE JOIN  |    |99000    |420528|
|1 | TABLE SCAN |t7  |100000   |61860 |
|2 | SORT       |    |100000   |272349|
|3 |  TABLE SCAN|t8  |100000   |61860 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c2]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  3 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 169(end)  ************** 

***************   Case 170   ***************

SQL: select c1/c2 as v,sum(c1) from t1 group by v order by v; 

==============================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST   |
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |500000   |2525324|
|1 | EXCHANGE OUT DISTR           |:EX10001|500000   |2477993|
|2 |  MERGE GROUP BY              |        |500000   |2477993|
|3 |   SORT                       |        |500000   |2298762|
|4 |    EXCHANGE IN DISTR         |        |500000   |356592 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|500000   |309262 |
|6 |      PX PARTITION ITERATOR   |        |500000   |309262 |
|7 |       TABLE SCAN             |t1      |500000   |309262 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 / t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c1 / t1.c2, ASC])
  1 - output([T_FUN_SUM(t1.c1)], [t1.c1 / t1.c2]), filter(nil), dop=1
  2 - output([T_FUN_SUM(t1.c1)], [t1.c1 / t1.c2]), filter(nil), 
      group([t1.c1 / t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil), sort_keys([t1.c1 / t1.c2, ASC])
  4 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil)
  5 - (#keys=1, [t1.c1 / t1.c2]), output([t1.c1], [t1.c1 / t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 170(end)  ************** 

***************   Case 171   ***************

SQL: select c2 from t1 for update; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 171(end)  ************** 

***************   Case 172   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1) for update; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1649801|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1550408|
|2 |  MERGE JOIN                   |        |300000   |1550408|
|3 |   SORT                        |        |300000   |1096510|
|4 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|5 |     TABLE SCAN                |t2      |300000   |192197 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|8 |     PX PARTITION ITERATOR     |        |300000   |178962 |
|9 |      TABLE SCAN               |t6      |300000   |178962 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1]), filter(nil), dop=1
  8 - output([t6.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 172(end)  ************** 

***************   Case 173   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4 order by c3, c2; 

===============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST  |
-----------------------------------------------
|0 |SORT       |             |100000   |182724|
|1 | TABLE SCAN|t4(idx_t4_c3)|100000   |64066 |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), sort_keys([t4.c3, ASC], [t4.c2, ASC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c3], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c3], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 173(end)  ************** 

***************   Case 174   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4, t9 where t4.c1 = t9.c1; 

======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |MERGE JOIN |    |99000    |207833|
|1 | TABLE SCAN|t4  |100000   |61860 |
|2 | TABLE SCAN|t9  |100000   |59654 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), 
      equal_conds([t4.c1 = t9.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t9.c1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 174(end)  ************** 

***************   Case 175   ***************

SQL: select * from t4 where t4.c1 = 1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |990      |667 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 175(end)  ************** 

***************   Case 176   ***************

SQL: select * from t7 group by c1 order by c1 desc; 

===========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST |
-------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|100000   |61860|
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 176(end)  ************** 

***************   Case 177   ***************

SQL: select * from t4 order by c1,c2 desc; 

======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |SORT       |    |100000   |182724|
|1 | TABLE SCAN|t4  |100000   |64066 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC], [t4.c2, DESC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 177(end)  ************** 

***************   Case 178   ***************

SQL: select * from t4 order by c1 desc,c2 desc; 

===========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST |
-------------------------------------------
|0 |TABLE SCAN|t4(Reverse)|100000   |64066|
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 178(end)  ************** 

***************   Case 179   ***************

SQL: select * from (select * from t4 union select * from t4) as a; 

===============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST  |
-----------------------------------------------
|0 |MERGE UNION DISTINCT|    |200000   |215134|
|1 | TABLE SCAN         |t4  |100000   |64066 |
|2 | TABLE SCAN         |t4  |100000   |64066 |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 179(end)  ************** 

***************   Case 180   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t2.c1=2; 

=============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------
|0 |PX COORDINATOR               |        |500000   |1717290|
|1 | EXCHANGE OUT DISTR          |:EX10001|500000   |1527970|
|2 |  MERGE OUTER JOIN           |        |500000   |1527970|
|3 |   SORT                      |        |500000   |1458906|
|4 |    PX PARTITION ITERATOR    |        |500000   |309262 |
|5 |     TABLE SCAN              |t1      |500000   |309262 |
|6 |   EXCHANGE IN DISTR         |        |1        |53     |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |53     |
|8 |     TABLE GET               |t2      |1        |53     |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), is_single, dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 180(end)  ************** 

***************   Case 181   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1=2; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |106 |
|1 | EXCHANGE OUT REMOTE        |    |1        |105 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|3 |   TABLE GET                |t1  |1        |52  |
|4 |   TABLE GET                |t2  |1        |53  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 181(end)  ************** 

***************   Case 182   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 and t2.c1=2; 

=============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------
|0 |PX COORDINATOR               |        |300000   |1251561|
|1 | EXCHANGE OUT DISTR          |:EX10001|300000   |1137969|
|2 |  MERGE OUTER JOIN           |        |300000   |1137969|
|3 |   SORT                      |        |300000   |1096510|
|4 |    PX PARTITION ITERATOR    |        |300000   |192197 |
|5 |     TABLE SCAN              |t2      |300000   |192197 |
|6 |   EXCHANGE IN DISTR         |        |1        |53     |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |52     |
|8 |     TABLE GET               |t1      |1        |52     |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t2.c1 = ?])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 182(end)  ************** 

***************   Case 183   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 where t2.c1=2; 

=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |EXCHANGE IN REMOTE      |    |1        |106 |
|1 | EXCHANGE OUT REMOTE    |    |1        |105 |
|2 |  NESTED-LOOP OUTER JOIN|    |1        |105 |
|3 |   TABLE GET            |t2  |1        |53  |
|4 |   TABLE GET            |t1  |1        |52  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=true
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?], [t1.c1 = ?])

*************** Case 183(end)  ************** 

***************   Case 184   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 and t2.c1=2; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500000   |1828192|
|1 | EXCHANGE OUT DISTR            |:EX10001|500000   |1638872|
|2 |  MERGE FULL OUTER JOIN        |        |500000   |1638872|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500000   |356592 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |309262 |
|5 |     PX PARTITION ITERATOR     |        |500000   |309262 |
|6 |      TABLE SCAN               |t1      |500000   |309262 |
|7 |   SORT                        |        |300000   |1096510|
|8 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|9 |     TABLE SCAN                |t2      |300000   |192197 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t2.c1 = ?])
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 184(end)  ************** 

***************   Case 185   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 where t2.c1=2; 

=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |EXCHANGE IN REMOTE      |    |1        |106 |
|1 | EXCHANGE OUT REMOTE    |    |1        |105 |
|2 |  NESTED-LOOP OUTER JOIN|    |1        |105 |
|3 |   TABLE GET            |t2  |1        |53  |
|4 |   TABLE GET            |t1  |1        |52  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=true
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?], [t1.c1 = ?])

*************** Case 185(end)  ************** 

***************   Case 186   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1=t2.c1 limit 1); 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1983005|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1940408|
|2 |  MERGE JOIN                   |        |300000   |1940408|
|3 |   SORT                        |        |500000   |1458906|
|4 |    PX PARTITION ITERATOR      |        |500000   |309262 |
|5 |     TABLE SCAN                |t1      |500000   |309262 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|8 |     PX PARTITION ITERATOR     |        |300000   |178962 |
|9 |      TABLE SCAN               |t2      |300000   |178962 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 186(end)  ************** 

***************   Case 187   ***************

SQL: select c1 from (select c1, c2 from t1 limit 1) t; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |1        |37  |
|1 | PX COORDINATOR         |        |1        |36  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|3 |   PX PARTITION ITERATOR|        |1        |36  |
|4 |    TABLE SCAN          |t1      |1        |36  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 187(end)  ************** 

***************   Case 188   ***************

SQL: select sum(c) from (select c1 as c from t1 union select c1 as c from t1) as a; 

==========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST   |
----------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |1445547|
|1 | PX COORDINATOR           |        |1        |1254535|
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |1254535|
|3 |   MERGE GROUP BY         |        |1        |1254535|
|4 |    SUBPLAN SCAN          |a       |1000000  |1063522|
|5 |     PX PARTITION ITERATOR|        |1000000  |925500 |
|6 |      MERGE UNION DISTINCT|        |1000000  |925500 |
|7 |       TABLE SCAN         |t1      |500000   |298233 |
|8 |       TABLE SCAN         |t1      |500000   |298233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(a.c))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(a.c))])
  1 - output([T_FUN_SUM(a.c)]), filter(nil)
  2 - output([T_FUN_SUM(a.c)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  4 - output([a.c]), filter(nil), 
      access([a.c])
  5 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule, asc.
  6 - output([UNION([1])]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 188(end)  ************** 

***************   Case 189   ***************

SQL: select * from t2 where 'cb' <= c3; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |30000    |341227|
|1 | EXCHANGE OUT DISTR    |:EX10000|30000    |332707|
|2 |  PX PARTITION ITERATOR|        |30000    |332707|
|3 |   TABLE SCAN          |t2      |30000    |332707|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter([? <= t2.c3]), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 189(end)  ************** 

***************   Case 190   ***************

SQL: select t7.c1 = t8.c2 from t7, t8 where t7.c1 = t8.c1; 

======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |MERGE JOIN |    |100001   |208426|
|1 | TABLE SCAN|t7  |100000   |59654 |
|2 | TABLE SCAN|t8  |100000   |61860 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1 = t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 190(end)  ************** 

***************   Case 191   ***************

SQL: select t11.c2 from (select c1,c2 from t4 limit 1) as t11 , t6 where t11.c1>t6.c1; 

===============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST  |
---------------------------------------------------------------
|0 |PX COORDINATOR                  |        |100000   |138627|
|1 | EXCHANGE OUT DISTR             |:EX10001|100000   |124428|
|2 |  NESTED-LOOP JOIN              |        |100000   |124428|
|3 |   EXCHANGE IN DISTR            |        |1        |37    |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|1        |37    |
|5 |     SUBPLAN SCAN               |t11     |1        |37    |
|6 |      TABLE SCAN                |t4      |1        |36    |
|7 |   PX PARTITION ITERATOR        |        |100000   |59654 |
|8 |    TABLE SCAN                  |t6      |100000   |59654 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t11.c2]), filter(nil)
  1 - output([t11.c2]), filter(nil), dop=1
  2 - output([t11.c2]), filter(nil), 
      conds(nil), nl_params_([t11.c1]), batch_join=false
  3 - output([t11.c1], [t11.c2]), filter(nil)
  4 - output([t11.c1], [t11.c2]), filter(nil), is_single, dop=1
  5 - output([t11.c1], [t11.c2]), filter(nil), 
      access([t11.c1], [t11.c2])
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([1]), filter(nil), 
      access all, force partition granule, asc.
  8 - output([1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX), 
      range_cond([? > t6.c1])

*************** Case 191(end)  ************** 

***************   Case 192   ***************

SQL: select t11.c2 from (select c1,c2 from t4) t11 left join t6 on t11.c1=1; 

==================================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST       |
------------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |             |297000000|11123516396|
|1 | TABLE SCAN              |t4(idx_t4_c2)|100000   |47311      |
|2 | MATERIAL                |             |300000   |248287     |
|3 |  PX COORDINATOR         |             |300000   |193161     |
|4 |   EXCHANGE OUT DISTR    |:EX10000     |300000   |178962     |
|5 |    PX PARTITION ITERATOR|             |300000   |178962     |
|6 |     TABLE SCAN          |t6           |300000   |178962     |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      conds([t4.c1 = ?]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), dop=1
  5 - output([1]), filter(nil), 
      force partition granule, asc.
  6 - output([1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 192(end)  ************** 

***************   Case 193   ***************

SQL: select * from t2,t4 where t2.c1=t4.c1; 

=============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------
|0 |PX COORDINATOR               |        |99000    |1330869|
|1 | EXCHANGE OUT DISTR          |:EX10001|99000    |1288698|
|2 |  MERGE JOIN                 |        |99000    |1288698|
|3 |   SORT                      |        |300000   |1096510|
|4 |    PX PARTITION ITERATOR    |        |300000   |192197 |
|5 |     TABLE SCAN              |t2      |300000   |192197 |
|6 |   EXCHANGE IN DISTR         |        |100000   |78265  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100000   |64066  |
|8 |     TABLE SCAN              |t4      |100000   |64066  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 193(end)  ************** 

***************   Case 194   ***************

SQL: select * from t2,t6 where t2.c1=t6.c1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1684816|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1571224|
|2 |  MERGE JOIN                   |        |300000   |1571224|
|3 |   SORT                        |        |300000   |1096510|
|4 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|5 |     TABLE SCAN                |t2      |300000   |192197 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |213977 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |185579 |
|8 |     PX PARTITION ITERATOR     |        |300000   |185579 |
|9 |      TABLE SCAN               |t6      |300000   |185579 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2]), filter(nil), dop=1
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 194(end)  ************** 

***************   Case 195   ***************

SQL: select * from t2,t6,t7 where t2.c1=t6.c1 and t6.c1=t7.c1; 

=================================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST   |
-----------------------------------------------------------------
|0 |PX COORDINATOR                   |        |100000   |2393487|
|1 | EXCHANGE OUT DISTR              |:EX10002|100000   |2346157|
|2 |  MERGE JOIN                     |        |100000   |2346157|
|3 |   EXCHANGE IN MERGE SORT DISTR  |        |100000   |1135130|
|4 |    EXCHANGE OUT DISTR (PKEY)    |:EX10001|100000   |1116198|
|5 |     MATERIAL                    |        |100000   |1116198|
|6 |      MERGE JOIN                 |        |100000   |1042697|
|7 |       SORT                      |        |300000   |856854 |
|8 |        PX PARTITION ITERATOR    |        |300000   |185579 |
|9 |         TABLE SCAN              |t6      |300000   |185579 |
|10|       EXCHANGE IN DISTR         |        |100000   |71326  |
|11|        EXCHANGE OUT DISTR (PKEY)|:EX10000|100000   |61860  |
|12|         TABLE SCAN              |t7      |100000   |61860  |
|13|   SORT                          |        |300000   |1096510|
|14|    PX PARTITION ITERATOR        |        |300000   |192197 |
|15|     TABLE SCAN                  |t2      |300000   |192197 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), sort_keys([t6.c1, ASC])
  4 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil)
  6 - output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t6.c1 = t7.c1]), other_conds(nil)
  7 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  10 - output([t7.c1], [t7.c2]), filter(nil)
  11 - (#keys=1, [t7.c1]), output([t7.c1], [t7.c2]), filter(nil), is_single, dop=1
  12 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  14 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 195(end)  ************** 

***************   Case 196   ***************

SQL: select c1 from t2 union select c1 from t6; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |600000   |1210956|
|1 | EXCHANGE OUT DISTR            |:EX10001|600000   |1182558|
|2 |  MERGE UNION DISTINCT         |        |600000   |1182558|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|5 |     PX PARTITION ITERATOR     |        |300000   |178962 |
|6 |      TABLE SCAN               |t2      |300000   |178962 |
|7 |   SORT                        |        |300000   |791977 |
|8 |    PX PARTITION ITERATOR      |        |300000   |178962 |
|9 |     TABLE SCAN                |t6      |300000   |178962 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t6.c1]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  8 - output([t6.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 196(end)  ************** 

***************   Case 197   ***************

SQL: select c1 from t2 union all select c1 from t6; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |600000   |583741|
|1 | EXCHANGE OUT DISTR    |:EX10000|600000   |555343|
|2 |  PX PARTITION ITERATOR|        |600000   |555343|
|3 |   UNION ALL           |        |600000   |555343|
|4 |    TABLE SCAN         |t2      |300000   |178962|
|5 |    TABLE SCAN         |t6      |300000   |178962|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([UNION([1])]), filter(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 197(end)  ************** 

***************   Case 198   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1); 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1649801|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1550408|
|2 |  MERGE JOIN                   |        |300000   |1550408|
|3 |   SORT                        |        |300000   |1096510|
|4 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|5 |     TABLE SCAN                |t2      |300000   |192197 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|8 |     PX PARTITION ITERATOR     |        |300000   |178962 |
|9 |      TABLE SCAN               |t6      |300000   |178962 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1]), filter(nil), dop=1
  8 - output([t6.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 198(end)  ************** 

***************   Case 199   ***************

SQL: select * from t2 where exists (select * from t4 where t2.c1=t4.c1 limit 1); 

===========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST |
-----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |87760|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |87727|
|2 |  NESTED-LOOP JOIN           |        |100      |87727|
|3 |   EXCHANGE IN DISTR         |        |101      |84053|
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|101      |84048|
|5 |     SUBPLAN SCAN            |VIEW2   |101      |84048|
|6 |      MERGE DISTINCT         |        |101      |84035|
|7 |       TABLE SCAN            |t4      |100000   |61860|
|8 |   PX PARTITION ITERATOR     |        |1        |36   |
|9 |    TABLE GET                |t2      |1        |36   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.t4.c1]), batch_join=false
  3 - output([VIEW2.VIEW1.t4.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.t4.c1]), output([VIEW2.VIEW1.t4.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.t4.c1]), filter(nil), 
      access([VIEW2.VIEW1.t4.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 199(end)  ************** 

***************   Case 200   ***************

SQL: select * from t2 where exists (select * from t1 where t2.c1=t1.c1 limit 1); 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1806143|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1706750|
|2 |  MERGE JOIN                   |        |300000   |1706750|
|3 |   SORT                        |        |300000   |1096510|
|4 |    PX PARTITION ITERATOR      |        |300000   |192197 |
|5 |     TABLE SCAN                |t2      |300000   |192197 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500000   |321898 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500000   |298233 |
|8 |     PX PARTITION ITERATOR     |        |500000   |298233 |
|9 |      TABLE SCAN               |t1      |500000   |298233 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 200(end)  ************** 

***************   Case 201   ***************

SQL: select sum(c1) as c from t1 union select sum(c1) as c from t1; 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |MERGE UNION DISTINCT      |        |2        |978492|
|1 | SCALAR GROUP BY          |        |1        |489246|
|2 |  PX COORDINATOR          |        |1        |393739|
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |393739|
|4 |    MERGE GROUP BY        |        |1        |393739|
|5 |     PX PARTITION ITERATOR|        |500000   |298233|
|6 |      TABLE SCAN          |t1      |500000   |298233|
|7 | SCALAR GROUP BY          |        |1        |489246|
|8 |  PX COORDINATOR          |        |1        |393739|
|9 |   EXCHANGE OUT DISTR     |:EX20000|1        |393739|
|10|    MERGE GROUP BY        |        |1        |393739|
|11|     PX PARTITION ITERATOR|        |500000   |298233|
|12|      TABLE SCAN          |t1      |500000   |298233|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  8 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  9 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  10 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  11 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 201(end)  ************** 

***************   Case 202   ***************

SQL: select sum(c) from (select sum(c1) as c from t1 union select sum(c1) as c from t1) as a; 

===========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST  |
-----------------------------------------------------------
|0 |SCALAR GROUP BY             |        |1        |978492|
|1 | SUBPLAN SCAN               |a       |2        |978492|
|2 |  MERGE UNION DISTINCT      |        |2        |978492|
|3 |   SCALAR GROUP BY          |        |1        |489246|
|4 |    PX COORDINATOR          |        |1        |393739|
|5 |     EXCHANGE OUT DISTR     |:EX10000|1        |393739|
|6 |      MERGE GROUP BY        |        |1        |393739|
|7 |       PX PARTITION ITERATOR|        |500000   |298233|
|8 |        TABLE SCAN          |t1      |500000   |298233|
|9 |   SCALAR GROUP BY          |        |1        |489246|
|10|    PX COORDINATOR          |        |1        |393739|
|11|     EXCHANGE OUT DISTR     |:EX20000|1        |393739|
|12|      MERGE GROUP BY        |        |1        |393739|
|13|       PX PARTITION ITERATOR|        |500000   |298233|
|14|        TABLE SCAN          |t1      |500000   |298233|
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  1 - output([a.c]), filter(nil), 
      access([a.c])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  5 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  6 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  10 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  11 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  12 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  13 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  14 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 202(end)  ************** 

***************   Case 203   ***************

SQL: select * from t4 where c1; 

====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t4  |98010    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 203(end)  ************** 

***************   Case 204   ***************

SQL: select * from t4, t4 t where t4.c1; 

==========================================================
|ID|OPERATOR                  |NAME|EST. ROWS |COST      |
----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |9801000000|7140500363|
|1 | TABLE SCAN               |t   |100000    |64066     |
|2 | MATERIAL                 |    |98010     |126467    |
|3 |  TABLE SCAN              |t4  |98010     |72438     |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t.c1], [t.c2], [t.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1], [t.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 204(end)  ************** 

***************   Case 205   ***************

SQL: select * from t4 left join t4 a on t4.c1; 

======================================================
|ID|OPERATOR              |NAME|EST. ROWS |COST      |
------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |9801000000|8021350309|
|1 | TABLE SCAN           |t4  |100000    |64066     |
|2 | MATERIAL             |    |100000    |119192    |
|3 |  TABLE SCAN          |a   |100000    |64066     |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      conds([t4.c1]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([a.c1], [a.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 205(end)  ************** 

***************   Case 206   ***************

SQL: select t1.c2  from t1,t2 where t2.c1 in(t1.c1); 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1983005|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1940408|
|2 |  MERGE JOIN                   |        |300000   |1940408|
|3 |   SORT                        |        |500000   |1458906|
|4 |    PX PARTITION ITERATOR      |        |500000   |309262 |
|5 |     TABLE SCAN                |t1      |500000   |309262 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|8 |     PX PARTITION ITERATOR     |        |300000   |178962 |
|9 |      TABLE SCAN               |t2      |300000   |178962 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 206(end)  ************** 

***************   Case 207   ***************

SQL: select  * from t3 join t4 on t3.c1>t4.c1 where t4.c1 in (t3.c1, t3.c1); 

================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST   |
----------------------------------------------------------------
|0 |PX COORDINATOR                  |        |66000    |3779923|
|1 | EXCHANGE OUT DISTR             |:EX10001|66000    |3751809|
|2 |  NESTED-LOOP JOIN              |        |66000    |3751809|
|3 |   EXCHANGE IN DISTR            |        |100000   |78265  |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|100000   |64066  |
|5 |     TABLE SCAN                 |t4      |100000   |64066  |
|6 |   PX PARTITION ITERATOR        |        |1        |36     |
|7 |    TABLE GET                   |t3      |1        |36     |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  1 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), dop=1
  2 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access all, force partition granule, asc.
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 > ?], [? IN (t3.c1, t3.c1)])

*************** Case 207(end)  ************** 

***************   Case 208   ***************

SQL: select * from t1 where c1 in (select t2.c1 from t2 left join t3 on t2.c1=t3.c1); 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300000   |1983005|
|1 | EXCHANGE OUT DISTR            |:EX10001|300000   |1940408|
|2 |  MERGE JOIN                   |        |300000   |1940408|
|3 |   SORT                        |        |500000   |1458906|
|4 |    PX PARTITION ITERATOR      |        |500000   |309262 |
|5 |     TABLE SCAN                |t1      |500000   |309262 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |193161 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |178962 |
|8 |     PX PARTITION ITERATOR     |        |300000   |178962 |
|9 |      TABLE SCAN               |t2      |300000   |178962 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 208(end)  ************** 

***************   Case 209   ***************

SQL: select /*+use_merge(t10,t11)*/* from t10, t11 where t10.c2=t11.c2; 

=========================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST     |
---------------------------------------------------------
|0 |PX COORDINATOR         |        |392040000|345107975|
|1 | EXCHANGE OUT DISTR    |:EX10000|392040000|233776377|
|2 |  PX PARTITION ITERATOR|        |392040000|233776377|
|3 |   MERGE JOIN          |        |392040000|233776377|
|4 |    SORT               |        |200000   |604693   |
|5 |     TABLE SCAN        |t10     |200000   |128131   |
|6 |    SORT               |        |200000   |604693   |
|7 |     TABLE SCAN        |t11     |200000   |128131   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil)
  1 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), dop=1
  2 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      equal_conds([t10.c2 = t11.c2]), other_conds(nil)
  4 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), sort_keys([t10.c2, ASC])
  5 - output([t10.c2], [t10.c1], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c1], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), sort_keys([t11.c2, ASC])
  7 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil), 
      access([t11.c2], [t11.c1], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 209(end)  ************** 

***************   Case 210   ***************

SQL: select c1 from t1 where c1 not in (select c1 from t2 where c2 not in (select c2 from t2)); 

====================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST       |
--------------------------------------------------------------------
|0 |PX COORDINATOR                  |        |497060   |26322809581|
|1 | EXCHANGE OUT DISTR             |:EX10003|497060   |26322786055|
|2 |  MERGE ANTI JOIN               |        |497060   |26322786055|
|3 |   SORT                         |        |500000   |1350777    |
|4 |    PX PARTITION ITERATOR       |        |500000   |298233     |
|5 |     TABLE SCAN                 |t1      |500000   |298233     |
|6 |   SORT                         |        |2941     |26321364118|
|7 |    EXCHANGE IN DISTR           |        |2941     |26321359752|
|8 |     EXCHANGE OUT DISTR (PKEY)  |:EX10002|2941     |26321359613|
|9 |      SUBPLAN SCAN              |VIEW2   |2941     |26321359613|
|10|       NESTED-LOOP ANTI JOIN    |        |2941     |26321359207|
|11|        MATERIAL                |        |300000   |324229     |
|12|         EXCHANGE IN DISTR      |        |300000   |213977     |
|13|          EXCHANGE OUT DISTR    |:EX10000|300000   |185579     |
|14|           PX PARTITION ITERATOR|        |300000   |185579     |
|15|            TABLE SCAN          |t2      |300000   |185579     |
|16|        MATERIAL                |        |300000   |324229     |
|17|         EXCHANGE IN DISTR      |        |300000   |213977     |
|18|          EXCHANGE OUT DISTR    |:EX10001|300000   |185579     |
|19|           PX PARTITION ITERATOR|        |300000   |185579     |
|20|            TABLE SCAN          |t2      |300000   |185579     |
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([VIEW2.c1]), filter(nil), sort_keys([VIEW2.c1, ASC])
  7 - output([VIEW2.c1]), filter(nil)
  8 - (#keys=1, [VIEW2.c1]), output([VIEW2.c1]), filter(nil), is_single, dop=1
  9 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  10 - output([t2.c1]), filter(nil), 
      conds([(T_OP_OR, t2.c2 = t2.c2, (T_OP_IS, t2.c2, NULL, 0), (T_OP_IS, t2.c2, NULL, 0))]), nl_params_(nil), batch_join=false
  11 - output([t2.c1], [t2.c2]), filter(nil)
  12 - output([t2.c1], [t2.c2]), filter(nil)
  13 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  14 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  16 - output([t2.c2]), filter(nil)
  17 - output([t2.c2]), filter(nil)
  18 - output([t2.c2]), filter(nil), dop=1
  19 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  20 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 210(end)  ************** 

***************   Case 211   ***************

SQL: select distinct c1 from t1 order by c2; 

===============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500000   |1506236|
|1 | EXCHANGE OUT DISTR       |:EX10000     |500000   |1458906|
|2 |  SORT                    |             |500000   |1458906|
|3 |   PX PARTITION ITERATOR  |             |500000   |309262 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500000   |309262 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 211(end)  ************** 

***************   Case 212   ***************

SQL: SELECT c1, c2  FROM t1 WHERE c2 IN (ROUND(-1), 0, '5', '1'); 

==========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST |
----------------------------------------------------------
|0 |PX COORDINATOR         |             |19800    |14132|
|1 | EXCHANGE OUT DISTR    |:EX10000     |19800    |12257|
|2 |  PX PARTITION ITERATOR|             |19800    |12257|
|3 |   TABLE SCAN          |t1(idx_t1_c2)|19800    |12257|
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(-1,MIN ; -1,MAX), (0,MIN ; 0,MAX), (5,MIN ; 5,MAX), (1,MIN ; 1,MAX), 
      range_cond([t1.c2 IN (?, ?, ?, ?)])

*************** Case 212(end)  ************** 

***************   Case 213   ***************

SQL: select count(*) from (select count(*) as a  from t4) t ; 

====================================================
|ID|OPERATOR         |NAME         |EST. ROWS|COST |
----------------------------------------------------
|0 |SCALAR GROUP BY  |             |1        |66413|
|1 | SUBPLAN SCAN    |t            |1        |66413|
|2 |  SCALAR GROUP BY|             |1        |66413|
|3 |   TABLE SCAN    |t4(idx_t4_c2)|100000   |47311|
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil), 
      access(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output([1]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 213(end)  ************** 

***************   Case 214   ***************

SQL: (select * from t1 where c1 = 2) union all (select * from t1 where c1 = 2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |105 |
|1 | EXCHANGE OUT REMOTE|    |2        |105 |
|2 |  UNION ALL         |    |2        |105 |
|3 |   TABLE GET        |t1  |1        |52  |
|4 |   TABLE GET        |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 214(end)  ************** 

***************   Case 215   ***************

SQL: select * from t1 X, t1 Y where X.c1 = Y.c1 and X.c1 = 1 and Y.c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |X   |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c1], [X.c2]), filter(nil)
  1 - output([X.c1], [X.c2]), filter(nil)
  2 - output([X.c1], [X.c2]), filter(nil), 
      access([X.c1], [X.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([X.c1]), range[1 ; 1], 
      range_cond([X.c1 = ?], [X.c1 = ?])

*************** Case 215(end)  ************** 

***************   Case 216   ***************

SQL: select distinct c2, c1 from t1; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |356592|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |309262|
|2 |  PX PARTITION ITERATOR|        |500000   |309262|
|3 |   TABLE SCAN          |t1      |500000   |309262|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t1.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 216(end)  ************** 

***************   Case 217   ***************

SQL: select (select c1 from t7),c2 from t8; 

=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |SUBPLAN FILTER|    |100000   |135316|
|1 | TABLE SCAN   |t8  |100000   |61860 |
|2 | TABLE SCAN   |t7  |100000   |59654 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 217(end)  ************** 

***************   Case 218   ***************

SQL: select (select c1 from t7 where c2=t8.c2), c2 from t8; 

=============================================
|ID|OPERATOR      |NAME|EST. ROWS|COST      |
---------------------------------------------
|0 |SUBPLAN FILTER|    |100000   |7036934204|
|1 | TABLE SCAN   |t8  |100000   |61860     |
|2 | TABLE SCAN   |t7  |990      |70232     |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([subquery(1)], [t8.c2]), filter(nil), 
      exec_params_([t8.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 218(end)  ************** 

***************   Case 219   ***************

SQL: select c1 from t7 group by (select c1 from t8), c2; 

==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |HASH GROUP BY  |    |101      |168213|
|1 | SUBPLAN FILTER|    |100000   |135316|
|2 |  TABLE SCAN   |t7  |100000   |61860 |
|3 |  TABLE SCAN   |t8  |100000   |59654 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 219(end)  ************** 

***************   Case 220   ***************

SQL: select c1 from t7 group by (select c1 from t8 where c2=t7.c2),c2; 

==============================================
|ID|OPERATOR       |NAME|EST. ROWS|COST      |
----------------------------------------------
|0 |HASH GROUP BY  |    |101      |7036972914|
|1 | SUBPLAN FILTER|    |100000   |7036934204|
|2 |  TABLE SCAN   |t7  |100000   |61860     |
|3 |  TABLE SCAN   |t8  |990      |70232     |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([subquery(1)], [t7.c2]), agg_func(nil)
  1 - output([t7.c1], [subquery(1)], [t7.c2]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 220(end)  ************** 

***************   Case 221   ***************

SQL: select c1, sum(c2) from t4 group by c1 having sum(c2) < (select 1); 

========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |MERGE GROUP BY|    |6        |89334|
|1 | TABLE SCAN   |t4  |100000   |61860|
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [T_FUN_SUM(t4.c2)]), filter([T_FUN_SUM(t4.c2) < ?]), 
      group([t4.c1]), agg_func([T_FUN_SUM(t4.c2)])
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 221(end)  ************** 

***************   Case 222   ***************

SQL: select c1 from t7 order by (select c1 from t8), c2; 

==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |SORT           |    |100000   |345804|
|1 | SUBPLAN FILTER|    |100000   |135316|
|2 |  TABLE SCAN   |t7  |100000   |61860 |
|3 |  TABLE SCAN   |t8  |100000   |59654 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 222(end)  ************** 

***************   Case 223   ***************

SQL: select c1 from t7 order by (select c1 from t8 where c2=t7.c2),c2; 

==============================================
|ID|OPERATOR       |NAME|EST. ROWS|COST      |
----------------------------------------------
|0 |SORT           |    |100000   |7037146083|
|1 | SUBPLAN FILTER|    |100000   |7036934204|
|2 |  TABLE SCAN   |t7  |100000   |61860     |
|3 |  TABLE SCAN   |t8  |990      |70232     |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([subquery(1), ASC], [t7.c2, ASC])
  1 - output([t7.c1], [subquery(1)], [t7.c2]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 223(end)  ************** 

***************   Case 224   ***************

SQL: select (select 1, 2, 3)=row(1, 2, 3); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) = (?, ?, ?)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?], [?], [?]), filter(nil)
      values({?, ?, ?})

*************** Case 224(end)  ************** 

***************   Case 225   ***************

SQL: select count(1) from t1; 

========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST  |
--------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |489246|
|1 | PX COORDINATOR          |        |1        |393739|
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |393739|
|3 |   MERGE GROUP BY        |        |1        |393739|
|4 |    PX PARTITION ITERATOR|        |500000   |298233|
|5 |     TABLE SCAN          |t1      |500000   |298233|
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  1 - output([T_FUN_COUNT(?)]), filter(nil)
  2 - output([T_FUN_COUNT(?)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 225(end)  ************** 

***************   Case 226   ***************

SQL: select (select 1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 226(end)  ************** 

***************   Case 227   ***************

SQL: (select (select 1)) union (select (select 1)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 227(end)  ************** 

***************   Case 228   ***************

SQL: SELECT distinct '' , 1 FROM DUAL limit 2 offset 1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |LIMIT      |    |0        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(2), offset(?)
  1 - output([1]), filter(nil)
      values({1})

*************** Case 228(end)  ************** 

***************   Case 229   ***************

SQL: select * from t1,t1 t; 

==================================================================
|ID|OPERATOR                  |NAME    |EST. ROWS   |COST        |
------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |250000000000|179521900388|
|1 | PX COORDINATOR           |        |500000      |356592      |
|2 |  EXCHANGE OUT DISTR      |:EX10000|500000      |309262      |
|3 |   PX PARTITION ITERATOR  |        |500000      |309262      |
|4 |    TABLE SCAN            |t1      |500000      |309262      |
|5 | MATERIAL                 |        |500000      |540346      |
|6 |  PX COORDINATOR          |        |500000      |356592      |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500000      |309262      |
|8 |    PX PARTITION ITERATOR |        |500000      |309262      |
|9 |     TABLE SCAN           |t       |500000      |309262      |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t.c1], [t.c2]), filter(nil)
  6 - output([t.c1], [t.c2]), filter(nil)
  7 - output([t.c1], [t.c2]), filter(nil), dop=1
  8 - output([t.c1], [t.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 229(end)  ************** 

***************   Case 230   ***************

SQL: select * from t1,t1 t where t1.c1<t.c1; 

=======================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS  |COST        |
-----------------------------------------------------------------------
|0 |PX COORDINATOR                  |        |83333333334|121274997259|
|1 | EXCHANGE OUT DISTR             |:EX10001|83333333334|105498319475|
|2 |  NESTED-LOOP JOIN              |        |83333333334|105498319475|
|3 |   EXCHANGE IN DISTR            |        |500000     |356592      |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|500000     |309262      |
|5 |     PX PARTITION ITERATOR      |        |500000     |309262      |
|6 |      TABLE SCAN                |t1      |500000     |309262      |
|7 |   PX PARTITION ITERATOR        |        |166667     |103100      |
|8 |    TABLE SCAN                  |t       |166667     |103100      |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t.c1], [t.c2]), filter(nil), 
      access all, force partition granule, asc.
  8 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX), 
      range_cond([? < t.c1])

*************** Case 230(end)  ************** 

***************   Case 231   ***************

SQL: (select * from t4) union (select * from t4) order by (select c1 from t4 limit 1); 

================================================
|ID|OPERATOR             |NAME|EST. ROWS|COST  |
------------------------------------------------
|0 |SUBPLAN FILTER       |    |200000   |242775|
|1 | MERGE UNION DISTINCT|    |200000   |215134|
|2 |  TABLE SCAN         |t4  |100000   |64066 |
|3 |  TABLE SCAN         |t4  |100000   |64066 |
|4 | TABLE SCAN          |t4  |1        |36    |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  4 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 231(end)  ************** 

***************   Case 232   ***************

SQL: select 1 from dual where 1 in (select 1 from dual); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter([?])
      values({?})

*************** Case 232(end)  ************** 

***************   Case 233   ***************

SQL: select count(c1) + 1 from t1; 

========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST  |
--------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |489246|
|1 | PX COORDINATOR          |        |1        |393739|
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |393739|
|3 |   MERGE GROUP BY        |        |1        |393739|
|4 |    PX PARTITION ITERATOR|        |500000   |298233|
|5 |     TABLE SCAN          |t1      |500000   |298233|
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 233(end)  ************** 

***************   Case 234   ***************

SQL: select count(c1) + 1 + 1 from t1; 

========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST  |
--------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |489246|
|1 | PX COORDINATOR          |        |1        |393739|
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |393739|
|3 |   MERGE GROUP BY        |        |1        |393739|
|4 |    PX PARTITION ITERATOR|        |500000   |298233|
|5 |     TABLE SCAN          |t1      |500000   |298233|
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ? + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 234(end)  ************** 

***************   Case 235   ***************

SQL: SELECT (select max(t1.c1) from t1) as field from t1 group by field; 

==================================================================
|ID|OPERATOR                        |NAME       |EST. ROWS|COST  |
------------------------------------------------------------------
|0 |HASH GROUP BY                   |           |1        |809753|
|1 | NESTED-LOOP JOIN CARTESIAN     |           |500000   |645625|
|2 |  SUBPLAN SCAN                  |VIEW4      |1        |38    |
|3 |   SCALAR GROUP BY              |           |1        |37    |
|4 |    SUBPLAN SCAN                |VIEW5      |1        |37    |
|5 |     LIMIT                      |           |1        |37    |
|6 |      PX COORDINATOR MERGE SORT |           |1        |37    |
|7 |       EXCHANGE OUT DISTR       |:EX10000   |1        |37    |
|8 |        SORT                    |           |1        |37    |
|9 |         PX PARTITION ITERATOR  |           |1        |36    |
|10|          TABLE SCAN            |t1(Reverse)|1        |36    |
|11|  PX COORDINATOR                |           |500000   |321898|
|12|   EXCHANGE OUT DISTR           |:EX20000   |500000   |298233|
|13|    PX PARTITION ITERATOR       |           |500000   |298233|
|14|     TABLE SCAN                 |t1         |500000   |298233|
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW4.max(t1.c1)]), filter(nil), 
      group([VIEW4.max(t1.c1)]), agg_func(nil)
  1 - output([VIEW4.max(t1.c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW4.max(t1.c1)]), filter(nil), 
      access([VIEW4.max(t1.c1)])
  3 - output([T_FUN_MAX(VIEW5.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW5.c1)])
  4 - output([VIEW5.c1]), filter(nil), 
      access([VIEW5.c1])
  5 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC])
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC]), local merge sort
  9 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), dop=1
  13 - output([1]), filter(nil), 
      force partition granule, asc.
  14 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 235(end)  ************** 

***************   Case 236   ***************

SQL: ( SELECT * FROM t12 WHERE 69 > ROUND ( 3075 ) ) UNION ALL ( SELECT * FROM t12  ) UNION ( SELECT * FROM t13) ; 

==============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST  |
----------------------------------------------
|0 |HASH UNION DISTINCT|    |300000   |627270|
|1 | UNION ALL         |    |200000   |215134|
|2 |  TABLE SCAN       |t12 |100000   |64066 |
|3 |  TABLE SCAN       |t12 |100000   |64066 |
|4 | TABLE SCAN        |t13 |100000   |64066 |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([cast(UNION([1]), CHAR(20))], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([t12.a], [t12.b], [t12.c]), filter(nil), startup_filter([0]), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  3 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  4 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.b], [t13.c], [t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 236(end)  ************** 

***************   Case 237   ***************

SQL: select t1.c1, nvl(t2.c2,0) from (select c1,c2 from t1 where c1=0 or c1=1) as t1 left join (select c1,c2 from t1 where c1=0) as t2 on t1.c1=t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |112 |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |112 |
|2 |  MERGE OUTER JOIN           |        |2        |112 |
|3 |   SORT                      |        |2        |59  |
|4 |    PX PARTITION ITERATOR    |        |2        |57  |
|5 |     TABLE GET               |t1      |2        |57  |
|6 |   EXCHANGE IN DISTR         |        |1        |53  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |52  |
|8 |     TABLE GET               |t1      |1        |52  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [nvl(t1.c2, ?)]), filter(nil)
  1 - output([t1.c1], [nvl(t1.c2, ?)]), filter(nil), dop=1
  2 - output([t1.c1], [nvl(t1.c2, ?)]), filter(nil), 
      equal_conds([t1.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t1.c1]), range[0 ; 0], [1 ; 1], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[0 ; 0], 
      range_cond([t1.c1 = ?])

*************** Case 237(end)  ************** 

***************   Case 238   ***************

SQL: (select * from t12 where a != 1 limit 7 ) union (select * from t13) union ( select * from t13); 

================================================
|ID|OPERATOR             |NAME|EST. ROWS|COST  |
------------------------------------------------
|0 |MERGE UNION DISTINCT |    |200007   |258689|
|1 | MERGE UNION DISTINCT|    |100007   |107618|
|2 |  SORT               |    |7        |48    |
|3 |   TABLE SCAN        |t12 |7        |38    |
|4 |  TABLE SCAN         |t13 |100000   |64066 |
|5 | TABLE SCAN          |t13 |100000   |64066 |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([cast(t12.a, CHAR(20))], [t12.b], [t12.c]), filter(nil), sort_keys([t12.c, ASC], [cast(t12.a, CHAR(20)), ASC], [t12.b, ASC])
  3 - output([t12.b], [t12.c], [cast(t12.a, CHAR(20))]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      limit(7), offset(nil), 
      is_index_back=false, 
      range_key([t12.a]), range(NULL ; 1), (1 ; MAX), 
      range_cond([t12.a != ?])
  4 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.b], [t13.c], [t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  5 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.b], [t13.c], [t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 238(end)  ************** 

***************   Case 239   ***************

SQL: select /*+ leading(t3, t2, t1) use_merge(t3,t2) */* from t1,t2,t3; 

=============================================================================
|ID|OPERATOR                   |NAME    |EST. ROWS        |COST             |
-----------------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |3.000000e+16     |2.154257e+16     |
|1 | NESTED-LOOP JOIN CARTESIAN|        |60000000000      |45592449346      |
|2 |  PX COORDINATOR           |        |300000           |277391           |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300000           |192197           |
|4 |    PX PARTITION ITERATOR  |        |300000           |192197           |
|5 |     TABLE SCAN            |t2      |300000           |192197           |
|6 |  MATERIAL                 |        |200000           |405432           |
|7 |   PX COORDINATOR          |        |200000           |184927           |
|8 |    EXCHANGE OUT DISTR     |:EX20000|200000           |128131           |
|9 |     PX PARTITION ITERATOR |        |200000           |128131           |
|10|      TABLE SCAN           |t3      |200000           |128131           |
|11| MATERIAL                  |        |500000           |540346           |
|12|  PX COORDINATOR           |        |500000           |356592           |
|13|   EXCHANGE OUT DISTR      |:EX30000|500000           |309262           |
|14|    PX PARTITION ITERATOR  |        |500000           |309262           |
|15|     TABLE SCAN            |t1      |500000           |309262           |
=============================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1], [t1.c2]), filter(nil)
  12 - output([t1.c1], [t1.c2]), filter(nil)
  13 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 239(end)  ************** 

***************   Case 240   ***************

SQL: select /*+leading(t10, t11) use_nl(t11) */ * from t10 join t11 on t10.c2 = t11.c2; 

===========================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST       |
-----------------------------------------------------------
|0 |PX COORDINATOR         |        |392040000|12427200687|
|1 | EXCHANGE OUT DISTR    |:EX10000|392040000|12315869089|
|2 |  PX PARTITION ITERATOR|        |392040000|12315869089|
|3 |   NESTED-LOOP JOIN    |        |392040000|12315869089|
|4 |    TABLE SCAN         |t10     |200000   |128131     |
|5 |    MATERIAL           |        |200000   |238383     |
|6 |     TABLE SCAN        |t11     |200000   |128131     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil)
  1 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), dop=1
  2 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      conds([t10.c2 = t11.c2]), nl_params_(nil), batch_join=false
  4 - output([t10.c2], [t10.c1], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c1], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil)
  6 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil), 
      access([t11.c2], [t11.c1], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 240(end)  ************** 

***************   Case 241   ***************

SQL: select * from t4 where c1 not in (select c1 from t7 where t4.c1+t7.c1 >(select c1 from t8)); 

===============================================
|ID|OPERATOR       |NAME|EST. ROWS|COST       |
-----------------------------------------------
|0 |SUBPLAN FILTER |    |50000    |14525459058|
|1 | TABLE SCAN    |t4  |100000   |64066      |
|2 | SUBPLAN FILTER|    |33334    |140654     |
|3 |  TABLE SCAN   |t7  |33334    |76399      |
|4 |  TABLE SCAN   |t8  |100000   |59654      |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter([? + t7.c1 > ?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 241(end)  ************** 

***************   Case 242   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t7.c1>(select c1 from t8)); 

============================================
|ID|OPERATOR        |NAME |EST. ROWS|COST  |
--------------------------------------------
|0 |MERGE ANTI JOIN |     |1000     |227718|
|1 | TABLE SCAN     |t4   |100000   |61860 |
|2 | SUBPLAN SCAN   |VIEW1|33334    |88740 |
|3 |  SUBPLAN FILTER|     |33334    |84139 |
|4 |   TABLE SCAN   |t7   |33334    |19885 |
|5 |   TABLE SCAN   |t8   |100000   |59654 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 242(end)  ************** 

***************   Case 243   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t4.c1>(select c1 from t8)); 

========================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST       |
--------------------------------------------------------
|0 |SUBPLAN FILTER |             |50000    |14001128771|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100000   |47311      |
|2 | SUBPLAN FILTER|             |50000    |133110     |
|3 |  TABLE SCAN   |t7           |100000   |59654      |
|4 |  TABLE SCAN   |t8           |100000   |59654      |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 243(end)  ************** 

***************   Case 244   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where 1>(select c1 from t8)); 

============================================
|ID|OPERATOR        |NAME |EST. ROWS|COST  |
--------------------------------------------
|0 |MERGE ANTI JOIN |     |1000     |281289|
|1 | TABLE SCAN     |t4   |100000   |61860 |
|2 | SUBPLAN SCAN   |VIEW1|50000    |140011|
|3 |  SUBPLAN FILTER|     |50000    |133110|
|4 |   TABLE SCAN   |t7   |100000   |59654 |
|5 |   TABLE SCAN   |t8   |100000   |59654 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 244(end)  ************** 

***************   Case 245   ***************

SQL: select c1 from t7 where c1 <>ALL (select c1 from t8 where 1>(select 2)); 

===========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST  |
-------------------------------------------
|0 |MERGE ANTI JOIN|     |0        |220023|
|1 | TABLE SCAN    |t7   |100000   |59654 |
|2 | SUBPLAN SCAN  |VIEW1|100000   |73456 |
|3 |  TABLE SCAN   |t8   |100000   |59654 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 245(end)  ************** 

***************   Case 246   ***************

SQL: select c1 from t4 where c1 in (select c1 from t7 where t4.c1>(select c1 from t8)); 

========================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST       |
--------------------------------------------------------
|0 |SUBPLAN FILTER |             |50000    |14001128771|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100000   |47311      |
|2 | SUBPLAN FILTER|             |50000    |133110     |
|3 |  TABLE SCAN   |t7           |100000   |59654      |
|4 |  TABLE SCAN   |t8           |100000   |59654      |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 246(end)  ************** 

***************   Case 247   ***************

SQL: select * from t7 where c1 not in (select 1 from t8 where t8.c1 >1); 

====================================================
|ID|OPERATOR             |NAME |EST. ROWS|COST     |
----------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |98999    |282077555|
|1 | TABLE SCAN          |t7   |100000   |61860    |
|2 | MATERIAL            |     |10000    |9216     |
|3 |  SUBPLAN SCAN       |VIEW1|10000    |7378     |
|4 |   TABLE SCAN        |t8   |10000    |5998     |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = VIEW1.1 OR (T_OP_IS, VIEW1.1, NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.1]), filter(nil)
  3 - output([VIEW1.1]), filter(nil), 
      access([VIEW1.1])
  4 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 247(end)  ************** 

***************   Case 248   ***************

SQL: select * from t7 where c1 not in (select t7.c1 from t8 where t8.c1 >1); 

====================================================
|ID|OPERATOR             |NAME |EST. ROWS|COST     |
----------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |282127981|
|1 | TABLE SCAN          |t7   |100000   |61860    |
|2 | MATERIAL            |     |10000    |9216     |
|3 |  SUBPLAN SCAN       |VIEW1|10000    |7378     |
|4 |   TABLE SCAN        |t8   |10000    |5998     |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = t7.c1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 248(end)  ************** 

***************   Case 249   ***************

SQL: select * from t7 where c1 not in (select (select c1 from t1) from t8 where t8.c1 >1); 

===========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST     |
-----------------------------------------------------------
|0 |SUBPLAN FILTER           |        |50000    |198689909|
|1 | TABLE SCAN              |t7      |100000   |61860    |
|2 | SUBPLAN FILTER          |        |10000    |329276   |
|3 |  TABLE SCAN             |t8      |10000    |5998     |
|4 |  PX COORDINATOR         |        |500000   |321898   |
|5 |   EXCHANGE OUT DISTR    |:EX10000|500000   |298233   |
|6 |    PX PARTITION ITERATOR|        |500000   |298233   |
|7 |     TABLE SCAN          |t1      |500000   |298233   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 249(end)  ************** 

***************   Case 250   ***************

SQL: select * from t7 where c1 in (select t8.c1 from t8 where t8.c1 >1); 

=====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST |
-------------------------------------
|0 |MERGE JOIN |    |10000    |20907|
|1 | TABLE SCAN|t7  |10000    |6219 |
|2 | TABLE SCAN|t8  |10000    |5998 |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(1 ; MAX), 
      range_cond([t7.c1 > ?])
  2 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 250(end)  ************** 

***************   Case 251   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >t7.c1); 

=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |8811|
|1 | TABLE GET                     |t7   |1        |52  |
|2 | SUBPLAN SCAN                  |VIEW1|10000    |7378|
|3 |  TABLE SCAN                   |t8   |10000    |5998|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])
  2 - output([1]), filter(nil), 
      access(nil)
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 251(end)  ************** 

***************   Case 252   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >1); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1|1        |37  |
|2 |  TABLE SCAN    |t8   |1        |36  |
|3 | TABLE GET      |t7   |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.1]), batch_join=true
  1 - output([VIEW1.1]), filter(nil), 
      access([VIEW1.1])
  2 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 252(end)  ************** 

***************   Case 253   ***************

SQL: select * from t1 where c1 = 1 and c2 in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t1  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 253(end)  ************** 

***************   Case 254   ***************

SQL: select * from t1 partition(p1)  where c2 =1 or c2 = 2; 

======================================================
|ID|OPERATOR            |NAME         |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE  |             |1980     |1442|
|1 | EXCHANGE OUT REMOTE|             |1980     |1255|
|2 |  TABLE SCAN        |t1(idx_t1_c2)|1980     |1255|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ? OR t1.c2 = ?])

*************** Case 254(end)  ************** 

***************   Case 255   ***************

SQL: select * from t14 partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |20       |43  |
|1 | EXCHANGE OUT REMOTE|    |20       |40  |
|2 |  TABLE SCAN        |t14 |20       |40  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil)
  2 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 255(end)  ************** 

***************   Case 256   ***************

SQL: select/*+index(t14 primary)*/* from t14  partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |20       |43  |
|1 | EXCHANGE OUT REMOTE|    |20       |40  |
|2 |  TABLE SCAN        |t14 |20       |40  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil)
  2 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 256(end)  ************** 

***************   Case 257   ***************

SQL: select c1 from t1 where (1, 2) in (select t1.c1, t2.c1 from t2); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |105 |
|1 | PX COORDINATOR           |        |1        |52  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |52  |
|3 |   TABLE GET              |t1      |1        |52  |
|4 | PX COORDINATOR           |        |1        |52  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |52  |
|6 |   TABLE GET              |t2      |1        |52  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), is_single, dop=1
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), is_single, dop=1
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 257(end)  ************** 

***************   Case 258   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where t1.c1); 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |4950     |6858  |
|1 | PX COORDINATOR           |        |1        |53    |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53    |
|3 |   TABLE GET              |t2      |1        |53    |
|4 | PX COORDINATOR           |        |499999   |363760|
|5 |  EXCHANGE OUT DISTR      |:EX20000|499999   |340095|
|6 |   PX PARTITION ITERATOR  |        |499999   |340095|
|7 |    TABLE SCAN            |t1      |499999   |340095|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), is_single, dop=1
  3 - output([1]), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter([t1.c1]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 258(end)  ************** 

***************   Case 259   ***************

SQL: select c1 from t1 where (1, 2) in (select distinct t1.c1, t1.c2 from t2 where t1.c1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |53  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t1      |1        |53  |
|4 | SUBPLAN SCAN             |VIEW2   |1        |37  |
|5 |  LIMIT                   |        |1        |37  |
|6 |   PX COORDINATOR         |        |1        |36  |
|7 |    EXCHANGE OUT DISTR    |:EX20000|1        |36  |
|8 |     PX PARTITION ITERATOR|        |1        |36  |
|9 |      TABLE SCAN          |t2      |1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), is_single, dop=1
  3 - output([t1.c1]), filter([t1.c2 = ?], [t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([1]), filter(nil), 
      access(nil)
  5 - output([1]), filter(nil), limit(1), offset(nil)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), dop=1
  8 - output([1]), filter(nil), 
      force partition granule, asc.
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 259(end)  ************** 

***************   Case 260   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1 and t1.c2 limit 1); 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |490050   |786189|
|1 | PX COORDINATOR            |        |490050   |439375|
|2 |  EXCHANGE OUT DISTR       |:EX10000|490050   |392987|
|3 |   PX PARTITION ITERATOR   |        |490050   |392987|
|4 |    TABLE SCAN             |t1      |490050   |392987|
|5 | MATERIAL                  |        |1        |37    |
|6 |  SUBPLAN SCAN             |VIEW2   |1        |37    |
|7 |   LIMIT                   |        |1        |37    |
|8 |    PX COORDINATOR         |        |1        |36    |
|9 |     EXCHANGE OUT DISTR    |:EX20000|1        |36    |
|10|      PX PARTITION ITERATOR|        |1        |36    |
|11|       TABLE SCAN          |t2      |1        |36    |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c2]), filter(nil)
  2 - output([t1.c2]), filter(nil), dop=1
  3 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c2]), filter([t1.c2], [t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access(nil)
  7 - output([1]), filter(nil), limit(1), offset(nil)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), dop=1
  10 - output([1]), filter(nil), 
      force partition granule, asc.
  11 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 260(end)  ************** 

***************   Case 261   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7 left join t8 on t7.c1<=t8.c1 where (t7.c1,t4.c1) in (select c1,c2 from t9)); 

=======================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST    |
-------------------------------------------------------
|0 |NESTED-LOOP JOIN         |     |97358    |24402012|
|1 | SUBPLAN SCAN            |VIEW3|100      |24272093|
|2 |  MERGE DISTINCT         |     |100      |24272079|
|3 |   NESTED-LOOP OUTER JOIN|     |16500000 |20613268|
|4 |    NESTED-LOOP JOIN     |     |495      |88578   |
|5 |     TABLE SCAN          |t9   |500      |70232   |
|6 |     TABLE GET           |t7   |1        |36      |
|7 |    TABLE SCAN           |t8   |33334    |19885   |
|8 | TABLE SCAN              |t4   |990      |667     |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([VIEW3.VIEW2.t9.c2]), batch_join=true
  1 - output([VIEW3.VIEW2.t9.c2]), filter(nil), 
      access([VIEW3.VIEW2.t9.c2])
  2 - output([t9.c2], [t7.c1]), filter(nil), 
      distinct([t9.c2])
  3 - output([t9.c2], [t7.c1]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  4 - output([t9.c2], [t7.c1]), filter(nil), 
      conds(nil), nl_params_([t9.c2]), batch_join=true
  5 - output([t9.c2]), filter([t9.c2 = t9.c1]), 
      access([t9.c1], [t9.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t9.c1]), range(MIN ; MAX)always true
  6 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([? = t7.c1])
  7 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? <= t8.c1])
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN ; MAX), 
      range_cond([t4.c1 = ?])

*************** Case 261(end)  ************** 

***************   Case 262   ***************

SQL: select * from t7 where 1 in (select c1 from t8 where t7.c1); 

=====================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST  |
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |99999    |135022|
|1 | TABLE GET                |t8  |1        |52    |
|2 | TABLE SCAN               |t7  |99999    |70232 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[1 ; 1], 
      range_cond([t8.c1 = ?])
  2 - output([t7.c1], [t7.c2]), filter([t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 262(end)  ************** 

***************   Case 263   ***************

SQL: select * from t7 where 1 not in (select 2 from t8 where t7.c1=t8.c1); 

===========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST  |
-------------------------------------------
|0 |MERGE ANTI JOIN|     |0        |222228|
|1 | TABLE SCAN    |t7   |100000   |61860 |
|2 | SUBPLAN SCAN  |VIEW1|100000   |73456 |
|3 |  TABLE SCAN   |t8   |100000   |59654 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.t8.c1]), filter(nil), 
      access([VIEW1.t8.c1])
  3 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 263(end)  ************** 

***************   Case 264   ***************

SQL: select * from t4 where (select c1 from t7)+1 in (select 2 from t8 where t4.c1=t8.c1); 

=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |SUBPLAN FILTER|    |49500    |283357|
|1 | MERGE JOIN   |    |99000    |210039|
|2 |  TABLE SCAN  |t4  |100000   |64066 |
|3 |  TABLE SCAN  |t8  |100000   |59654 |
|4 | TABLE SCAN   |t7  |100000   |59654 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([?]), 
      exec_params_(nil), onetime_exprs_([subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t8.c1]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 264(end)  ************** 

***************   Case 265   ***************

SQL: select sum(c1)+sum(c2), sum(c1) from t1 group by c2 having sum(c1) > 5; 

===================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST  |
-------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |6        |636990|
|1 | EXCHANGE OUT DISTR            |:EX10001     |6        |636990|
|2 |  MERGE GROUP BY               |             |6        |636990|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |6        |473126|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |6        |473126|
|5 |     PX PARTITION ITERATOR     |             |6        |473126|
|6 |      MERGE GROUP BY           |             |6        |473126|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c2))])
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 265(end)  ************** 

***************   Case 266   ***************

SQL: select sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

==================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST |
------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |1        |63721|
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |63721|
|2 |  MERGE GROUP BY               |             |1        |63721|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |47335|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |47334|
|5 |     PX PARTITION ITERATOR     |             |1        |47334|
|6 |      MERGE GROUP BY           |             |1        |47334|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|50000    |30948|
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 266(end)  ************** 

***************   Case 267   ***************

SQL: select distinct sum(c1) from t1 group by c2 having sum(c1) > 5; 

======================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST  |
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |             |5        |584006|
|1 | EXCHANGE OUT DISTR               |:EX10002     |5        |584005|
|2 |  HASH DISTINCT                   |             |5        |584005|
|3 |   EXCHANGE IN DISTR              |             |6        |584000|
|4 |    EXCHANGE OUT DISTR (HASH)     |:EX10001     |6        |583999|
|5 |     MERGE GROUP BY               |             |6        |583999|
|6 |      EXCHANGE IN MERGE SORT DISTR|             |6        |446631|
|7 |       EXCHANGE OUT DISTR (HASH)  |:EX10000     |6        |446631|
|8 |        PX PARTITION ITERATOR     |             |6        |446631|
|9 |         MERGE GROUP BY           |             |6        |446631|
|10|          TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  4 - (#keys=1, [T_FUN_SUM(T_FUN_SUM(t1.c1))]), output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  7 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 267(end)  ************** 

***************   Case 268   ***************

SQL: select distinct sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

==================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST |
------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |1        |63721|
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |63721|
|2 |  MERGE GROUP BY               |             |1        |63721|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |47335|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |47334|
|5 |     PX PARTITION ITERATOR     |             |1        |47334|
|6 |      MERGE GROUP BY           |             |1        |47334|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|50000    |30948|
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 268(end)  ************** 

***************   Case 269   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

==================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST |
------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |1        |63721|
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |63721|
|2 |  MERGE GROUP BY               |             |1        |63721|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |47335|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |47334|
|5 |     PX PARTITION ITERATOR     |             |1        |47334|
|6 |      MERGE GROUP BY           |             |1        |47334|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|50000    |30948|
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 269(end)  ************** 

***************   Case 270   ***************

SQL: select distinct sum(c1)+1, sum(c1) + 2 from t1 group by c2 having sum(c1) > 5 and count(c1) + 2 > 2; 

======================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST  |
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |             |1        |636990|
|1 | EXCHANGE OUT DISTR               |:EX10002     |1        |636990|
|2 |  HASH DISTINCT                   |             |1        |636990|
|3 |   EXCHANGE IN DISTR              |             |1        |636990|
|4 |    EXCHANGE OUT DISTR (HASH)     |:EX10001     |1        |636989|
|5 |     MERGE GROUP BY               |             |1        |636989|
|6 |      EXCHANGE IN MERGE SORT DISTR|             |1        |473126|
|7 |       EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |473126|
|8 |        PX PARTITION ITERATOR     |             |1        |473126|
|9 |         MERGE GROUP BY           |             |1        |473126|
|10|          TABLE SCAN              |t1(idx_t1_c2)|500000   |309262|
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?])
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil)
  4 - (#keys=2, [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), dop=1
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ? > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  7 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  9 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 270(end)  ************** 

***************   Case 271   ***************

SQL: select * from t1, t2 where t1.c1 > any(select t3.c2 from t2,t3 where t2.c1 > any(select t4.c1 from t4,t5 where exists (select c1 from t2 ))); 

====================================================================================
|ID|OPERATOR                            |NAME         |EST. ROWS  |COST            |
------------------------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN          |             |50000000000|2.820124e+15    |
|1 | PX COORDINATOR                     |             |300000     |277391          |
|2 |  EXCHANGE OUT DISTR                |:EX10000     |300000     |192197          |
|3 |   PX PARTITION ITERATOR            |             |300000     |192197          |
|4 |    TABLE SCAN                      |t2           |300000     |192197          |
|5 | MATERIAL                           |             |166667     |2.820088e+15    |
|6 |  NESTED-LOOP SEMI JOIN             |             |166667     |2.820088e+15    |
|7 |   PX COORDINATOR                   |             |500000     |356592          |
|8 |    EXCHANGE OUT DISTR              |:EX20000     |500000     |309262          |
|9 |     PX PARTITION ITERATOR          |             |500000     |309262          |
|10|      TABLE SCAN                    |t1           |500000     |309262          |
|11|   MATERIAL                         |             |20000000000|28633829101     |
|12|    SUBPLAN SCAN                    |VIEW2        |20000000000|24958754009     |
|13|     NESTED-LOOP JOIN CARTESIAN     |             |20000000000|22198315287     |
|14|      PX COORDINATOR                |             |200000     |142652          |
|15|       EXCHANGE OUT DISTR           |:EX30000     |200000     |123720          |
|16|        PX PARTITION ITERATOR       |             |200000     |123720          |
|17|         TABLE SCAN                 |t3           |200000     |123720          |
|18|      MATERIAL                      |             |100000     |8045386168      |
|19|       NESTED-LOOP SEMI JOIN        |             |100000     |8045367793      |
|20|        PX COORDINATOR              |             |300000     |193161          |
|21|         EXCHANGE OUT DISTR         |:EX40000     |300000     |178962          |
|22|          PX PARTITION ITERATOR     |             |300000     |178962          |
|23|           TABLE SCAN               |t2           |300000     |178962          |
|24|        SUBPLAN SCAN                |VIEW1        |1          |26817           |
|25|         SUBPLAN FILTER             |             |1          |26817           |
|26|          NESTED-LOOP JOIN CARTESIAN|             |1          |26781           |
|27|           PX COORDINATOR           |             |1          |36              |
|28|            EXCHANGE OUT DISTR      |:EX50000     |1          |36              |
|29|             PX PARTITION ITERATOR  |             |1          |36              |
|30|              TABLE SCAN            |t5(idx_t5_c2)|1          |36              |
|31|           MATERIAL                 |             |33334      |26745           |
|32|            TABLE SCAN              |t4           |33334      |20620           |
|33|          LIMIT                     |             |1          |37              |
|34|           PX COORDINATOR           |             |1          |36              |
|35|            EXCHANGE OUT DISTR      |:EX60000     |1          |36              |
|36|             PX PARTITION ITERATOR  |             |1          |36              |
|37|              TABLE SCAN            |t2           |1          |36              |
====================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW2.c2]), nl_params_(nil), batch_join=false
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([VIEW2.c2]), filter(nil)
  12 - output([VIEW2.c2]), filter(nil), 
      access([VIEW2.c2])
  13 - output([t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  14 - output([t3.c2]), filter(nil)
  15 - output([t3.c2]), filter(nil), dop=1
  16 - output([t3.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  18 - output([1]), filter(nil)
  19 - output([1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  20 - output([t2.c1]), filter(nil)
  21 - output([t2.c1]), filter(nil), dop=1
  22 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  23 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  24 - output([1]), filter(nil), 
      access([VIEW1.c1])
  25 - output([t4.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  26 - output([t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  27 - output([1]), filter(nil)
  28 - output([1]), filter(nil), dop=1
  29 - output([1]), filter(nil), 
      force partition granule, asc.
  30 - output([1]), filter(nil), 
      access([t5.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  31 - output([t4.c1]), filter(nil)
  32 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true, 
      range_cond([? > t4.c1])
  33 - output([1]), filter(nil), limit(1), offset(nil)
  34 - output([1]), filter(nil)
  35 - output([1]), filter(nil), dop=1
  36 - output([1]), filter(nil), 
      force partition granule, asc.
  37 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 271(end)  ************** 

***************   Case 272   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8); 

===============================================================
|ID|OPERATOR                    |NAME |EST. ROWS  |COST       |
---------------------------------------------------------------
|0 |HASH RIGHT SEMI JOIN        |     |99000      |30501191064|
|1 | SUBPLAN SCAN               |VIEW1|10000000000|8456750278 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |10000000000|7076530917 |
|3 |   TABLE SCAN               |t7   |100000     |59654      |
|4 |   MATERIAL                 |     |100000     |78030      |
|5 |    TABLE SCAN              |t8   |100000     |59654      |
|6 | NESTED-LOOP JOIN CARTESIAN |     |10000000000|7285470299 |
|7 |  TABLE SCAN                |t4   |100000     |64066      |
|8 |  MATERIAL                  |     |100000     |119192     |
|9 |   TABLE SCAN               |t5   |100000     |64066      |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t4.c1 + t5.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t4.c1 + t5.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  9 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 272(end)  ************** 

***************   Case 273   ***************

SQL: select * from t4,t4 t5 where t4.c1 in (select t7.c1 from t7,t8); 

===============================================================
|ID|OPERATOR                      |NAME |EST. ROWS |COST      |
---------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN    |     |9900000000|7216269494|
|1 | TABLE SCAN                   |t5   |100000    |64066     |
|2 | MATERIAL                     |     |99000     |3771257   |
|3 |  NESTED-LOOP SEMI JOIN       |     |99000     |3716682   |
|4 |   TABLE SCAN                 |t4   |100000    |64066     |
|5 |   SUBPLAN SCAN               |VIEW1|1         |36        |
|6 |    NESTED-LOOP JOIN CARTESIAN|     |1         |36        |
|7 |     TABLE GET                |t7   |1         |36        |
|8 |     TABLE SCAN               |t8   |100000    |59654     |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([1]), filter(nil), 
      access([VIEW1.c1])
  6 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  7 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t7.c1])
  8 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 273(end)  ************** 

***************   Case 274   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8 where t7.c1=t8.c1); 

==============================================================
|ID|OPERATOR                    |NAME|EST. ROWS  |COST       |
--------------------------------------------------------------
|0 |HASH JOIN                   |    |10000000000|26809843181|
|1 | TABLE SCAN                 |t8  |100000     |59654      |
|2 | HASH JOIN                  |    |10000000000|17596323359|
|3 |  TABLE SCAN                |t7  |100000     |59654      |
|4 |  NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285470299 |
|5 |   TABLE SCAN               |t4  |100000     |64066      |
|6 |   MATERIAL                 |    |100000     |119192     |
|7 |    TABLE SCAN              |t5  |100000     |64066      |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t7.c1]), filter(nil), 
      equal_conds([t4.c1 + t5.c1 = t7.c1]), other_conds(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t4.c1 + t5.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  7 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 274(end)  ************** 

***************   Case 275   ***************

SQL: select count(*) v from t1 where c2 = 1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SCALAR GROUP BY          |             |1        |4974|
|1 | PX COORDINATOR          |             |1        |4028|
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |4028|
|3 |   MERGE GROUP BY        |             |1        |4028|
|4 |    PX PARTITION ITERATOR|             |4950     |3083|
|5 |     TABLE SCAN          |t1(idx_t1_c2)|4950     |3083|
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 275(end)  ************** 

***************   Case 276   ***************

SQL: select count(*) v, sum(c1) as v2 from t1 where c1 > 0; 

=======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST |
-------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |54246|
|1 | PX COORDINATOR          |        |1        |42045|
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |42045|
|3 |   MERGE GROUP BY        |        |1        |42045|
|4 |    PX PARTITION ITERATOR|        |50000    |29845|
|5 |     TABLE SCAN          |t1      |50000    |29845|
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))])
  1 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 276(end)  ************** 

***************   Case 277   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) as alias from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1 and alias > 100; 

==================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST |
------------------------------------------------------------------
|0 |PX COORDINATOR                 |             |1        |63721|
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |63721|
|2 |  MERGE GROUP BY               |             |1        |63721|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |47334|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |47334|
|5 |     PX PARTITION ITERATOR     |             |1        |47334|
|6 |      MERGE GROUP BY           |             |1        |47334|
|7 |       TABLE SCAN              |t1(idx_t1_c2)|50000    |30948|
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 277(end)  ************** 

***************   Case 278   ***************

SQL: select 1 from t15; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |400000   |275158|
|1 | EXCHANGE OUT DISTR    |:EX10000|400000   |256226|
|2 |  PX PARTITION ITERATOR|        |400000   |256226|
|3 |   TABLE SCAN          |t15     |400000   |256226|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil), dop=1
  2 - output([?]), filter(nil), 
      force partition granule, asc.
  3 - output([?]), filter(nil), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 278(end)  ************** 

***************   Case 279   ***************

SQL: select c1 from t15 where false; 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |400000   |283981|
|1 | EXCHANGE OUT DISTR    |:EX10000|400000   |265049|
|2 |  PX PARTITION ITERATOR|        |400000   |265049|
|3 |   TABLE SCAN          |t15     |400000   |265049|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t15.c1]), filter(nil)
  1 - output([t15.c1]), filter(nil), dop=1
  2 - output([t15.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t15.c1]), filter(nil), startup_filter([0]), 
      access([t15.c1]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 279(end)  ************** 

***************   Case 280   ***************

SQL: select count(1) from t15 where false; 

========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST  |
--------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |409036|
|1 | PX COORDINATOR          |        |1        |332631|
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |332631|
|3 |   MERGE GROUP BY        |        |1        |332631|
|4 |    PX PARTITION ITERATOR|        |400000   |256226|
|5 |     TABLE SCAN          |t15     |400000   |256226|
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  1 - output([T_FUN_COUNT(?)]), filter(nil)
  2 - output([T_FUN_COUNT(?)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), startup_filter([0]), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 280(end)  ************** 

***************   Case 281   ***************

SQL: select * from t1 order by c2,c1,c2; 

===============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500000   |1514161|
|1 | EXCHANGE OUT DISTR       |:EX10000     |500000   |1466831|
|2 |  SORT                    |             |500000   |1466831|
|3 |   PX PARTITION ITERATOR  |             |500000   |309262 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500000   |309262 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 281(end)  ************** 

***************   Case 282   ***************

SQL: select * from t1 left outer join t2 using(c1) order by t1.c1 desc, t2.c1; 

==================================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |           |500000   |1930764|
|1 | EXCHANGE OUT DISTR            |:EX10001   |500000   |1741444|
|2 |  MERGE OUTER JOIN             |           |500000   |1741444|
|3 |   EXCHANGE IN MERGE SORT DISTR|           |500000   |356592 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000   |500000   |309262 |
|5 |     PX PARTITION ITERATOR     |           |500000   |309262 |
|6 |      TABLE SCAN               |t1(Reverse)|500000   |309262 |
|7 |   SORT                        |           |300000   |1096510|
|8 |    PX PARTITION ITERATOR      |           |300000   |192197 |
|9 |     TABLE SCAN                |t2(Reverse)|300000   |192197 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, DESC])
  1 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, DESC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), sort_keys([t2.c1, DESC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 282(end)  ************** 

***************   Case 283   ***************

SQL: select count(*) from t1 left outer join t2 using(c1) group by (t1.c1) having count(*) > 1 order by t1.c1 desc, t2.c1; 

==================================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |           |500000   |1879610|
|1 | EXCHANGE OUT DISTR            |:EX10001   |500000   |1832279|
|2 |  MERGE OUTER JOIN             |           |500000   |1832279|
|3 |   SORT                        |           |500000   |1350777|
|4 |    PX PARTITION ITERATOR      |           |500000   |298233 |
|5 |     TABLE SCAN                |t1(Reverse)|500000   |298233 |
|6 |   EXCHANGE IN MERGE SORT DISTR|           |300000   |193161 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000   |300000   |178962 |
|8 |     PX PARTITION ITERATOR     |           |300000   |178962 |
|9 |      TABLE SCAN               |t2(Reverse)|300000   |178962 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil), sort_keys([t1.c1, DESC])
  1 - output([1], [t1.c1]), filter(nil), dop=1
  2 - output([1], [t1.c1]), filter(nil), startup_filter([?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), startup_filter([?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, DESC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), startup_filter([?]), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 283(end)  ************** 

***************   Case 284   ***************

SQL: select now() from t1 left outer join t2 using(c1); 

======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST  |
------------------------------------------------------
|0 |PX COORDINATOR         |        |500000   |321898|
|1 | EXCHANGE OUT DISTR    |:EX10000|500000   |298233|
|2 |  PX PARTITION ITERATOR|        |500000   |298233|
|3 |   TABLE SCAN          |t1      |500000   |298233|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil), dop=1
  2 - output([?]), filter(nil), 
      force partition granule, asc.
  3 - output([?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 284(end)  ************** 

***************   Case 285   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where least(t1.c2, a1.c2) > 1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100000   |1928520|
|1 | EXCHANGE OUT DISTR            |:EX10001|100000   |1909588|
|2 |  MERGE JOIN                   |        |100000   |1909588|
|3 |   SORT                        |        |500000   |1458906|
|4 |    PX PARTITION ITERATOR      |        |500000   |309262 |
|5 |     TABLE SCAN                |t1      |500000   |309262 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300000   |213977 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300000   |185579 |
|8 |     PX PARTITION ITERATOR     |        |300000   |185579 |
|9 |      TABLE SCAN               |a1      |300000   |185579 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([a1.c2]), filter(nil)
  1 - output([a1.c2]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds([least(t1.c2, a1.c2) > ?])
  3 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([a1.c1], [a1.c2]), filter(nil), sort_keys([a1.c1, ASC]), Local Order
  7 - (#keys=1, [a1.c1]), output([a1.c1], [a1.c2]), filter(nil), dop=1
  8 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true

*************** Case 285(end)  ************** 

***************   Case 286   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where length(t1.c2) > 1; 

===============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST   |
---------------------------------------------------------------
|0 |PX COORDINATOR                 |        |166667   |1418566|
|1 | EXCHANGE OUT DISTR            |:EX10001|166667   |1387012|
|2 |  MERGE OUTER JOIN             |        |166667   |1387012|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |166667   |366901 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|166667   |351124 |
|5 |     PX PARTITION ITERATOR     |        |166667   |351124 |
|6 |      TABLE SCAN               |t1      |166667   |351124 |
|7 |   SORT                        |        |300000   |856854 |
|8 |    PX PARTITION ITERATOR      |        |300000   |185579 |
|9 |     TABLE SCAN                |a1      |300000   |185579 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([a1.c2]), filter(nil)
  1 - output([a1.c2]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter([length(t1.c2) > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([a1.c2], [a1.c1]), filter(nil), sort_keys([a1.c1, ASC]), local merge sort
  8 - output([a1.c1], [a1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true

*************** Case 286(end)  ************** 

***************   Case 287   ***************

SQL: select a2.c2, t1.c2, a1.c2 from t1  left join t2 a1 on (a1.c1 = t1.c1), t2 a2 where least(t1.c2, a1.c2) =a2.c2; 

==================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST     |
------------------------------------------------------------------
|0 |HASH JOIN                       |        |450000000|269601090|
|1 | PX COORDINATOR                 |        |300000   |213977   |
|2 |  EXCHANGE OUT DISTR            |:EX10000|300000   |185579   |
|3 |   PX PARTITION ITERATOR        |        |300000   |185579   |
|4 |    TABLE SCAN                  |a2      |300000   |185579   |
|5 | PX COORDINATOR                 |        |300000   |2018020  |
|6 |  EXCHANGE OUT DISTR            |:EX20001|300000   |1961224  |
|7 |   MERGE JOIN                   |        |300000   |1961224  |
|8 |    SORT                        |        |500000   |1458906  |
|9 |     PX PARTITION ITERATOR      |        |500000   |309262   |
|10|      TABLE SCAN                |t1      |500000   |309262   |
|11|    EXCHANGE IN MERGE SORT DISTR|        |300000   |213977   |
|12|     EXCHANGE OUT DISTR (PKEY)  |:EX20000|300000   |185579   |
|13|      PX PARTITION ITERATOR     |        |300000   |185579   |
|14|       TABLE SCAN               |a1      |300000   |185579   |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([a2.c2], [t1.c2], [a1.c2]), filter(nil), 
      equal_conds([least(t1.c2, a1.c2) = a2.c2]), other_conds(nil)
  1 - output([a2.c2]), filter(nil)
  2 - output([a2.c2]), filter(nil), dop=1
  3 - output([a2.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c2], [a1.c2], [least(t1.c2, a1.c2)]), filter(nil)
  6 - output([t1.c2], [a1.c2], [least(t1.c2, a1.c2)]), filter(nil), dop=1
  7 - output([t1.c2], [a1.c2], [least(t1.c2, a1.c2)]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds(nil)
  8 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([a1.c1], [a1.c2]), filter(nil), sort_keys([a1.c1, ASC]), Local Order
  12 - (#keys=1, [a1.c1]), output([a1.c1], [a1.c2]), filter(nil), dop=1
  13 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule, asc.
  14 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true

*************** Case 287(end)  ************** 

***************   Case 288   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 = 1 and t2.c3 = f1.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t2 f2 on (f2.c1 = 3 and f2.c3=t2.c3) left join t3 a2 on (a2.c1 = f2.c1), t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

===========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST  |
-----------------------------------------------------------
|0 |HASH JOIN                   |        |29403    |666559|
|1 | NESTED-LOOP JOIN CARTESIAN |        |30       |440690|
|2 |  PX COORDINATOR            |        |1        |53    |
|3 |   EXCHANGE OUT DISTR       |:EX10000|1        |52    |
|4 |    TABLE GET               |a2      |1        |52    |
|5 |  NESTED-LOOP JOIN CARTESIAN|        |30       |440618|
|6 |   PX COORDINATOR           |        |1        |53    |
|7 |    EXCHANGE OUT DISTR      |:EX20000|1        |52    |
|8 |     TABLE GET              |a1      |1        |52    |
|9 |   MERGE JOIN               |        |30       |440547|
|10|    NESTED-LOOP JOIN        |        |2970     |440056|
|11|     PX COORDINATOR         |        |1        |53    |
|12|      EXCHANGE OUT DISTR    |:EX30000|1        |52    |
|13|       TABLE GET            |f1      |1        |52    |
|14|     PX COORDINATOR         |        |300000   |256574|
|15|      EXCHANGE OUT DISTR    |:EX40000|300000   |185579|
|16|       PX PARTITION ITERATOR|        |300000   |185579|
|17|        TABLE SCAN          |t2      |300000   |185579|
|18|    TABLE GET               |f2      |1        |52    |
|19| PX COORDINATOR             |        |200000   |142652|
|20|  EXCHANGE OUT DISTR        |:EX50000|200000   |123720|
|21|   PX PARTITION ITERATOR    |        |200000   |123720|
|22|    TABLE SCAN              |f_acc   |200000   |123720|
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a2.c2]), filter(nil), 
      equal_conds([least(a1.c2, a2.c2) = f_acc.c2]), other_conds(nil)
  1 - output([a1.c2], [a2.c2], [least(a1.c2, a2.c2)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([a2.c2]), filter(nil)
  3 - output([a2.c2]), filter(nil), is_single, dop=1
  4 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a2.c1]), range[3 ; 3], 
      range_cond([a2.c1 = ?])
  5 - output([a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  6 - output([a1.c2]), filter(nil)
  7 - output([a1.c2]), filter(nil), is_single, dop=1
  8 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])
  9 - output([1]), filter(nil), 
      equal_conds([f2.c3 = t2.c3]), other_conds(nil)
  10 - output([t2.c3]), filter(nil), 
      conds([t2.c3 = f1.c3]), nl_params_(nil), batch_join=false
  11 - output([f1.c3]), filter(nil)
  12 - output([f1.c3]), filter(nil), is_single, dop=1
  13 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  14 - output([t2.c3]), filter(nil)
  15 - output([t2.c3]), filter(nil), dop=1
  16 - output([t2.c3]), filter(nil), 
      force partition granule, asc.
  17 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  18 - output([f2.c3]), filter(nil), 
      access([f2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([f2.c1]), range[3 ; 3], 
      range_cond([f2.c1 = ?])
  19 - output([f_acc.c2]), filter(nil)
  20 - output([f_acc.c2]), filter(nil), dop=1
  21 - output([f_acc.c2]), filter(nil), 
      force partition granule, asc.
  22 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true

*************** Case 288(end)  ************** 

***************   Case 289   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 =1 and f1.c3 = t2.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t3 a2 on (a2.c1 = f1.c1) , t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

==========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST   |
----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |2970000  |2823104|
|1 | NESTED-LOOP JOIN         |        |2970     |440056 |
|2 |  PX COORDINATOR          |        |1        |53     |
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |52     |
|4 |    TABLE GET             |f1      |1        |52     |
|5 |  PX COORDINATOR          |        |300000   |256574 |
|6 |   EXCHANGE OUT DISTR     |:EX20000|300000   |185579 |
|7 |    PX PARTITION ITERATOR |        |300000   |185579 |
|8 |     TABLE SCAN           |t2      |300000   |185579 |
|9 | MATERIAL                 |        |1000     |188297 |
|10|  NESTED-LOOP JOIN        |        |1000     |187562 |
|11|   PX COORDINATOR         |        |1        |53     |
|12|    EXCHANGE OUT DISTR    |:EX30000|1        |52     |
|13|     TABLE GET            |a1      |1        |52     |
|14|   PX COORDINATOR         |        |200000   |142652 |
|15|    EXCHANGE OUT DISTR    |:EX40000|200000   |123720 |
|16|     PX PARTITION ITERATOR|        |200000   |123720 |
|17|      TABLE SCAN          |f_acc   |200000   |123720 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil), 
      conds([f1.c3 = t2.c3]), nl_params_(nil), batch_join=false
  2 - output([f1.c3]), filter(nil)
  3 - output([f1.c3]), filter(nil), is_single, dop=1
  4 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  5 - output([t2.c3]), filter(nil)
  6 - output([t2.c3]), filter(nil), dop=1
  7 - output([t2.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([f_acc.c2], [a1.c2]), filter(nil)
  10 - output([f_acc.c2], [a1.c2]), filter(nil), 
      conds([least(a1.c2, a1.c2) = f_acc.c2]), nl_params_(nil), batch_join=false
  11 - output([a1.c2]), filter(nil)
  12 - output([a1.c2]), filter(nil), is_single, dop=1
  13 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])
  14 - output([f_acc.c2]), filter(nil)
  15 - output([f_acc.c2]), filter(nil), dop=1
  16 - output([f_acc.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true

*************** Case 289(end)  ************** 

***************   Case 290   ***************

SQL: select * from t9,t10,t11 where t9.c2=t10.c2 and t9.c3=t10.c3 and t9.c2=t11.c2 and t9.c3=t11.c3 order by t11.c3,t11.c2; 

=================================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST     |
-----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |36909788 |198609614|
|1 | EXCHANGE OUT DISTR            |:EX10001|36909788 |182887141|
|2 |  SORT                         |        |36909788 |182887141|
|3 |   HASH JOIN                   |        |36909788 |27891549 |
|4 |    PX PARTITION ITERATOR      |        |200000   |128131   |
|5 |     TABLE SCAN                |t11     |200000   |128131   |
|6 |    HASH JOIN                  |        |1921193  |1736074  |
|7 |     EXCHANGE IN DISTR         |        |100000   |78265    |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100000   |64066    |
|9 |       TABLE SCAN              |t9      |100000   |64066    |
|10|     PX PARTITION ITERATOR     |        |200000   |128131   |
|11|      TABLE SCAN               |t10     |200000   |128131   |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), sort_keys([t11.c3, ASC], [t11.c2, ASC])
  1 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), dop=1
  2 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), sort_keys([t11.c3, ASC], [t11.c2, ASC])
  3 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      equal_conds([t9.c2 = t11.c2], [t9.c3 = t11.c3]), other_conds(nil)
  4 - output([t11.c2], [t11.c3], [t11.c1]), filter(nil), 
      affinitize, partition wise, force partition granule, asc.
  5 - output([t11.c2], [t11.c3], [t11.c1]), filter(nil), 
      access([t11.c2], [t11.c3], [t11.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  7 - output([t9.c2], [t9.c3], [t9.c1]), filter(nil)
  8 - (#keys=1, [t9.c2]), output([t9.c2], [t9.c3], [t9.c1]), filter(nil), is_single, dop=1
  9 - output([t9.c2], [t9.c3], [t9.c1]), filter(nil), 
      access([t9.c2], [t9.c3], [t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  10 - output([t10.c2], [t10.c3], [t10.c1]), filter(nil), 
      affinitize, partition wise, force partition granule, asc.
  11 - output([t10.c2], [t10.c3], [t10.c1]), filter(nil), 
      access([t10.c2], [t10.c3], [t10.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 290(end)  ************** 

***************   Case 291   ***************

SQL: select t9.c2, t9.c3, t9.c2, t10.c3 from t9, t10 where t9.c2 = t10.c2 and t9.c3 = t10.c3 order by t9.c2, t9.c3 desc; 

==============================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST   |
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |1921193  |2559613|
|1 | EXCHANGE OUT DISTR           |:EX10001|1921193  |2195893|
|2 |  MERGE JOIN                  |        |1921193  |2195893|
|3 |   SORT                       |        |100000   |285411 |
|4 |    EXCHANGE IN DISTR         |        |100000   |73532  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100000   |64066  |
|6 |      TABLE SCAN              |t9      |100000   |64066  |
|7 |   SORT                       |        |200000   |568802 |
|8 |    PX PARTITION ITERATOR     |        |200000   |128131 |
|9 |     TABLE SCAN               |t10     |200000   |128131 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c2], [t9.c3], [t9.c2], [t10.c3]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  1 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), dop=1
  2 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  3 - output([t9.c2], [t9.c3]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  4 - output([t9.c2], [t9.c3]), filter(nil)
  5 - (#keys=1, [t9.c2]), output([t9.c2], [t9.c3]), filter(nil), is_single, dop=1
  6 - output([t9.c2], [t9.c3]), filter(nil), 
      access([t9.c2], [t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  7 - output([t10.c3], [t10.c2]), filter(nil), sort_keys([t10.c2, ASC], [t10.c3, DESC])
  8 - output([t10.c2], [t10.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t10.c2], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 291(end)  ************** 

***************   Case 292   ***************

SQL: select c1, (select count(c1) from t7 where c1=t4.c1) calc_total, (select count(c1) from t8 where c1=0 and c1=t4.c1) calc_new from t4 where c1 in (select distinct c1 from t1); 

===============================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST    |
---------------------------------------------------------------
|0 |SUBPLAN FILTER                |        |99000    |10336222|
|1 | PX COORDINATOR               |        |99000    |1568269 |
|2 |  EXCHANGE OUT DISTR          |:EX10001|99000    |1558898 |
|3 |   MERGE JOIN                 |        |99000    |1558898 |
|4 |    EXCHANGE IN DISTR         |        |100000   |66593   |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100000   |61860   |
|6 |      TABLE SCAN              |t4      |100000   |61860   |
|7 |    SORT                      |        |500000   |1350777 |
|8 |     PX PARTITION ITERATOR    |        |500000   |298233  |
|9 |      TABLE SCAN              |t1      |500000   |298233  |
|10| SCALAR GROUP BY              |        |1        |37      |
|11|  TABLE GET                   |t7      |1        |36      |
|12| SCALAR GROUP BY              |        |1        |53      |
|13|  TABLE GET                   |t8      |1        |52      |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [subquery(1)], [subquery(2)]), filter(nil), 
      exec_params_([t4.c1], [t4.c1 = ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil)
  2 - output([t4.c1]), filter(nil), dop=1
  3 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  4 - output([t4.c1]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  11 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  12 - output([T_FUN_COUNT(t8.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t8.c1)])
  13 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[0 ; 0], 
      range_cond([t8.c1 = ?])

*************** Case 292(end)  ************** 

***************   Case 293   ***************

SQL: select c1, (select count(c1) from t7 ) calc_total, (select count(c1) from t8 ) calc_new from t4  where c1 in (select distinct c1 from t1); 

================================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST   |
----------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN      |        |99000    |2553002|
|1 | SUBPLAN SCAN                   |VIEW3   |1        |78756  |
|2 |  SCALAR GROUP BY               |        |1        |78755  |
|3 |   TABLE SCAN                   |t8      |100000   |59654  |
|4 | MATERIAL                       |        |99000    |1765690|
|5 |  NESTED-LOOP JOIN CARTESIAN    |        |99000    |1711115|
|6 |   SUBPLAN SCAN                 |VIEW2   |1        |78756  |
|7 |    SCALAR GROUP BY             |        |1        |78755  |
|8 |     TABLE SCAN                 |t7      |100000   |59654  |
|9 |   PX COORDINATOR               |        |99000    |1568269|
|10|    EXCHANGE OUT DISTR          |:EX10001|99000    |1558898|
|11|     MERGE JOIN                 |        |99000    |1558898|
|12|      EXCHANGE IN DISTR         |        |100000   |66593  |
|13|       EXCHANGE OUT DISTR (PKEY)|:EX10000|100000   |61860  |
|14|        TABLE SCAN              |t4      |100000   |61860  |
|15|      SORT                      |        |500000   |1350777|
|16|       PX PARTITION ITERATOR    |        |500000   |298233 |
|17|        TABLE SCAN              |t1      |500000   |298233 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [VIEW2.count(c1)], [VIEW3.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([VIEW3.count(c1)]), filter(nil), 
      access([VIEW3.count(c1)])
  2 - output([T_FUN_COUNT(t8.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t8.c1)])
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t4.c1], [VIEW2.count(c1)]), filter(nil)
  5 - output([t4.c1], [VIEW2.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  6 - output([VIEW2.count(c1)]), filter(nil), 
      access([VIEW2.count(c1)])
  7 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  8 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  9 - output([t4.c1]), filter(nil)
  10 - output([t4.c1]), filter(nil), dop=1
  11 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  12 - output([t4.c1]), filter(nil)
  13 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  14 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  15 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  16 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  17 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 293(end)  ************** 

***************   Case 294   ***************

SQL: select distinct (select c1) from t4 limit 100; 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |LIMIT          |    |100      |84048|
|1 | MERGE DISTINCT|    |100      |84035|
|2 |  TABLE SCAN   |t4  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  2 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 294(end)  ************** 

***************   Case 295   ***************

SQL: select * from t4 where c1 > 0 and c1 < 100 order by c2 limit 1; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|1        |47  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 > ?], [t4.c1 < ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 295(end)  ************** 

***************   Case 296   ***************

SQL: select * from tt1 where c2 like "a%"; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |5000     |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, 'a%', '\\')]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 296(end)  ************** 

***************   Case 297   ***************

SQL: select * from tt1 where c2 like "ab%"; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |5000     |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, 'ab%', '\\')]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 297(end)  ************** 

***************   Case 298   ***************

SQL: select * from tt1 where c2 between "aa" and "ab"; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |5000     |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 298(end)  ************** 

***************   Case 299   ***************

SQL: select * from tt1 where c2 between "aa" and "ai"; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |5000     |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 299(end)  ************** 

***************   Case 300   ***************

SQL: select * from tt1 where c2 not between "aa" and "ab"; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |20000    |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 300(end)  ************** 

***************   Case 301   ***************

SQL: select * from tt1 where c2 not between "aa" and "ai"; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |20000    |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 301(end)  ************** 

***************   Case 302   ***************

SQL: select * from tt1 where "ag" between c2 and "ai"; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |10000    |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, ?, tt1.c2, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 302(end)  ************** 

***************   Case 303   ***************

SQL: select * from tt1 where "ag" between "aa" and "c2"; 

====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|tt1 |100000   |61860|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter(nil), startup_filter([1]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 303(end)  ************** 

***************   Case 304   ***************

SQL: select * from tt1 where 'ag' not between c1 and 'ai'; 

=====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST  |
-------------------------------------
|0 |TABLE SCAN|tt1 |33334    |108697|
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, ?, tt1.c1, ?)]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 304(end)  ************** 

***************   Case 305   ***************

SQL: SELECT id, k, c, pad FROM sbtest_sysbench WHERE k IN(1,2,3,4,5,6,7,8,9,10); 

======================================================
|ID|OPERATOR  |NAME                  |EST. ROWS|COST |
------------------------------------------------------
|0 |TABLE SCAN|sbtest_sysbench(key_1)|9900     |58320|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([sbtest_sysbench.id], [sbtest_sysbench.k], [sbtest_sysbench.c], [sbtest_sysbench.pad]), filter(nil), 
      access([sbtest_sysbench.k], [sbtest_sysbench.id], [sbtest_sysbench.c], [sbtest_sysbench.pad]), partitions(p0), 
      is_index_back=true, 
      range_key([sbtest_sysbench.k], [sbtest_sysbench.id]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), (3,MIN ; 3,MAX), (4,MIN ; 4,MAX), (5,MIN ; 5,MAX), (6,MIN ; 6,MAX), (7,MIN ; 7,MAX), (8,MIN ; 8,MAX), (9,MIN ; 9,MAX), (10,MIN ; 10,MAX), 
      range_cond([sbtest_sysbench.k IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)])

*************** Case 305(end)  ************** 

***************   Case 306   ***************

SQL: select a1 from test_limit limit 1000; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1000     |691 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1]), filter(nil), 
      access([test_limit.a1]), partitions(p0), 
      limit(1000), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 306(end)  ************** 

***************   Case 307   ***************

SQL: select a1,a2,a3 from test_limit limit 1000; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1000     |736 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3]), partitions(p0), 
      limit(1000), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 307(end)  ************** 

***************   Case 308   ***************

SQL: select * from test_limit limit 1000; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1000     |802 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), partitions(p0), 
      limit(1000), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 308(end)  ************** 

***************   Case 309   ***************

SQL: select a1 from test_limit limit 500; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|500      |364 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1]), filter(nil), 
      access([test_limit.a1]), partitions(p0), 
      limit(500), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 309(end)  ************** 

***************   Case 310   ***************

SQL: select a1,a2,a3 from test_limit limit 500; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|500      |386 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3]), partitions(p0), 
      limit(500), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 310(end)  ************** 

***************   Case 311   ***************

SQL: select * from test_limit limit 500; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|500      |419 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), partitions(p0), 
      limit(500), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 311(end)  ************** 

***************   Case 312   ***************

SQL: select * from cb_dep_acctbal_54 s,  cb_dep_acct_54 a where s.acctnbr = a.acctnbr and (a.curracctstatcd != 'CLS' or (a.curracctstatcd = 'CLS' and exists(select 1 from cb_dep_rxtnbal_54 r where r.acctnbr = a.acctnbr))); 

===================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------------
|0 |UNION ALL                          |        |102960   |2090545|
|1 | PX COORDINATOR                    |        |99000    |1851525|
|2 |  EXCHANGE OUT DISTR               |:EX10001|99000    |1835125|
|3 |   MERGE JOIN                      |        |99000    |1835125|
|4 |    EXCHANGE IN DISTR              |        |100000   |73532  |
|5 |     EXCHANGE OUT DISTR (PKEY)     |:EX10000|100000   |64066  |
|6 |      TABLE SCAN                   |s       |100000   |64066  |
|7 |    SORT                           |        |490050   |1621439|
|8 |     PX PARTITION ITERATOR         |        |490050   |543447 |
|9 |      TABLE SCAN                   |a       |490050   |543447 |
|10| MERGE JOIN                        |        |3961     |183319 |
|11|  PX COORDINATOR MERGE SORT        |        |100      |103089 |
|12|   EXCHANGE OUT DISTR              |:EX20001|100      |103062 |
|13|    SORT                           |        |100      |103062 |
|14|     NESTED-LOOP JOIN              |        |100      |102865 |
|15|      EXCHANGE IN DISTR            |        |101      |99202  |
|16|       EXCHANGE OUT DISTR (BC2HOST)|:EX20000|101      |99182  |
|17|        SUBPLAN SCAN               |VIEW3   |101      |99182  |
|18|         HASH DISTINCT             |        |101      |99169  |
|19|          TABLE SCAN               |r       |100000   |66272  |
|20|      PX PARTITION ITERATOR        |        |1        |37     |
|21|       TABLE GET                   |a       |1        |37     |
|22|  TABLE SCAN                       |s       |100000   |64066  |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])], [UNION([5])]), filter(nil)
  1 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd]), filter(nil)
  2 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd]), filter(nil), dop=1
  3 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd]), filter(nil), 
      equal_conds([s.acctnbr = a.acctnbr]), other_conds(nil)
  4 - output([s.acctnbr], [s.balcatcd], [s.baltypcd]), filter(nil)
  5 - (#keys=1, [s.acctnbr]), output([s.acctnbr], [s.balcatcd], [s.baltypcd]), filter(nil), is_single, dop=1
  6 - output([s.acctnbr], [s.balcatcd], [s.baltypcd]), filter(nil), 
      access([s.acctnbr], [s.balcatcd], [s.baltypcd]), partitions(p0), 
      is_index_back=false, 
      range_key([s.acctnbr], [s.balcatcd], [s.baltypcd]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([a.acctnbr], [a.curracctstatcd]), filter(nil), sort_keys([a.acctnbr, ASC]), local merge sort
  8 - output([a.acctnbr], [a.curracctstatcd]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([a.acctnbr], [a.curracctstatcd]), filter([a.curracctstatcd != ?]), 
      access([a.acctnbr], [a.curracctstatcd]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([a.acctnbr]), range(MIN ; MAX)always true
  10 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd]), filter(nil), 
      equal_conds([s.acctnbr = a.acctnbr]), other_conds(nil)
  11 - output([a.acctnbr], [a.curracctstatcd]), filter(nil), sort_keys([a.acctnbr, ASC])
  12 - output([a.acctnbr], [a.curracctstatcd]), filter(nil), dop=1
  13 - output([a.acctnbr], [a.curracctstatcd]), filter(nil), sort_keys([a.acctnbr, ASC])
  14 - output([a.acctnbr], [a.curracctstatcd]), filter(nil), 
      conds(nil), nl_params_([VIEW3.VIEW2.r.acctnbr]), batch_join=false
  15 - output([VIEW3.VIEW2.r.acctnbr]), filter(nil)
  16 - output([VIEW3.VIEW2.r.acctnbr]), filter(nil), is_single, dop=1
  17 - output([VIEW3.VIEW2.r.acctnbr]), filter(nil), 
      access([VIEW3.VIEW2.r.acctnbr])
  18 - output([cast(r.acctnbr, BIGINT(20, 0))]), filter(nil), 
      distinct([cast(r.acctnbr, BIGINT(20, 0))])
  19 - output([cast(r.acctnbr, BIGINT(20, 0))]), filter(nil), 
      access([r.acctnbr]), partitions(p0), 
      is_index_back=false, 
      range_key([r.__pk_increment], [r.__pk_cluster_id], [r.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  20 - output([a.acctnbr], [a.curracctstatcd]), filter(nil), 
      access all, force partition granule, asc.
  21 - output([a.acctnbr], [a.curracctstatcd]), filter([a.curracctstatcd = ?], [lnnvl(a.curracctstatcd != ?)]), 
      access([a.acctnbr], [a.curracctstatcd]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([a.acctnbr]), range(MIN ; MAX), 
      range_cond([? = a.acctnbr])
  22 - output([s.acctnbr], [s.balcatcd], [s.baltypcd]), filter(nil), 
      access([s.acctnbr], [s.balcatcd], [s.baltypcd]), partitions(p0), 
      is_index_back=false, 
      range_key([s.acctnbr], [s.balcatcd], [s.baltypcd]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 312(end)  ************** 

