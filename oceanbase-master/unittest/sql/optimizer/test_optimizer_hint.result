***************   Case 1   ***************

SQL: select /*+ log_level(debug)*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      LOG_LEVEL('debug')
      END_OUTLINE_DATA
  */

*************** Case 1(end)  ************** 

***************   Case 2   ***************

SQL: select /*+ log_level('sql.opt:debug')*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      LOG_LEVEL('sql.opt:debug')
      END_OUTLINE_DATA
  */

*************** Case 2(end)  ************** 

***************   Case 3   ***************

SQL: select /*+ leading(ta, tb) use_nl(tb)*/ * from hint.t1 as tb, opt.t1 as ta where tb.a = ta.c1; 

======================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST |
------------------------------------------------------
|0 |NESTED-LOOP JOIN        |        |100      |18746|
|1 | PX COORDINATOR         |        |500      |389  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |342  |
|3 |   PX PARTITION ITERATOR|        |500      |342  |
|4 |    TABLE SCAN          |ta      |500      |342  |
|5 | TABLE GET              |tb      |1        |36   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([tb.a], [tb.b], [ta.c1], [ta.c2]), filter(nil), 
      conds(nil), nl_params_([ta.c1])
  1 - output([ta.c1], [ta.c2]), filter(nil)
  2 - output([ta.c1], [ta.c2]), filter(nil), dop=1
  3 - output([ta.c1], [ta.c2]), filter(nil)
  4 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) BC2HOST NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.tb"@"SEL$1" ))
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 3(end)  ************** 

***************   Case 4   ***************

SQL: select /*+ leading(ta, tb) use_bnl(tb)*/ * from hint.t1 as tb, opt.t1 as ta where tb.a = ta.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |ta      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |100 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |tb      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([tb.a], [tb.b], [ta.c1], [ta.c2]), filter(nil)
  1 - output([tb.a], [tb.b], [ta.c1], [ta.c2]), filter(nil), dop=1
  2 - output([tb.a], [tb.b], [ta.c1], [ta.c2]), filter(nil), 
      equal_conds([tb.a = ta.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  4 - output([ta.c1], [ta.c2]), filter(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  6 - output([tb.a], [tb.b]), filter(nil)
  7 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  8 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 4(end)  ************** 

***************   Case 5   ***************

SQL: select /*+ leading(t1) use_nl(hint.t1)*/ * from hint.t2, hint.t1, opt.t1 where hint.t2.a = opt.t1.c1; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN    |        |10000    |8642|
|1 | PX COORDINATOR               |        |100      |1334|
|2 |  EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|3 |   MERGE JOIN                 |        |100      |1316|
|4 |    EXCHANGE IN DISTR         |        |100      |100 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|6 |      TABLE SCAN              |t2      |100      |90  |
|7 |    SORT                      |        |500      |1074|
|8 |     PX PARTITION ITERATOR    |        |500      |342 |
|9 |      TABLE SCAN              |t1      |500      |342 |
|10| MATERIAL                     |        |100      |127 |
|11|  TABLE SCAN                  |t1      |100      |90  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.a], [t2.b], [t1.a], [t1.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  2 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.a = t1.c1]), other_conds(nil)
  4 - output([t2.a], [t2.b]), filter(nil)
  5 - (#keys=1, [t2.a]), output([t2.a], [t2.b]), filter(nil), is_single, dop=1
  6 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  10 - output([t1.a], [t1.b]), filter(nil)
  11 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" )"hint.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 5(end)  ************** 

***************   Case 6   ***************

SQL: select /*+ leading(t1) use_bnl(hint.t1)*/ * from hint.t2, hint.t1, opt.t1 where hint.t2.a = opt.t1.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN     |        |10000    |8887|
|1 | TABLE SCAN                    |t1      |100      |90  |
|2 | MATERIAL                      |        |100      |1408|
|3 |  PX COORDINATOR               |        |100      |1334|
|4 |   EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|5 |    MERGE JOIN                 |        |100      |1316|
|6 |     EXCHANGE IN DISTR         |        |100      |100 |
|7 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |       TABLE SCAN              |t2      |100      |90  |
|9 |     SORT                      |        |500      |1074|
|10|      PX PARTITION ITERATOR    |        |500      |342 |
|11|       TABLE SCAN              |t1      |500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.a], [t2.b], [t1.a], [t1.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  3 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  4 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.a = t1.c1]), other_conds(nil)
  6 - output([t2.a], [t2.b]), filter(nil)
  7 - (#keys=1, [t2.a]), output([t2.a], [t2.b]), filter(nil), is_single, dop=1
  8 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  9 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" )))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 6(end)  ************** 

***************   Case 7   ***************

SQL: select /*+ leading(t2, t1) use_merge(t1)*/ * from hint.t2, opt.t1 where t1.c1 = t2.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   EXCHANGE IN DISTR         |        |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t2      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  1 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.a]), other_conds(nil)
  3 - output([t2.a], [t2.b]), filter(nil)
  4 - (#keys=1, [t2.a]), output([t2.a], [t2.b]), filter(nil), is_single, dop=1
  5 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 7(end)  ************** 

***************   Case 8   ***************

SQL: select /*+ index(hint.t1 idx_t1_a)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c1; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |1847|
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |1828|
|2 |  MERGE JOIN                 |            |100      |1828|
|3 |   SORT                      |            |500      |1074|
|4 |    PX PARTITION ITERATOR    |            |500      |342 |
|5 |     TABLE SCAN              |t1          |500      |342 |
|6 |   EXCHANGE IN DISTR         |            |100      |613 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |603 |
|8 |     TABLE SCAN              |t1(idx_t1_a)|100      |603 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t1.a], [t1.b]), filter(nil)
  7 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  8 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      INDEX(@"SEL$1" "hint.t1"@"SEL$1" "idx_t1_a")
      END_OUTLINE_DATA
  */

*************** Case 8(end)  ************** 

***************   Case 9   ***************

SQL: select /*+ full(opt.t1)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |490      |1061|
|1 | TABLE SCAN             |t1      |100      |90  |
|2 | PX COORDINATOR         |        |500      |389 |
|3 |  EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|4 |   PX PARTITION ITERATOR|        |500      |342 |
|5 |    TABLE SCAN          |t1      |500      |342 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 9(end)  ************** 

***************   Case 10   ***************

SQL: select /*+ ordered use_nl(hint.t2 opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

============================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST    |
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |11435129|
|1 | NESTED-LOOP JOIN CARTESIAN|        |50000    |36567   |
|2 |  TABLE SCAN               |t2      |100      |90      |
|3 |  MATERIAL                 |        |500      |573     |
|4 |   PX COORDINATOR          |        |500      |389     |
|5 |    EXCHANGE OUT DISTR     |:EX10000|500      |342     |
|6 |     PX PARTITION ITERATOR |        |500      |342     |
|7 |      TABLE SCAN           |t1      |500      |342     |
|8 | MATERIAL                  |        |300      |621     |
|9 |  PX COORDINATOR           |        |300      |290     |
|10|   EXCHANGE OUT DISTR      |:EX20000|300      |205     |
|11|    PX PARTITION ITERATOR  |        |300      |205     |
|12|     TABLE SCAN            |t2      |300      |205     |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 10(end)  ************** 

***************   Case 11   ***************

SQL: select /*+ ordered use_bnl(hint.t2 opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

============================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST    |
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |11434982|
|1 | NESTED-LOOP JOIN CARTESIAN|        |50000    |36420   |
|2 |  PX COORDINATOR           |        |500      |389     |
|3 |   EXCHANGE OUT DISTR      |:EX10000|500      |342     |
|4 |    PX PARTITION ITERATOR  |        |500      |342     |
|5 |     TABLE SCAN            |t1      |500      |342     |
|6 |  MATERIAL                 |        |100      |127     |
|7 |   TABLE SCAN              |t2      |100      |90      |
|8 | MATERIAL                  |        |300      |621     |
|9 |  PX COORDINATOR           |        |300      |290     |
|10|   EXCHANGE OUT DISTR      |:EX20000|300      |205     |
|11|    PX PARTITION ITERATOR  |        |300      |205     |
|12|     TABLE SCAN            |t2      |300      |205     |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t2.a], [t2.b]), filter(nil)
  7 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "hint.t2"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 11(end)  ************** 

***************   Case 12   ***************

SQL: select /*+ leading(tb, opt.t1) use_nl(hint.t2 opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

============================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST    |
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |10879962|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |108575  |
|2 |  PX COORDINATOR           |        |300      |290     |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |205     |
|4 |    PX PARTITION ITERATOR  |        |300      |205     |
|5 |     TABLE SCAN            |t2      |300      |205     |
|6 |  MATERIAL                 |        |500      |573     |
|7 |   PX COORDINATOR          |        |500      |389     |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |342     |
|9 |     PX PARTITION ITERATOR |        |500      |342     |
|10|      TABLE SCAN           |t1      |500      |342     |
|11| MATERIAL                  |        |100      |127     |
|12|  TABLE SCAN               |t2      |100      |90      |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  11 - output([t2.a], [t2.b]), filter(nil)
  12 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" )"hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 12(end)  ************** 

***************   Case 13   ***************

SQL: select /*+ leading(tb, opt.t1) use_bnl(hint.t2, opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

============================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST    |
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |10879962|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |108575  |
|2 |  PX COORDINATOR           |        |300      |290     |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |205     |
|4 |    PX PARTITION ITERATOR  |        |300      |205     |
|5 |     TABLE SCAN            |t2      |300      |205     |
|6 |  MATERIAL                 |        |500      |573     |
|7 |   PX COORDINATOR          |        |500      |389     |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |342     |
|9 |     PX PARTITION ITERATOR |        |500      |342     |
|10|      TABLE SCAN           |t1      |500      |342     |
|11| MATERIAL                  |        |100      |127     |
|12|  TABLE SCAN               |t2      |100      |90      |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  11 - output([t2.a], [t2.b]), filter(nil)
  12 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" )"hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 13(end)  ************** 

***************   Case 14   ***************

SQL: select * from opt.t1,opt.t2 use index (idx_t1_c2) where opt.t1.c1 = opt.t2.c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |290      |1651|
|1 | EXCHANGE OUT DISTR          |:EX10001|290      |1541|
|2 |  HASH JOIN                  |        |290      |1541|
|3 |   PX PARTITION ITERATOR     |        |500      |342 |
|4 |    TABLE SCAN               |t1      |500      |342 |
|5 |   EXCHANGE IN DISTR         |        |300      |290 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |205 |
|7 |     PX PARTITION ITERATOR   |        |300      |205 |
|8 |      TABLE SCAN             |t2      |300      |205 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 14(end)  ************** 

***************   Case 15   ***************

SQL: select /*+ index(t1 idx_t1_c2)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |MERGE JOIN                 |             |490      |1585|
|1 | PX COORDINATOR MERGE SORT |             |500      |1122|
|2 |  EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|3 |   SORT                    |             |500      |1074|
|4 |    PX PARTITION ITERATOR  |             |500      |342 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
|6 | TABLE SCAN                |t1           |100      |90  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 15(end)  ************** 

***************   Case 16   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |MERGE JOIN                 |             |490      |1585|
|1 | PX COORDINATOR MERGE SORT |             |500      |1122|
|2 |  EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|3 |   SORT                    |             |500      |1074|
|4 |    PX PARTITION ITERATOR  |             |500      |342 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
|6 | TABLE SCAN                |t1           |100      |90  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 16(end)  ************** 

***************   Case 17   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(hint.t2, hint.t1)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |MERGE JOIN                 |             |490      |1585|
|1 | PX COORDINATOR MERGE SORT |             |500      |1122|
|2 |  EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|3 |   SORT                    |             |500      |1074|
|4 |    PX PARTITION ITERATOR  |             |500      |342 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
|6 | TABLE SCAN                |t1           |100      |90  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 17(end)  ************** 

***************   Case 18   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(test hint.t2) use_nl(hint.t1)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |MERGE JOIN                 |             |490      |1585|
|1 | TABLE SCAN                |t1           |100      |90  |
|2 | PX COORDINATOR MERGE SORT |             |500      |1122|
|3 |  EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|4 |   SORT                    |             |500      |1074|
|5 |    PX PARTITION ITERATOR  |             |500      |342 |
|6 |     TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 18(end)  ************** 

***************   Case 19   ***************

SQL: select /*+ index(ta idx_t1_c2) use_merge(test) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |100      |811 |
|1 | EXCHANGE OUT DISTR          |:EX10001     |100      |792 |
|2 |  HASH JOIN                  |             |100      |792 |
|3 |   EXCHANGE IN DISTR         |             |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |90  |
|5 |     TABLE SCAN              |tb           |100      |90  |
|6 |   PX PARTITION ITERATOR     |             |500      |342 |
|7 |    TABLE SCAN               |ta(idx_t1_c2)|500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 19(end)  ************** 

***************   Case 20   ***************

SQL: select /*+ index(ta idx_t1_c2) use_merge(test) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |100      |811 |
|1 | EXCHANGE OUT DISTR          |:EX10001     |100      |792 |
|2 |  HASH JOIN                  |             |100      |792 |
|3 |   EXCHANGE IN DISTR         |             |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |90  |
|5 |     TABLE SCAN              |tb           |100      |90  |
|6 |   PX PARTITION ITERATOR     |             |500      |342 |
|7 |    TABLE SCAN               |ta(idx_t1_c2)|500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 20(end)  ************** 

***************   Case 21   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(opt.t2) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   EXCHANGE IN DISTR         |        |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |tb      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |ta      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 21(end)  ************** 

***************   Case 22   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(opt.t2) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   EXCHANGE IN DISTR         |        |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |tb      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |ta      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 22(end)  ************** 

***************   Case 23   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(opt.t2) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   EXCHANGE IN DISTR         |        |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |tb      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |ta      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 23(end)  ************** 

***************   Case 24   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(opt.t2) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   EXCHANGE IN DISTR         |        |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |tb      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |ta      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 24(end)  ************** 

***************   Case 25   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(ta tb) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |ta      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |100 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |tb      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  4 - output([ta.c1], [ta.c2]), filter(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  6 - output([tb.a], [tb.b]), filter(nil)
  7 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  8 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 25(end)  ************** 

***************   Case 26   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(ta tb) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1334|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1316|
|2 |  MERGE JOIN                 |        |100      |1316|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |ta      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |100 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |tb      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  4 - output([ta.c1], [ta.c2]), filter(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  6 - output([tb.a], [tb.b]), filter(nil)
  7 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  8 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 26(end)  ************** 

***************   Case 27   ***************

SQL: select * from opt.t1,hint.t1 use index (idx_t1_c2, idx_t1_a) where opt.t1.c1 = hint.t1.a; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |1847|
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |1828|
|2 |  MERGE JOIN                 |            |100      |1828|
|3 |   SORT                      |            |500      |1074|
|4 |    PX PARTITION ITERATOR    |            |500      |342 |
|5 |     TABLE SCAN              |t1          |500      |342 |
|6 |   EXCHANGE IN DISTR         |            |100      |613 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |603 |
|8 |     TABLE SCAN              |t1(idx_t1_a)|100      |603 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.c1 = t1.a]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t1.a], [t1.b]), filter(nil)
  7 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  8 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      INDEX(@"SEL$1" "hint.t1"@"SEL$1" "idx_t1_a")
      END_OUTLINE_DATA
  */

*************** Case 27(end)  ************** 

***************   Case 28   ***************

SQL: select * from opt.t1,hint.t1 use index (idx_t1_a, idx_t1_c2) where opt.t1.c1 = hint.t1.a; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |1847|
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |1828|
|2 |  MERGE JOIN                 |            |100      |1828|
|3 |   SORT                      |            |500      |1074|
|4 |    PX PARTITION ITERATOR    |            |500      |342 |
|5 |     TABLE SCAN              |t1          |500      |342 |
|6 |   EXCHANGE IN DISTR         |            |100      |613 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |603 |
|8 |     TABLE SCAN              |t1(idx_t1_a)|100      |603 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.c1 = t1.a]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t1.a], [t1.b]), filter(nil)
  7 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  8 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      INDEX(@"SEL$1" "hint.t1"@"SEL$1" "idx_t1_a")
      END_OUTLINE_DATA
  */

*************** Case 28(end)  ************** 

***************   Case 29   ***************

SQL: select * from opt.t1,hint.t1 force index (idx_t1_a, idx_t1_c2) where opt.t1.c1 = hint.t1.a; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |1847|
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |1828|
|2 |  MERGE JOIN                 |            |100      |1828|
|3 |   SORT                      |            |500      |1074|
|4 |    PX PARTITION ITERATOR    |            |500      |342 |
|5 |     TABLE SCAN              |t1          |500      |342 |
|6 |   EXCHANGE IN DISTR         |            |100      |613 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |603 |
|8 |     TABLE SCAN              |t1(idx_t1_a)|100      |603 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.c1 = t1.a]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t1.a], [t1.b]), filter(nil)
  7 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  8 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      INDEX(@"SEL$1" "hint.t1"@"SEL$1" "idx_t1_a")
      END_OUTLINE_DATA
  */

*************** Case 29(end)  ************** 

***************   Case 30   ***************

SQL: select * from opt.t4 force index (idx_t4_c2,idx_t4_c3,idx_t4_c2_c3) where opt.t4.c1 = opt.t4.c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c3)|1        |101 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = t4.c2]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c3")
      END_OUTLINE_DATA
  */

*************** Case 30(end)  ************** 

***************   Case 31   ***************

SQL: select * from opt.t4 ignore index (idx_t4_c2,idx_t4_c3,idx_t4_c2_c3) where opt.t4.c1 = opt.t4.c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |1        |101 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = t4.c2]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 31(end)  ************** 

***************   Case 32   ***************

SQL: select * from opt.t4 ignore index (idx_t4_c2,idx_t4_c3) where opt.t4.c1 = opt.t4.c2; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|1        |101 |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = t4.c2]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c2_c3")
      END_OUTLINE_DATA
  */

*************** Case 32(end)  ************** 

***************   Case 33   ***************

SQL: select * from opt.t4, hint.t1 ignore index (idx_t4_c2,idx_t4_c3, idx_t1_a) where opt.t4.c1 = hint.t1.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t4  |100      |92  |
|2 | TABLE SCAN|t1  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t4.c1 = t1.a]), other_conds(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 33(end)  ************** 

***************   Case 34   ***************

SQL: select * from opt.t4 as ta, hint.t1 as tb ignore index (idx_t4_c2,idx_t4_c3, idx_t1_a) where ta.c1 = tb.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|ta  |100      |92  |
|2 | TABLE SCAN|tb  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [ta.c3], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [ta.c3]), filter(nil), 
      access([ta.c1], [ta.c2], [ta.c3]), partitions(p0)
  2 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 34(end)  ************** 

***************   Case 35   ***************

SQL: select * from opt.t1 use index(idx_yeti, idx_t1_c2) where opt.t1.c1 = opt.t1.c1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |500      |431 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |500      |384 |
|2 |  PX PARTITION ITERATOR|             |500      |384 |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|500      |384 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 35(end)  ************** 

***************   Case 36   ***************

SQL: select * from opt.t4 as ta, hint.t1 as tb ignore index (idx_test, idx_t1_a) where ta.c1 = tb.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|ta  |100      |92  |
|2 | TABLE SCAN|tb  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [ta.c3], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [ta.c3]), filter(nil), 
      access([ta.c1], [ta.c2], [ta.c3]), partitions(p0)
  2 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "hint.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 36(end)  ************** 

***************   Case 37   ***************

SQL: select * from opt.t1 use index(index_t1_c2) where opt.t1.c2 = (select hint.t1.a from hint.t1,opt.t2 use index(idx_t1_a) where opt.t2.c1 = hint.t1.b); 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |SUBPLAN FILTER                 |             |5        |947 |
|1 | PX COORDINATOR                |             |5        |38  |
|2 |  EXCHANGE OUT DISTR           |:EX10000     |5        |37  |
|3 |   PX PARTITION ITERATOR       |             |5        |37  |
|4 |    TABLE SCAN                 |t1(idx_t1_c2)|5        |37  |
|5 | PX COORDINATOR                |             |100      |909 |
|6 |  EXCHANGE OUT DISTR           |:EX20001     |100      |895 |
|7 |   MERGE JOIN                  |             |100      |895 |
|8 |    SORT                       |             |100      |227 |
|9 |     EXCHANGE IN DISTR         |             |100      |100 |
|10|      EXCHANGE OUT DISTR (PKEY)|:EX20000     |100      |90  |
|11|       TABLE SCAN              |t1           |100      |90  |
|12|    SORT                       |             |300      |554 |
|13|     PX PARTITION ITERATOR     |             |300      |192 |
|14|      TABLE SCAN               |t2           |300      |192 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t1.a]), filter(nil)
  6 - output([t1.a]), filter(nil), dop=1
  7 - output([t1.a]), filter(nil), 
      equal_conds([t2.c1 = t1.b]), other_conds(nil)
  8 - output([t1.a], [t1.b]), filter(nil), sort_keys([t1.b, ASC])
  9 - output([t1.b], [t1.a]), filter(nil)
  10 - (#keys=1, [t1.b]), output([t1.b], [t1.a]), filter(nil), is_single, dop=1
  11 - output([t1.b], [t1.a]), filter(nil), 
      access([t1.b], [t1.a]), partitions(p0)
  12 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  13 - output([t2.c1]), filter(nil)
  14 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      LEADING(@"SEL$2" ("hint.t1"@"SEL$2" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$2" ))
      PQ_DISTRIBUTE(@"SEL$2" ("opt.t2"@"SEL$2" ) PARTITION NONE)
      FULL(@"SEL$2" "hint.t1"@"SEL$2")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

*************** Case 37(end)  ************** 

***************   Case 38   ***************

SQL: select /*+ idex(yeti idx_t1_c2)*/ * from (select /*+ idex(opt.t4 idx_t4_c2))*/ * from hint.t1, opt.t4 where hint.t1.a = opt.t4.c2) as yeti, opt.t1 where yeti.a = opt.t1.c2; 

================================================================
|ID|OPERATOR                   |NAME            |EST. ROWS|COST|
----------------------------------------------------------------
|0 |MERGE JOIN                 |                |490      |1764|
|1 | MERGE JOIN                |                |100      |269 |
|2 |  TABLE SCAN               |t4(idx_t4_c2_c3)|100      |92  |
|3 |  TABLE SCAN               |t1              |100      |90  |
|4 | PX COORDINATOR MERGE SORT |                |500      |1122|
|5 |  EXCHANGE OUT DISTR       |:EX10000        |500      |1074|
|6 |   SORT                    |                |500      |1074|
|7 |    PX PARTITION ITERATOR  |                |500      |342 |
|8 |     TABLE SCAN            |t1(idx_t1_c2)   |500      |342 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.a = t4.c2]), other_conds(nil)
  2 - output([t4.c2], [t4.c1], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c1], [t4.c3]), partitions(p0)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c2_c3")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 38(end)  ************** 

***************   Case 39   ***************

SQL: select /*+ idex(ta idx_t1_c2)*/ * from (select /*+ idex(opt.t4 idx_t4_c2))*/ * from hint.t1, opt.t4 where hint.t1.a = opt.t4.c2) as yeti, opt.t1 as ta where yeti.a = ta.c2; 

================================================================
|ID|OPERATOR                   |NAME            |EST. ROWS|COST|
----------------------------------------------------------------
|0 |MERGE JOIN                 |                |490      |1764|
|1 | MERGE JOIN                |                |100      |269 |
|2 |  TABLE SCAN               |t4(idx_t4_c2_c3)|100      |92  |
|3 |  TABLE SCAN               |t1              |100      |90  |
|4 | PX COORDINATOR MERGE SORT |                |500      |1122|
|5 |  EXCHANGE OUT DISTR       |:EX10000        |500      |1074|
|6 |   SORT                    |                |500      |1074|
|7 |    PX PARTITION ITERATOR  |                |500      |342 |
|8 |     TABLE SCAN            |ta(idx_t1_c2)   |500      |342 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3], [ta.c1], [ta.c2]), filter(nil), 
      equal_conds([t1.a = ta.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.a = t4.c2]), other_conds(nil)
  2 - output([t4.c2], [t4.c1], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c1], [t4.c3]), partitions(p0)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  4 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC])
  5 - output([ta.c1], [ta.c2]), filter(nil), dop=1
  6 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC]), local merge sort
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" )"opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c2_c3")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 39(end)  ************** 

***************   Case 40   ***************

SQL: select /*+ idex(opt.t1 idx_t1_c2)*/ * from (select /*+ idex(opt.t4 idx_t4_c2))*/ * from hint.t1, opt.t4 where hint.t1.a = opt.t4.c2) as yeti, opt.t1 as ta where yeti.a = ta.c2; 

================================================================
|ID|OPERATOR                   |NAME            |EST. ROWS|COST|
----------------------------------------------------------------
|0 |MERGE JOIN                 |                |490      |1764|
|1 | MERGE JOIN                |                |100      |269 |
|2 |  TABLE SCAN               |t4(idx_t4_c2_c3)|100      |92  |
|3 |  TABLE SCAN               |t1              |100      |90  |
|4 | PX COORDINATOR MERGE SORT |                |500      |1122|
|5 |  EXCHANGE OUT DISTR       |:EX10000        |500      |1074|
|6 |   SORT                    |                |500      |1074|
|7 |    PX PARTITION ITERATOR  |                |500      |342 |
|8 |     TABLE SCAN            |ta(idx_t1_c2)   |500      |342 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3], [ta.c1], [ta.c2]), filter(nil), 
      equal_conds([t1.a = ta.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.a = t4.c2]), other_conds(nil)
  2 - output([t4.c2], [t4.c1], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c1], [t4.c3]), partitions(p0)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  4 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC])
  5 - output([ta.c1], [ta.c2]), filter(nil), dop=1
  6 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC]), local merge sort
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" )"opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c2_c3")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 40(end)  ************** 

***************   Case 41   ***************

SQL: select /*+ full(opt.t1)*/ * from opt.t1 as ta , opt.t2 as tb where ta.c1 = tb.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |ta      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |tb      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c1 = tb.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), Local Order
  4 - (#keys=1, [ta.c1]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  7 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([tb.c1, ASC]), local merge sort
  8 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "opt.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 41(end)  ************** 

***************   Case 42   ***************

SQL: select /*+ full(opt.t1 opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |290      |1651|
|1 | EXCHANGE OUT DISTR          |:EX10001|290      |1541|
|2 |  HASH JOIN                  |        |290      |1541|
|3 |   PX PARTITION ITERATOR     |        |500      |342 |
|4 |    TABLE SCAN               |t1      |500      |342 |
|5 |   EXCHANGE IN DISTR         |        |300      |290 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |205 |
|7 |     PX PARTITION ITERATOR   |        |300      |205 |
|8 |      TABLE SCAN             |t2      |300      |205 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 42(end)  ************** 

***************   Case 43   ***************

SQL: select /*+ full(opt.t1 hint.t2)*/ * from opt.t1, hint.t2 where opt.t1.c1 = hint.t2.b; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |1462|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |1443|
|2 |  MERGE JOIN                  |        |100      |1443|
|3 |   SORT                       |        |500      |1074|
|4 |    PX PARTITION ITERATOR     |        |500      |342 |
|5 |     TABLE SCAN               |t1      |500      |342 |
|6 |   SORT                       |        |100      |227 |
|7 |    EXCHANGE IN DISTR         |        |100      |100 |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|9 |      TABLE SCAN              |t2      |100      |90  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil), 
      equal_conds([t1.c1 = t2.b]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t2.a], [t2.b]), filter(nil), sort_keys([t2.b, ASC])
  7 - output([t2.b], [t2.a]), filter(nil)
  8 - (#keys=1, [t2.b]), output([t2.b], [t2.a]), filter(nil), is_single, dop=1
  9 - output([t2.b], [t2.a]), filter(nil), 
      access([t2.b], [t2.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 43(end)  ************** 

***************   Case 44   ***************

SQL: select /*+ full(opt.t1) use_merge(ta)*/ * from opt.t1 as ta , opt.t2 as tb where ta.c1 = tb.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |ta      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |tb      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c1 = tb.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), Local Order
  4 - (#keys=1, [ta.c1]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  7 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([tb.c1, ASC]), local merge sort
  8 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "opt.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 44(end)  ************** 

***************   Case 45   ***************

SQL: select /*+ full(opt.ta) use_merge(ta)*/ * from opt.t1 as ta , opt.t2 as tb where ta.c1 = tb.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |ta      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |tb      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c1 = tb.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), Local Order
  4 - (#keys=1, [ta.c1]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  7 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([tb.c1, ASC]), local merge sort
  8 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.ta"@"SEL$1")
      FULL(@"SEL$1" "opt.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 45(end)  ************** 

***************   Case 46   ***************

SQL: select /*+ full(opt.t1 opt.t2) use_merge(opt.t1), use_nl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |290      |2410|
|1 | EXCHANGE OUT DISTR           |:EX10001|290      |2300|
|2 |  MERGE JOIN                  |        |290      |2300|
|3 |   SORT                       |        |300      |944 |
|4 |    EXCHANGE IN DISTR         |        |300      |290 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |205 |
|6 |      PX PARTITION ITERATOR   |        |300      |205 |
|7 |       TABLE SCAN             |t2      |300      |205 |
|8 |   SORT                       |        |500      |1074|
|9 |    PX PARTITION ITERATOR     |        |500      |342 |
|10|     TABLE SCAN               |t1      |500      |342 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, ASC])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  8 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 46(end)  ************** 

***************   Case 47   ***************

SQL: select /*+ full(opt.t1 opt.t2) use_merge(opt.t1), use_bnl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |290      |2410|
|1 | EXCHANGE OUT DISTR           |:EX10001|290      |2300|
|2 |  MERGE JOIN                  |        |290      |2300|
|3 |   SORT                       |        |300      |944 |
|4 |    EXCHANGE IN DISTR         |        |300      |290 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |205 |
|6 |      PX PARTITION ITERATOR   |        |300      |205 |
|7 |       TABLE SCAN             |t2      |300      |205 |
|8 |   SORT                       |        |500      |1074|
|9 |    PX PARTITION ITERATOR     |        |500      |342 |
|10|     TABLE SCAN               |t1      |500      |342 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, ASC])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  8 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 47(end)  ************** 

***************   Case 48   ***************

SQL: select /*+ full(opt.t1 hint.t2) use_merge(test), use_nl(opt.t1)*/ * from opt.t1, hint.t2 where opt.t1.c1 = hint.t2.b; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |1462|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |1443|
|2 |  MERGE JOIN                  |        |100      |1443|
|3 |   SORT                       |        |500      |1074|
|4 |    PX PARTITION ITERATOR     |        |500      |342 |
|5 |     TABLE SCAN               |t1      |500      |342 |
|6 |   SORT                       |        |100      |227 |
|7 |    EXCHANGE IN DISTR         |        |100      |100 |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|9 |      TABLE SCAN              |t2      |100      |90  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil), 
      equal_conds([t1.c1 = t2.b]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t2.a], [t2.b]), filter(nil), sort_keys([t2.b, ASC])
  7 - output([t2.b], [t2.a]), filter(nil)
  8 - (#keys=1, [t2.b]), output([t2.b], [t2.a]), filter(nil), is_single, dop=1
  9 - output([t2.b], [t2.a]), filter(nil), 
      access([t2.b], [t2.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 48(end)  ************** 

***************   Case 49   ***************

SQL: select /*+ full(opt.t1 hint.t2) use_merge(test), use_bnl(opt.t1)*/ * from opt.t1, hint.t2 where opt.t1.c1 = hint.t2.b; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |1462|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |1443|
|2 |  MERGE JOIN                  |        |100      |1443|
|3 |   SORT                       |        |500      |1074|
|4 |    PX PARTITION ITERATOR     |        |500      |342 |
|5 |     TABLE SCAN               |t1      |500      |342 |
|6 |   SORT                       |        |100      |227 |
|7 |    EXCHANGE IN DISTR         |        |100      |100 |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|9 |      TABLE SCAN              |t2      |100      |90  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.a], [t2.b]), filter(nil), 
      equal_conds([t1.c1 = t2.b]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t2.a], [t2.b]), filter(nil), sort_keys([t2.b, ASC])
  7 - output([t2.b], [t2.a]), filter(nil)
  8 - (#keys=1, [t2.b]), output([t2.b], [t2.a]), filter(nil), is_single, dop=1
  9 - output([t2.b], [t2.a]), filter(nil), 
      access([t2.b], [t2.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 49(end)  ************** 

***************   Case 50   ***************

SQL: select /*+ ordered use_merge(ta,tb,tc,td)*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |MERGE JOIN                         |             |33       |3891|
|1 | SORT                              |             |98       |3627|
|2 |  MERGE JOIN                       |             |98       |3351|
|3 |   PX COORDINATOR MERGE SORT       |             |490      |3121|
|4 |    EXCHANGE OUT DISTR             |:EX10001     |490      |2936|
|5 |     SORT                          |             |490      |2936|
|6 |      MERGE JOIN                   |             |490      |1648|
|7 |       EXCHANGE IN MERGE SORT DISTR|             |500      |389 |
|8 |        EXCHANGE OUT DISTR (PKEY)  |:EX10000     |500      |342 |
|9 |         PX PARTITION ITERATOR     |             |500      |342 |
|10|          TABLE SCAN               |ta(idx_t1_c2)|500      |342 |
|11|       SORT                        |             |300      |859 |
|12|        PX PARTITION ITERATOR      |             |300      |205 |
|13|         TABLE SCAN                |tb           |300      |205 |
|14|   TABLE SCAN                      |tc           |100      |90  |
|15| SORT                              |             |100      |217 |
|16|  TABLE SCAN                       |td           |100      |90  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      equal_conds([tb.c1 = td.b]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), sort_keys([tb.c1, ASC])
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      equal_conds([ta.c1 = tc.a]), other_conds(nil)
  3 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([ta.c1, ASC])
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([ta.c1, ASC])
  6 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c2 = tb.c1]), other_conds(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC]), Local Order
  8 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  9 - output([ta.c1], [ta.c2]), filter(nil)
  10 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  11 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([tb.c1, ASC]), local merge sort
  12 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  13 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])
  14 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  15 - output([td.a], [td.b]), filter(nil), sort_keys([td.b, ASC])
  16 - output([td.b], [td.a]), filter(nil), 
      access([td.b], [td.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" )"hint.tc"@"SEL$1" )"hint.td"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.td"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tc"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt.tb"@"SEL$1")
      FULL(@"SEL$1" "hint.tc"@"SEL$1")
      FULL(@"SEL$1" "hint.td"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 50(end)  ************** 

***************   Case 51   ***************

SQL: select /*+ ordered use_nl(ta tb tc td)*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

==================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST |
------------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |             |33       |39941|
|1 | NESTED-LOOP JOIN              |             |98       |36932|
|2 |  PX COORDINATOR               |             |490      |18942|
|3 |   EXCHANGE OUT DISTR          |:EX10001     |490      |18757|
|4 |    NESTED-LOOP JOIN           |             |490      |18757|
|5 |     EXCHANGE IN DISTR         |             |500      |389  |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000     |500      |342  |
|7 |       PX PARTITION ITERATOR   |             |500      |342  |
|8 |        TABLE SCAN             |ta(idx_t1_c2)|500      |342  |
|9 |     PX PARTITION ITERATOR     |             |1        |36   |
|10|      TABLE GET                |tb           |1        |36   |
|11|  TABLE GET                    |tc           |1        |36   |
|12| MATERIAL                      |             |100      |127  |
|13|  TABLE SCAN                   |td           |100      |90   |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      conds([tb.c1 = td.b]), nl_params_(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      conds(nil), nl_params_([ta.c1])
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  3 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      conds(nil), nl_params_([ta.c2])
  5 - output([ta.c1], [ta.c2], [PARTITION_ID]), filter(nil)
  6 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2], [PARTITION_ID]), filter(nil), dop=1
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  10 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])
  11 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  12 - output([td.a], [td.b]), filter(nil)
  13 - output([td.b], [td.a]), filter(nil), 
      access([td.b], [td.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" )"hint.tc"@"SEL$1" )"hint.td"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.td"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.td"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.tc"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tc"@"SEL$1" ) BC2HOST NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.tc"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.tb"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt.tb"@"SEL$1")
      FULL(@"SEL$1" "hint.tc"@"SEL$1")
      FULL(@"SEL$1" "hint.td"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 51(end)  ************** 

***************   Case 52   ***************

SQL: select /*+ ordered use_bnl(ta tb tc td)*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |HASH JOIN                        |             |33       |2540|
|1 | TABLE SCAN                      |td           |100      |90  |
|2 | HASH JOIN                       |             |98       |2271|
|3 |  TABLE SCAN                     |tc           |100      |90  |
|4 |  PX COORDINATOR                 |             |490      |1834|
|5 |   EXCHANGE OUT DISTR            |:EX10001     |490      |1648|
|6 |    MERGE JOIN                   |             |490      |1648|
|7 |     EXCHANGE IN MERGE SORT DISTR|             |500      |389 |
|8 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000     |500      |342 |
|9 |       PX PARTITION ITERATOR     |             |500      |342 |
|10|        TABLE SCAN               |ta(idx_t1_c2)|500      |342 |
|11|     SORT                        |             |300      |859 |
|12|      PX PARTITION ITERATOR      |             |300      |205 |
|13|       TABLE SCAN                |tb           |300      |205 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      equal_conds([tb.c1 = td.b]), other_conds(nil)
  1 - output([td.b], [td.a]), filter(nil), 
      access([td.b], [td.a]), partitions(p0)
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      equal_conds([ta.c1 = tc.a]), other_conds(nil)
  3 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  5 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  6 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c2 = tb.c1]), other_conds(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC]), Local Order
  8 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  9 - output([ta.c1], [ta.c2]), filter(nil)
  10 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  11 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([tb.c1, ASC]), local merge sort
  12 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  13 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.td"@"SEL$1" ("hint.tc"@"SEL$1" ("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" ))))
      USE_HASH(@"SEL$1" ("hint.tc"@"SEL$1" "opt.ta"@"SEL$1" "opt.tb"@"SEL$1" ))
      FULL(@"SEL$1" "hint.td"@"SEL$1")
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" ))
      FULL(@"SEL$1" "hint.tc"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt.tb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 52(end)  ************** 

***************   Case 53   ***************

SQL: select /*+ ordered*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |HASH JOIN                        |             |33       |3593|
|1 | HASH JOIN                       |             |98       |3182|
|2 |  PX COORDINATOR                 |             |490      |1834|
|3 |   EXCHANGE OUT DISTR            |:EX10001     |490      |1648|
|4 |    MERGE JOIN                   |             |490      |1648|
|5 |     EXCHANGE IN MERGE SORT DISTR|             |500      |389 |
|6 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000     |500      |342 |
|7 |       PX PARTITION ITERATOR     |             |500      |342 |
|8 |        TABLE SCAN               |ta(idx_t1_c2)|500      |342 |
|9 |     SORT                        |             |300      |859 |
|10|      PX PARTITION ITERATOR      |             |300      |205 |
|11|       TABLE SCAN                |tb           |300      |205 |
|12|  TABLE SCAN                     |tc           |100      |90  |
|13| TABLE SCAN                      |td           |100      |90  |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      equal_conds([tb.c1 = td.b]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      equal_conds([ta.c1 = tc.a]), other_conds(nil)
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  3 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c2 = tb.c1]), other_conds(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC]), Local Order
  6 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([tb.c1, ASC]), local merge sort
  10 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  11 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])
  12 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  13 - output([td.b], [td.a]), filter(nil), 
      access([td.b], [td.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" )"hint.tc"@"SEL$1" )"hint.td"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.td"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.tc"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "opt.ta"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt.tb"@"SEL$1")
      FULL(@"SEL$1" "hint.tc"@"SEL$1")
      FULL(@"SEL$1" "hint.td"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 53(end)  ************** 

***************   Case 54   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) */ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 54(end)  ************** 

***************   Case 55   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_merge(opt.t1), use_nl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|8 |     PX PARTITION ITERATOR     |        |500      |342 |
|9 |      TABLE SCAN               |t1      |500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 55(end)  ************** 

***************   Case 56   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_merge(opt.t1), use_bnl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|8 |     PX PARTITION ITERATOR     |        |500      |342 |
|9 |      TABLE SCAN               |t1      |500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 56(end)  ************** 

***************   Case 57   ***************

SQL: select /*+ leading(opt.t1 opt.t2) */ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 57(end)  ************** 

***************   Case 58   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) */ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |HASH JOIN                        |        |58       |2152|
|1 | MERGE JOIN                      |        |60       |1830|
|2 |  PX COORDINATOR MERGE SORT      |        |300      |1649|
|3 |   EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|4 |    MERGE JOIN                   |        |300      |1536|
|5 |     EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|6 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|7 |       PX PARTITION ITERATOR     |        |500      |342 |
|8 |        TABLE SCAN               |t1      |500      |342 |
|9 |     SORT                        |        |300      |859 |
|10|      PX PARTITION ITERATOR      |        |300      |205 |
|11|       TABLE SCAN                |t2      |300      |205 |
|12|  TABLE SCAN                     |ha      |100      |90  |
|13| TABLE SCAN                      |hb      |100      |90  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  12 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  13 - output([hb.b], [hb.a]), filter(nil), 
      access([hb.b], [hb.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.hb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.ha"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "hint.ha"@"SEL$1")
      FULL(@"SEL$1" "hint.hb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 58(end)  ************** 

***************   Case 59   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_merge(opt.t1 ha) use_nl(opt.t1 hb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |NESTED-LOOP JOIN                 |        |58       |3740|
|1 | MERGE JOIN                      |        |60       |1830|
|2 |  PX COORDINATOR MERGE SORT      |        |300      |1649|
|3 |   EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|4 |    MERGE JOIN                   |        |300      |1536|
|5 |     EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|6 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|7 |       PX PARTITION ITERATOR     |        |500      |342 |
|8 |        TABLE SCAN               |t1      |500      |342 |
|9 |     SORT                        |        |300      |859 |
|10|      PX PARTITION ITERATOR      |        |300      |205 |
|11|       TABLE SCAN                |t2      |300      |205 |
|12|  TABLE SCAN                     |ha      |100      |90  |
|13| MATERIAL                        |        |100      |127 |
|14|  TABLE SCAN                     |hb      |100      |90  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      conds([t2.c2 = hb.b]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  12 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  13 - output([hb.a], [hb.b]), filter(nil)
  14 - output([hb.b], [hb.a]), filter(nil), 
      access([hb.b], [hb.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.hb"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.hb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.ha"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "hint.ha"@"SEL$1")
      FULL(@"SEL$1" "hint.hb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 59(end)  ************** 

***************   Case 60   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_merge(opt.t1 ha) use_bnl(opt.t1 hb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |HASH JOIN                        |        |58       |2102|
|1 | TABLE SCAN                      |hb      |100      |90  |
|2 | MERGE JOIN                      |        |60       |1830|
|3 |  PX COORDINATOR MERGE SORT      |        |300      |1649|
|4 |   EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|5 |    MERGE JOIN                   |        |300      |1536|
|6 |     EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|7 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|8 |       PX PARTITION ITERATOR     |        |500      |342 |
|9 |        TABLE SCAN               |t1      |500      |342 |
|10|     SORT                        |        |300      |859 |
|11|      PX PARTITION ITERATOR      |        |300      |205 |
|12|       TABLE SCAN                |t2      |300      |205 |
|13|  TABLE SCAN                     |ha      |100      |90  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([hb.b], [hb.a]), filter(nil), 
      access([hb.b], [hb.a]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  13 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.hb"@"SEL$1" (("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" "hint.ha"@"SEL$1" ))
      FULL(@"SEL$1" "hint.hb"@"SEL$1")
      USE_MERGE(@"SEL$1" ("hint.ha"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "hint.ha"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 60(end)  ************** 

***************   Case 61   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) use_merge(test opt.t1 opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 61(end)  ************** 

***************   Case 62   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) use_merge(test opt.t1) use_nl(test opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|8 |     PX PARTITION ITERATOR     |        |500      |342 |
|9 |      TABLE SCAN               |t1      |500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 62(end)  ************** 

***************   Case 63   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) use_merge(test opt.t1) use_bnl(test opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|8 |     PX PARTITION ITERATOR     |        |500      |342 |
|9 |      TABLE SCAN               |t1      |500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 63(end)  ************** 

***************   Case 64   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_nl(opt.t1 opt.t3 opt.t5)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 64(end)  ************** 

***************   Case 65   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_bnl(opt.t1 opt.t3 opt.t5)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 65(end)  ************** 

***************   Case 66   ***************

SQL: select /*+ leading(opt.t1 opt.t2) use_nl()*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 66(end)  ************** 

***************   Case 67   ***************

SQL: select /*+ leading(opt.t1 opt.t2) use_bnl()*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 67(end)  ************** 

***************   Case 68   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_nl(ta hint.t1 hint.t2 tb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |HASH JOIN                        |        |58       |2152|
|1 | MERGE JOIN                      |        |60       |1830|
|2 |  PX COORDINATOR MERGE SORT      |        |300      |1649|
|3 |   EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|4 |    MERGE JOIN                   |        |300      |1536|
|5 |     EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|6 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|7 |       PX PARTITION ITERATOR     |        |500      |342 |
|8 |        TABLE SCAN               |t1      |500      |342 |
|9 |     SORT                        |        |300      |859 |
|10|      PX PARTITION ITERATOR      |        |300      |205 |
|11|       TABLE SCAN                |t2      |300      |205 |
|12|  TABLE SCAN                     |ha      |100      |90  |
|13| TABLE SCAN                      |hb      |100      |90  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  12 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  13 - output([hb.b], [hb.a]), filter(nil), 
      access([hb.b], [hb.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.hb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.ha"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "hint.ha"@"SEL$1")
      FULL(@"SEL$1" "hint.hb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 68(end)  ************** 

***************   Case 69   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_bnl(ta hint.t1 hint.t2 tb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |HASH JOIN                        |        |58       |2152|
|1 | MERGE JOIN                      |        |60       |1830|
|2 |  PX COORDINATOR MERGE SORT      |        |300      |1649|
|3 |   EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|4 |    MERGE JOIN                   |        |300      |1536|
|5 |     EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|6 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|7 |       PX PARTITION ITERATOR     |        |500      |342 |
|8 |        TABLE SCAN               |t1      |500      |342 |
|9 |     SORT                        |        |300      |859 |
|10|      PX PARTITION ITERATOR      |        |300      |205 |
|11|       TABLE SCAN                |t2      |300      |205 |
|12|  TABLE SCAN                     |ha      |100      |90  |
|13| TABLE SCAN                      |hb      |100      |90  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  12 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  13 - output([hb.b], [hb.a]), filter(nil), 
      access([hb.b], [hb.a]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.hb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.ha"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "hint.ha"@"SEL$1")
      FULL(@"SEL$1" "hint.hb"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 69(end)  ************** 

***************   Case 70   ***************

SQL: select t1.c1, v.c1 from t1, (select t2.c1 from t2, t4) v; 

=================================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST    |
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |15000000 |10636543|
|1 | NESTED-LOOP JOIN CARTESIAN|             |30000    |21507   |
|2 |  PX COORDINATOR           |             |300      |206     |
|3 |   EXCHANGE OUT DISTR      |:EX10000     |300      |192     |
|4 |    PX PARTITION ITERATOR  |             |300      |192     |
|5 |     TABLE SCAN            |t2           |300      |192     |
|6 |  MATERIAL                 |             |100      |73      |
|7 |   TABLE SCAN              |t4(idx_t4_c2)|100      |54      |
|8 | MATERIAL                  |             |500      |446     |
|9 |  PX COORDINATOR           |             |500      |354     |
|10|   EXCHANGE OUT DISTR      |:EX20000     |500      |331     |
|11|    PX PARTITION ITERATOR  |             |500      |331     |
|12|     TABLE SCAN            |t1           |500      |331     |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1]), filter(nil)
  3 - output([t2.c1]), filter(nil), dop=1
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t4.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t4"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t4"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 70(end)  ************** 

***************   Case 71   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+index(t4 primary)*/ t2.c1 from t2, t4) v; 

============================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST    |
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |10636579|
|1 | NESTED-LOOP JOIN CARTESIAN|        |30000    |21543   |
|2 |  PX COORDINATOR           |        |300      |206     |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |192     |
|4 |    PX PARTITION ITERATOR  |        |300      |192     |
|5 |     TABLE SCAN            |t2      |300      |192     |
|6 |  MATERIAL                 |        |100      |109     |
|7 |   TABLE SCAN              |t4      |100      |90      |
|8 | MATERIAL                  |        |500      |446     |
|9 |  PX COORDINATOR           |        |500      |354     |
|10|   EXCHANGE OUT DISTR      |:EX20000|500      |331     |
|11|    PX PARTITION ITERATOR  |        |500      |331     |
|12|     TABLE SCAN            |t1      |500      |331     |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1]), filter(nil)
  3 - output([t2.c1]), filter(nil), dop=1
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t4"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t4"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 71(end)  ************** 

***************   Case 72   ***************

SQL: select/*+no_rewrite*/ t1.c1, v.c1 from t1, (select/*+index(t4 primary)*/ t2.c1 from t2, t4) v; 

=============================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST    |
-------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |        |15000000 |10640719|
|1 | SUBPLAN SCAN               |v       |30000    |25684   |
|2 |  NESTED-LOOP JOIN CARTESIAN|        |30000    |21543   |
|3 |   PX COORDINATOR           |        |300      |206     |
|4 |    EXCHANGE OUT DISTR      |:EX10000|300      |192     |
|5 |     PX PARTITION ITERATOR  |        |300      |192     |
|6 |      TABLE SCAN            |t2      |300      |192     |
|7 |   MATERIAL                 |        |100      |109     |
|8 |    TABLE SCAN              |t4      |100      |90      |
|9 | MATERIAL                   |        |500      |446     |
|10|  PX COORDINATOR            |        |500      |354     |
|11|   EXCHANGE OUT DISTR       |:EX20000|500      |331     |
|12|    PX PARTITION ITERATOR   |        |500      |331     |
|13|     TABLE SCAN             |t1      |500      |331     |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [v.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([v.c1]), filter(nil), 
      access([v.c1])
  2 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.c1]), filter(nil)
  4 - output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), dop=1
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("v"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      LEADING(@"SEL$2" ("opt.t2"@"SEL$2" "opt.t4"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t4"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t4"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$2" "opt.t4"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      NO_REWRITE
      END_OUTLINE_DATA
  */

*************** Case 72(end)  ************** 

***************   Case 73   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+leading(t2)*/ t2.c1 from t2, t4) v; 

=================================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST    |
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |15000000 |10636543|
|1 | NESTED-LOOP JOIN CARTESIAN|             |30000    |21507   |
|2 |  PX COORDINATOR           |             |300      |206     |
|3 |   EXCHANGE OUT DISTR      |:EX10000     |300      |192     |
|4 |    PX PARTITION ITERATOR  |             |300      |192     |
|5 |     TABLE SCAN            |t2           |300      |192     |
|6 |  MATERIAL                 |             |100      |73      |
|7 |   TABLE SCAN              |t4(idx_t4_c2)|100      |54      |
|8 | MATERIAL                  |             |500      |446     |
|9 |  PX COORDINATOR           |             |500      |354     |
|10|   EXCHANGE OUT DISTR      |:EX20000     |500      |331     |
|11|    PX PARTITION ITERATOR  |             |500      |331     |
|12|     TABLE SCAN            |t1           |500      |331     |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1]), filter(nil)
  3 - output([t2.c1]), filter(nil), dop=1
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t4.c2]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t4"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t4"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 73(end)  ************** 

***************   Case 74   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+read_consistency(weak)*/ t2.c1 from t2, t4) v; 

=================================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST    |
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |15000000 |10636543|
|1 | NESTED-LOOP JOIN CARTESIAN|             |30000    |21507   |
|2 |  PX COORDINATOR           |             |300      |206     |
|3 |   EXCHANGE OUT DISTR      |:EX10000     |300      |192     |
|4 |    PX PARTITION ITERATOR  |             |300      |192     |
|5 |     TABLE SCAN            |t2           |300      |192     |
|6 |  MATERIAL                 |             |100      |73      |
|7 |   TABLE SCAN              |t4(idx_t4_c2)|100      |54      |
|8 | MATERIAL                  |             |500      |446     |
|9 |  PX COORDINATOR           |             |500      |354     |
|10|   EXCHANGE OUT DISTR      |:EX20000     |500      |331     |
|11|    PX PARTITION ITERATOR  |             |500      |331     |
|12|     TABLE SCAN            |t1           |500      |331     |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1]), filter(nil)
  3 - output([t2.c1]), filter(nil), dop=1
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      hint(read_consistency:2)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      hint(read_consistency:2)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      hint(read_consistency:2)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t4"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t4"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      READ_CONSISTENCY("WEAK")
      END_OUTLINE_DATA
  */

*************** Case 74(end)  ************** 

***************   Case 75   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+use_nl(t2, t4)*/ t2.c1 from t2, t4 where t2.c1 = t4.c1) v; 

============================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST |
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN    |        |50000    |39601|
|1 | PX COORDINATOR               |        |100      |3774 |
|2 |  EXCHANGE OUT DISTR          |:EX10001|100      |3764 |
|3 |   NESTED-LOOP JOIN           |        |100      |3764 |
|4 |    EXCHANGE IN DISTR         |        |100      |95   |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90   |
|6 |      TABLE SCAN              |t4      |100      |90   |
|7 |    PX PARTITION ITERATOR     |        |1        |36   |
|8 |     TABLE GET                |t2      |1        |36   |
|9 | MATERIAL                     |        |500      |446  |
|10|  PX COORDINATOR              |        |500      |354  |
|11|   EXCHANGE OUT DISTR         |:EX20000|500      |331  |
|12|    PX PARTITION ITERATOR     |        |500      |331  |
|13|     TABLE SCAN               |t1      |500      |331  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil)
  2 - output([t2.c1]), filter(nil), dop=1
  3 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  4 - output([t4.c1], [PARTITION_ID]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([t4.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), dop=1
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 75(end)  ************** 

***************   Case 76   ***************

SQL: (select /*+read_consistency(weak)*/ c1 from t1) union (select c1 from t2); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |800      |1472|
|1 | EXCHANGE OUT DISTR            |:EX10001|800      |1435|
|2 |  MERGE UNION DISTINCT         |        |800      |1435|
|3 |   SORT                        |        |500      |966 |
|4 |    PX PARTITION ITERATOR      |        |500      |331 |
|5 |     TABLE SCAN                |t1      |500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      hint(read_consistency:2)
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      hint(read_consistency:2)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      READ_CONSISTENCY("WEAK")
      END_OUTLINE_DATA
  */

*************** Case 76(end)  ************** 

***************   Case 77   ***************

SQL: (select /*+read_consistency(weak)*/ c1 from t1) union (select /*+read_consistency(strong)*/ c1 from t2); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |800      |1472|
|1 | EXCHANGE OUT DISTR            |:EX10001|800      |1435|
|2 |  MERGE UNION DISTINCT         |        |800      |1435|
|3 |   SORT                        |        |500      |966 |
|4 |    PX PARTITION ITERATOR      |        |500      |331 |
|5 |     TABLE SCAN                |t1      |500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

*************** Case 77(end)  ************** 

***************   Case 78   ***************

SQL: select * from opt.t1 ignore index (primary); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |500      |342 |
|2 |  PX PARTITION ITERATOR|             |500      |342 |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|500      |342 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 78(end)  ************** 

***************   Case 79   ***************

SQL: select /*+ index(@a0123456789012345678 t4@a0123456789012345678 idx_t4_c3)*/ * from t1 where c1 in (select/*+qb_name(a0123456789012345678)*/ c1 from t4); 

================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                |             |100      |1428|
|1 | EXCHANGE OUT DISTR           |:EX10001     |100      |1418|
|2 |  MERGE SEMI JOIN             |             |100      |1418|
|3 |   SORT                       |             |500      |1074|
|4 |    PX PARTITION ITERATOR     |             |500      |342 |
|5 |     TABLE SCAN               |t1           |500      |342 |
|6 |   SORT                       |             |100      |203 |
|7 |    EXCHANGE IN DISTR         |             |100      |95  |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |90  |
|9 |      TABLE SCAN              |t4(idx_t4_c3)|100      |90  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  7 - output([t4.c1]), filter(nil)
  8 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  9 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c3")
      END_OUTLINE_DATA
  */

*************** Case 79(end)  ************** 

***************   Case 80   ***************

SQL: select /*+ index(@a01234567890123456789 t4@a01234567890123456789 idx_t4_c3)*/ * from t1 where c1 in (select/*+qb_name(a01234567890123456789)*/ c1 from t4); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1320|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE SEMI JOIN            |        |100      |1311|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |t1      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |95  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |t4      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t4.c1]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 80(end)  ************** 

***************   Case 81   ***************

SQL: select /*+ index(@SEL$1 t4  idx_t4_c3)*/ * from t1 where c1 in (select/*+qb_name(yz)*/ c1 from t4); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1361|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1347|
|2 |  MERGE JOIN                 |        |100      |1347|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |t1      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |131 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |126 |
|8 |     SUBPLAN SCAN            |VIEW2   |100      |126 |
|9 |      MERGE DISTINCT         |        |100      |112 |
|10|       TABLE SCAN            |t4      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.VIEW1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([VIEW2.VIEW1.c1]), filter(nil)
  7 - (#keys=1, [VIEW2.VIEW1.c1]), output([VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  8 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  9 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$4" ("opt.t1"@"SEL$4" "VIEW2"@"SEL$4" ))
      USE_MERGE(@"SEL$4" ("VIEW2"@"SEL$4" ))
      PQ_DISTRIBUTE(@"SEL$4" ("VIEW2"@"SEL$4" ) NONE PARTITION)
      FULL(@"SEL$4" "opt.t1"@"SEL$4")
      FULL(@"SEL$3" "opt.t4"@"SEL$3")
      END_OUTLINE_DATA
  */

*************** Case 81(end)  ************** 

***************   Case 82   ***************

SQL: select /*+ leading(@SEL$1 t4  t1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   EXCHANGE IN DISTR         |        |100      |95  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t4      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 82(end)  ************** 

***************   Case 83   ***************

SQL: select /*+ leading(@SEL$1 t1  t4)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |t1      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |95  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |t4      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t4.c1]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 83(end)  ************** 

***************   Case 84   ***************

SQL: select /*+ leading(@SEL$1 t1@SEL$1  t4@YZ)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |t1      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |95  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |t4      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t4.c1]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 84(end)  ************** 

***************   Case 85   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   EXCHANGE IN DISTR         |        |100      |95  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t4      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 85(end)  ************** 

***************   Case 86   ***************

SQL: select /*+ leading(@SEL$1 t_a@YZ  t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4 t_a) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   EXCHANGE IN DISTR         |        |100      |95  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t_a     |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t_a.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t_a.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t_a.c1]), filter(nil), 
      equal_conds([t_a.c1 = t1.c1]), other_conds(nil)
  3 - output([t_a.c1]), filter(nil)
  4 - (#keys=1, [t_a.c1]), output([t_a.c1]), filter(nil), is_single, dop=1
  5 - output([t_a.c1]), filter(nil), 
      access([t_a.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t_a"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t_a"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 86(end)  ************** 

***************   Case 87   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4 t_a) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |t1      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |95  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |t_a     |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t_a.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t_a.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t_a.c1]), filter(nil), 
      equal_conds([t_a.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  6 - output([t_a.c1]), filter(nil)
  7 - (#keys=1, [t_a.c1]), output([t_a.c1]), filter(nil), is_single, dop=1
  8 - output([t_a.c1]), filter(nil), 
      access([t_a.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t_a"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t_a"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t_a"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t_a"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 87(end)  ************** 

***************   Case 88   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) use_nl(@SEL$1 t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |3780|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |3766|
|2 |  NESTED-LOOP JOIN           |        |100      |3766|
|3 |   EXCHANGE IN DISTR         |        |100      |95  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t4      |100      |90  |
|6 |   PX PARTITION ITERATOR     |        |1        |36  |
|7 |    TABLE GET                |t1      |1        |36  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  3 - output([t4.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 88(end)  ************** 

***************   Case 89   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) use_bnl(@SEL$1 t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   EXCHANGE IN DISTR         |        |100      |95  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t4      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 89(end)  ************** 

***************   Case 90   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) */ * from t1 , (select/*+qb_name(yz) use_merge(@SEL$1 t1@SEL$1)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1325|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1311|
|2 |  MERGE JOIN                 |        |100      |1311|
|3 |   EXCHANGE IN DISTR         |        |100      |95  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t4      |100      |90  |
|6 |   SORT                      |        |500      |1074|
|7 |    PX PARTITION ITERATOR    |        |500      |342 |
|8 |     TABLE SCAN              |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 90(end)  ************** 

***************   Case 91   ***************

SQL: select c1 from t1 union select /*+index(@SEL$1 t1 idx_t1_c2)*/ c1 from t2; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |800      |1409|
|1 | EXCHANGE OUT DISTR          |:EX10001     |800      |1371|
|2 |  HASH UNION DISTINCT        |             |800      |1371|
|3 |   PX PARTITION ITERATOR     |             |500      |331 |
|4 |    TABLE SCAN               |t1(idx_t1_c2)|500      |331 |
|5 |   EXCHANGE IN DISTR         |             |300      |206 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |300      |192 |
|7 |     PX PARTITION ITERATOR   |             |300      |192 |
|8 |      TABLE SCAN             |t2           |300      |192 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

*************** Case 91(end)  ************** 

***************   Case 92   ***************

SQL: select t1.c1 from t1, t2 where t1.c1 = t2.c1 union select/*+leading(@SEL$1 t1 t2) use_merge(@SEL1 t2@SEL$1)*/ c1 from t2; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |600      |2296|
|1 | EXCHANGE OUT DISTR               |:EX10002|600      |2239|
|2 |  MERGE UNION DISTINCT            |        |600      |2239|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |300      |1488|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1460|
|5 |     MERGE JOIN                   |        |300      |1460|
|6 |      SORT                        |        |500      |966 |
|7 |       PX PARTITION ITERATOR      |        |500      |331 |
|8 |        TABLE SCAN                |t1      |500      |331 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|11|        PX PARTITION ITERATOR     |        |300      |192 |
|12|         TABLE SCAN               |t2      |300      |192 |
|13|   SORT                           |        |300      |554 |
|14|    PX PARTITION ITERATOR         |        |300      |192 |
|15|     TABLE SCAN                   |t2      |300      |192 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1]), filter(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  10 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  11 - output([t2.c1]), filter(nil)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  13 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  14 - output([t2.c1]), filter(nil)
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

*************** Case 92(end)  ************** 

***************   Case 93   ***************

SQL: select/*+leading(@SEL$1 t2 t1)*/ t1.c1 from t1, t2 where t1.c1 = t2.c1 union select/*+leading(@SEL$1 t1 t2) use_merge(@SEL1 t2@SEL$1)*/ c1 from t2; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |600      |2296|
|1 | EXCHANGE OUT DISTR               |:EX10002|600      |2239|
|2 |  MERGE UNION DISTINCT            |        |600      |2239|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |300      |1488|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1460|
|5 |     MERGE JOIN                   |        |300      |1460|
|6 |      SORT                        |        |500      |966 |
|7 |       PX PARTITION ITERATOR      |        |500      |331 |
|8 |        TABLE SCAN                |t1      |500      |331 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|11|        PX PARTITION ITERATOR     |        |300      |192 |
|12|         TABLE SCAN               |t2      |300      |192 |
|13|   SORT                           |        |300      |554 |
|14|    PX PARTITION ITERATOR         |        |300      |192 |
|15|     TABLE SCAN                   |t2      |300      |192 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1]), filter(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  10 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  11 - output([t2.c1]), filter(nil)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  13 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  14 - output([t2.c1]), filter(nil)
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

*************** Case 93(end)  ************** 

***************   Case 94   ***************

SQL: (select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) */ t1.c1 from t1 , (select/*+qb_name(yz) use_merge(@SEL$1 t1@SEL$1)*/ c1 from t4) t where t.c1 = t1.c1) union select c1 from t3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |MERGE UNION DISTINCT          |        |300      |1692|
|1 | PX COORDINATOR MERGE SORT    |        |100      |1212|
|2 |  EXCHANGE OUT DISTR          |:EX10001|100      |1203|
|3 |   MERGE JOIN                 |        |100      |1203|
|4 |    EXCHANGE IN DISTR         |        |100      |95  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|6 |      TABLE SCAN              |t4      |100      |90  |
|7 |    SORT                      |        |500      |966 |
|8 |     PX PARTITION ITERATOR    |        |500      |331 |
|9 |      TABLE SCAN              |t1      |500      |331 |
|10| PX COORDINATOR MERGE SORT    |        |200      |381 |
|11|  EXCHANGE OUT DISTR          |:EX20000|200      |372 |
|12|   SORT                       |        |200      |372 |
|13|    PX PARTITION ITERATOR     |        |200      |140 |
|14|     TABLE SCAN               |t3      |200      |140 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  4 - output([t4.c1]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  10 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  11 - output([t3.c1]), filter(nil), dop=1
  12 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  13 - output([t3.c1]), filter(nil)
  14 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

*************** Case 94(end)  ************** 

***************   Case 95   ***************

SQL: (select t1.c1 from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1) union select/*+leading(@SEL$1 t4@YZ t1@SEL$1) use_merge(@SEL$1 t1@SEL$1)*/ c1 from t3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |MERGE UNION DISTINCT          |        |300      |1692|
|1 | PX COORDINATOR MERGE SORT    |        |100      |1212|
|2 |  EXCHANGE OUT DISTR          |:EX10001|100      |1203|
|3 |   MERGE JOIN                 |        |100      |1203|
|4 |    EXCHANGE IN DISTR         |        |100      |95  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|6 |      TABLE SCAN              |t4      |100      |90  |
|7 |    SORT                      |        |500      |966 |
|8 |     PX PARTITION ITERATOR    |        |500      |331 |
|9 |      TABLE SCAN              |t1      |500      |331 |
|10| PX COORDINATOR MERGE SORT    |        |200      |381 |
|11|  EXCHANGE OUT DISTR          |:EX20000|200      |372 |
|12|   SORT                       |        |200      |372 |
|13|    PX PARTITION ITERATOR     |        |200      |140 |
|14|     TABLE SCAN               |t3      |200      |140 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  4 - output([t4.c1]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  10 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  11 - output([t3.c1]), filter(nil), dop=1
  12 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  13 - output([t3.c1]), filter(nil)
  14 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

*************** Case 95(end)  ************** 

***************   Case 96   ***************

SQL: select/*+index(@SEL$1 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select t4.c1 from t4 group by t4.c2); 

================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                |             |100      |1315|
|1 | EXCHANGE OUT DISTR           |:EX10001     |100      |1311|
|2 |  MERGE SEMI JOIN             |             |100      |1311|
|3 |   SORT                       |             |500      |966 |
|4 |    PX PARTITION ITERATOR     |             |500      |331 |
|5 |     TABLE SCAN               |t1           |500      |331 |
|6 |   SORT                       |             |100      |203 |
|7 |    EXCHANGE IN DISTR         |             |100      |95  |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |90  |
|9 |      SUBPLAN SCAN            |VIEW1        |100      |90  |
|10|       MERGE GROUP BY         |             |100      |77  |
|11|        TABLE SCAN            |t4(idx_t4_c2)|100      |54  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  6 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  7 - output([VIEW1.c1]), filter(nil)
  8 - (#keys=1, [VIEW1.c1]), output([VIEW1.c1]), filter(nil), is_single, dop=1
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("VIEW1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      NO_USE_HASH_AGGREGATION(@"SEL$2")
      INDEX(@"SEL$2" "opt.t4"@"SEL$2" "idx_t4_c2")
      END_OUTLINE_DATA
  */

*************** Case 96(end)  ************** 

***************   Case 97   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select t4.c1 from t4 group by t4.c2); 

================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                |             |100      |1315|
|1 | EXCHANGE OUT DISTR           |:EX10001     |100      |1311|
|2 |  MERGE SEMI JOIN             |             |100      |1311|
|3 |   SORT                       |             |500      |966 |
|4 |    PX PARTITION ITERATOR     |             |500      |331 |
|5 |     TABLE SCAN               |t1           |500      |331 |
|6 |   SORT                       |             |100      |203 |
|7 |    EXCHANGE IN DISTR         |             |100      |95  |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |90  |
|9 |      SUBPLAN SCAN            |VIEW1        |100      |90  |
|10|       MERGE GROUP BY         |             |100      |77  |
|11|        TABLE SCAN            |t4(idx_t4_c2)|100      |54  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  6 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  7 - output([VIEW1.c1]), filter(nil)
  8 - (#keys=1, [VIEW1.c1]), output([VIEW1.c1]), filter(nil), is_single, dop=1
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("VIEW1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      NO_USE_HASH_AGGREGATION(@"SEL$2")
      INDEX(@"SEL$2" "opt.t4"@"SEL$2" "idx_t4_c2")
      END_OUTLINE_DATA
  */

*************** Case 97(end)  ************** 

***************   Case 98   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select/*+index(t4 idx_t4_c3)*/ t4.c1 from t4, (select t5.c1 from t5) t_a where t4.c2 > 1 and t4.c2 < 3 and t_a.c1 = t4.c1 group by t4.c2); 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR                  |             |72       |2087|
|1 | EXCHANGE OUT DISTR             |:EX10002     |72       |2083|
|2 |  MERGE SEMI JOIN               |             |72       |2083|
|3 |   SORT                         |             |500      |966 |
|4 |    PX PARTITION ITERATOR       |             |500      |331 |
|5 |     TABLE SCAN                 |t1           |500      |331 |
|6 |   SORT                         |             |100      |993 |
|7 |    EXCHANGE IN DISTR           |             |100      |885 |
|8 |     EXCHANGE OUT DISTR (PKEY)  |:EX10001     |100      |880 |
|9 |      SUBPLAN SCAN              |VIEW1        |100      |880 |
|10|       HASH GROUP BY            |             |100      |866 |
|11|        HASH JOIN               |             |290      |700 |
|12|         TABLE SCAN             |t4(idx_t4_c2)|100      |54  |
|13|         EXCHANGE IN DISTR      |             |300      |247 |
|14|          EXCHANGE OUT DISTR    |:EX10000     |300      |205 |
|15|           PX PARTITION ITERATOR|             |300      |205 |
|16|            TABLE SCAN          |t5           |300      |205 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  6 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  7 - output([VIEW1.c1]), filter(nil)
  8 - (#keys=1, [VIEW1.c1]), output([VIEW1.c1]), filter(nil), is_single, dop=1
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t5.c1 = t4.c1]), other_conds(nil)
  12 - output([t4.c2], [t4.c1]), filter(nil), 
      access([t4.c2], [t4.c1]), partitions(p0)
  13 - output([t5.c1]), filter(nil)
  14 - output([t5.c1]), filter(nil), dop=1
  15 - output([t5.c1]), filter(nil)
  16 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("VIEW1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      USE_HASH_AGGREGATION(@"SEL$2")
      LEADING(@"SEL$2" ("opt.t4"@"SEL$2" "opt.t5"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t5"@"SEL$2" ))
      INDEX(@"SEL$2" "opt.t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$2" "opt.t5"@"SEL$2")
      END_OUTLINE_DATA
  */

*************** Case 98(end)  ************** 

***************   Case 99   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select/*+index(t4 idx_t4_c3)*/ t4.c1 from t4, (select t5.c1 from t5) t_a where t4.c3 > 1 and t4.c3 < 3 and t_a.c1 = t4.c1 group by t4.c2); 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR                  |             |72       |2143|
|1 | EXCHANGE OUT DISTR             |:EX10002     |72       |2140|
|2 |  MERGE SEMI JOIN               |             |72       |2140|
|3 |   SORT                         |             |500      |966 |
|4 |    PX PARTITION ITERATOR       |             |500      |331 |
|5 |     TABLE SCAN                 |t1           |500      |331 |
|6 |   SORT                         |             |100      |1049|
|7 |    EXCHANGE IN DISTR           |             |100      |941 |
|8 |     EXCHANGE OUT DISTR (PKEY)  |:EX10001     |100      |937 |
|9 |      SUBPLAN SCAN              |VIEW1        |100      |937 |
|10|       HASH GROUP BY            |             |100      |923 |
|11|        HASH JOIN               |             |290      |756 |
|12|         TABLE SCAN             |t4(idx_t4_c3)|100      |92  |
|13|         EXCHANGE IN DISTR      |             |300      |247 |
|14|          EXCHANGE OUT DISTR    |:EX10000     |300      |205 |
|15|           PX PARTITION ITERATOR|             |300      |205 |
|16|            TABLE SCAN          |t5           |300      |205 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  6 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  7 - output([VIEW1.c1]), filter(nil)
  8 - (#keys=1, [VIEW1.c1]), output([VIEW1.c1]), filter(nil), is_single, dop=1
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t5.c1 = t4.c1]), other_conds(nil)
  12 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  13 - output([t5.c1]), filter(nil)
  14 - output([t5.c1]), filter(nil), dop=1
  15 - output([t5.c1]), filter(nil)
  16 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("VIEW1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      USE_HASH_AGGREGATION(@"SEL$2")
      LEADING(@"SEL$2" ("opt.t4"@"SEL$2" "opt.t5"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t5"@"SEL$2" ))
      INDEX(@"SEL$2" "opt.t4"@"SEL$2" "idx_t4_c3")
      FULL(@"SEL$2" "opt.t5"@"SEL$2")
      END_OUTLINE_DATA
  */

*************** Case 99(end)  ************** 

***************   Case 100   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) leading(@SEL$2 t5@SEL$3 t4@SEL$2)*/t1.c1 from t1 where t1.c1 in (select t4.c1 from t4, (select t5.c1 from t5) t_a where t_a.c1 = t4.c1 group by t4.c2); 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR                  |             |72       |2332|
|1 | EXCHANGE OUT DISTR             |:EX10002     |72       |2329|
|2 |  MERGE SEMI JOIN               |             |72       |2329|
|3 |   SORT                         |             |500      |966 |
|4 |    PX PARTITION ITERATOR       |             |500      |331 |
|5 |     TABLE SCAN                 |t1           |500      |331 |
|6 |   SORT                         |             |100      |1238|
|7 |    EXCHANGE IN DISTR           |             |100      |1130|
|8 |     EXCHANGE OUT DISTR (PKEY)  |:EX10001     |100      |1126|
|9 |      SUBPLAN SCAN              |VIEW1        |100      |1126|
|10|       HASH GROUP BY            |             |100      |1112|
|11|        HASH JOIN               |             |290      |945 |
|12|         EXCHANGE IN DISTR      |             |300      |247 |
|13|          EXCHANGE OUT DISTR    |:EX10000     |300      |205 |
|14|           PX PARTITION ITERATOR|             |300      |205 |
|15|            TABLE SCAN          |t5           |300      |205 |
|16|         TABLE SCAN             |t4(idx_t4_c2)|100      |54  |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  6 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  7 - output([VIEW1.c1]), filter(nil)
  8 - (#keys=1, [VIEW1.c1]), output([VIEW1.c1]), filter(nil), is_single, dop=1
  9 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  10 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t5.c1 = t4.c1]), other_conds(nil)
  12 - output([t5.c1]), filter(nil)
  13 - output([t5.c1]), filter(nil), dop=1
  14 - output([t5.c1]), filter(nil)
  15 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p[0-2])
  16 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("VIEW1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      USE_HASH_AGGREGATION(@"SEL$2")
      LEADING(@"SEL$2" ("opt.t5"@"SEL$2" "opt.t4"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t4"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t5"@"SEL$2")
      INDEX(@"SEL$2" "opt.t4"@"SEL$2" "idx_t4_c2")
      END_OUTLINE_DATA
  */

*************** Case 100(end)  ************** 

***************   Case 101   ***************

SQL: select * from hint.t1 where a in (select * from (select max(t1.a) from hint.t1, hint.t2) as tt); 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |NESTED-LOOP JOIN             |            |1        |9181|
|1 | SUBPLAN SCAN                |VIEW1       |1        |9145|
|2 |  SCALAR GROUP BY            |            |1        |9145|
|3 |   NESTED-LOOP JOIN CARTESIAN|            |10000    |7235|
|4 |    TABLE SCAN               |t1(idx_t1_a)|100      |52  |
|5 |    MATERIAL                 |            |100      |106 |
|6 |     TABLE SCAN              |t2          |100      |88  |
|7 | TABLE GET                   |t1          |1        |36  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      conds(nil), nl_params_([VIEW1.max(t1.a)])
  1 - output([VIEW1.max(t1.a)]), filter(nil), 
      access([VIEW1.max(t1.a)])
  2 - output([T_FUN_MAX(t1.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t1.a)])
  3 - output([t1.a]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t2.a]), partitions(p0)
  7 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t1"@"SEL$1" ))
      LEADING(@"SEL$3" ("hint.t1"@"SEL$3" "hint.t2"@"SEL$3" ))
      USE_NL(@"SEL$3" ("hint.t2"@"SEL$3" ))
      USE_NL_MATERIALIZATION(@"SEL$3" ("hint.t2"@"SEL$3" ))
      INDEX(@"SEL$3" "hint.t1"@"SEL$3" "idx_t1_a")
      FULL(@"SEL$3" "hint.t2"@"SEL$3")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 101(end)  ************** 

***************   Case 102   ***************

SQL: select   /*+ BEGIN_OUTLINE_DATA USE_NL(@"SEL$3" "hint.t2"@"SEL$3") LEADING(@"SEL$3" "hint.t2"@"SEL$3" "hint.t1"@"SEL$3") END_OUTLINE_DATA */* from hint.t1 where a in (select * from (select max(t1.a) from hint.t1, hint.t2) as tt); 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |NESTED-LOOP JOIN             |            |1        |9181|
|1 | SUBPLAN SCAN                |VIEW1       |1        |9145|
|2 |  SCALAR GROUP BY            |            |1        |9145|
|3 |   NESTED-LOOP JOIN CARTESIAN|            |10000    |7235|
|4 |    TABLE SCAN               |t2          |100      |88  |
|5 |    MATERIAL                 |            |100      |71  |
|6 |     TABLE SCAN              |t1(idx_t1_a)|100      |52  |
|7 | TABLE GET                   |t1          |1        |36  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      conds(nil), nl_params_([VIEW1.max(t1.a)])
  1 - output([VIEW1.max(t1.a)]), filter(nil), 
      access([VIEW1.max(t1.a)])
  2 - output([T_FUN_MAX(t1.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t1.a)])
  3 - output([t1.a]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([1]), filter(nil), 
      access([t2.a]), partitions(p0)
  5 - output([t1.a]), filter(nil)
  6 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  7 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t1"@"SEL$1" ))
      LEADING(@"SEL$3" ("hint.t2"@"SEL$3" "hint.t1"@"SEL$3" ))
      USE_NL(@"SEL$3" ("hint.t1"@"SEL$3" ))
      USE_NL_MATERIALIZATION(@"SEL$3" ("hint.t1"@"SEL$3" ))
      FULL(@"SEL$3" "hint.t2"@"SEL$3")
      INDEX(@"SEL$3" "hint.t1"@"SEL$3" "idx_t1_a")
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 102(end)  ************** 

***************   Case 103   ***************

SQL: select t1.c1 from t1, (select t2.c1 from t2, (select t3.c1 from t3) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

==================================================================
|ID|OPERATOR                             |NAME    |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR                       |        |40       |2335|
|1 | EXCHANGE OUT DISTR                  |:EX10003|40       |2329|
|2 |  MERGE JOIN                         |        |40       |2329|
|3 |   EXCHANGE IN MERGE SORT DISTR      |        |60       |1898|
|4 |    EXCHANGE OUT DISTR (PKEY)        |:EX10002|60       |1892|
|5 |     MATERIAL                        |        |60       |1892|
|6 |      MERGE JOIN                     |        |60       |1870|
|7 |       EXCHANGE IN MERGE SORT DISTR  |        |100      |1226|
|8 |        EXCHANGE OUT DISTR (PKEY)    |:EX10001|100      |1221|
|9 |         MATERIAL                    |        |100      |1221|
|10|          MERGE SEMI JOIN            |        |100      |1203|
|11|           SORT                      |        |500      |966 |
|12|            PX PARTITION ITERATOR    |        |500      |331 |
|13|             TABLE SCAN              |t1      |500      |331 |
|14|           EXCHANGE IN DISTR         |        |100      |95  |
|15|            EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|16|             TABLE SCAN              |t4      |100      |90  |
|17|       SORT                          |        |300      |554 |
|18|        PX PARTITION ITERATOR        |        |300      |192 |
|19|         TABLE SCAN                  |t2      |300      |192 |
|20|   SORT                              |        |200      |372 |
|21|    PX PARTITION ITERATOR            |        |200      |140 |
|22|     TABLE SCAN                      |t3      |200      |140 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t1.c1], [t2.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1]), filter(nil)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  8 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  11 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  14 - output([t4.c1]), filter(nil)
  15 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  16 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  17 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  18 - output([t2.c1]), filter(nil)
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  20 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  21 - output([t3.c1]), filter(nil)
  22 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t2"@"SEL$1" )"opt.t3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t3"@"SEL$1" ) PARTITION NONE)
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 103(end)  ************** 

***************   Case 104   ***************

SQL: select /*+ leading(@SEL$1 t1 t4 t3 t2) index(@SEL$4 t4 idx_t4_c3)*/ t1.c1 from t1, (select t2.c1 from t2, (select t3.c1 from t3) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

=======================================================================
|ID|OPERATOR                             |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------------
|0 |PX COORDINATOR                       |             |40       |2517|
|1 | EXCHANGE OUT DISTR                  |:EX10003     |40       |2509|
|2 |  MERGE JOIN                         |             |40       |2509|
|3 |   EXCHANGE IN MERGE SORT DISTR      |             |60       |2079|
|4 |    EXCHANGE OUT DISTR (PKEY)        |:EX10002     |60       |2070|
|5 |     MATERIAL                        |             |60       |2070|
|6 |      MERGE JOIN                     |             |60       |2037|
|7 |       EXCHANGE IN MERGE SORT DISTR  |             |100      |1393|
|8 |        EXCHANGE OUT DISTR (PKEY)    |:EX10001     |100      |1383|
|9 |         MATERIAL                    |             |100      |1383|
|10|          MERGE JOIN                 |             |100      |1346|
|11|           SORT                      |             |500      |966 |
|12|            PX PARTITION ITERATOR    |             |500      |331 |
|13|             TABLE SCAN              |t1           |500      |331 |
|14|           EXCHANGE IN DISTR         |             |100      |239 |
|15|            EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |234 |
|16|             SUBPLAN SCAN            |VIEW2        |100      |234 |
|17|              MERGE DISTINCT         |             |100      |220 |
|18|               SORT                  |             |100      |198 |
|19|                TABLE SCAN           |t4(idx_t4_c3)|100      |90  |
|20|       SORT                          |             |300      |554 |
|21|        PX PARTITION ITERATOR        |             |300      |192 |
|22|         TABLE SCAN                  |t2           |300      |192 |
|23|   SORT                              |             |200      |372 |
|24|    PX PARTITION ITERATOR            |             |200      |140 |
|25|     TABLE SCAN                      |t3           |200      |140 |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t1.c1], [t2.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1]), filter(nil)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  8 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.VIEW1.c1]), other_conds(nil)
  11 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  14 - output([VIEW2.VIEW1.c1]), filter(nil)
  15 - (#keys=1, [VIEW2.VIEW1.c1]), output([VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  16 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  17 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  18 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  19 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  20 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  21 - output([t2.c1]), filter(nil)
  22 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  23 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  24 - output([t3.c1]), filter(nil)
  25 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$6" ((("opt.t1"@"SEL$6" "VIEW2"@"SEL$6" )"opt.t2"@"SEL$6" )"opt.t3"@"SEL$6" ))
      USE_MERGE(@"SEL$6" ("opt.t3"@"SEL$6" ))
      PQ_DISTRIBUTE(@"SEL$6" ("opt.t3"@"SEL$6" ) PARTITION NONE)
      USE_MERGE(@"SEL$6" ("opt.t2"@"SEL$6" ))
      PQ_DISTRIBUTE(@"SEL$6" ("opt.t2"@"SEL$6" ) PARTITION NONE)
      USE_MERGE(@"SEL$6" ("VIEW2"@"SEL$6" ))
      PQ_DISTRIBUTE(@"SEL$6" ("VIEW2"@"SEL$6" ) NONE PARTITION)
      FULL(@"SEL$6" "opt.t1"@"SEL$6")
      INDEX(@"SEL$5" "opt.t4"@"SEL$5" "idx_t4_c3")
      FULL(@"SEL$6" "opt.t2"@"SEL$6")
      FULL(@"SEL$6" "opt.t3"@"SEL$6")
      END_OUTLINE_DATA
  */

*************** Case 104(end)  ************** 

***************   Case 105   ***************

SQL: select /*+ leading(@SEL1 t1 t4 t3 t2) index(@SEL$4 t4 idx_t4_c3)*/ t1.c1 from t1, (select t2.c1 from t2, (select t3.c1 from t3) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

=======================================================================
|ID|OPERATOR                             |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------------
|0 |PX COORDINATOR                       |             |40       |2424|
|1 | EXCHANGE OUT DISTR                  |:EX10003     |40       |2418|
|2 |  MERGE JOIN                         |             |40       |2418|
|3 |   EXCHANGE IN MERGE SORT DISTR      |             |60       |1987|
|4 |    EXCHANGE OUT DISTR (PKEY)        |:EX10002     |60       |1982|
|5 |     MATERIAL                        |             |60       |1982|
|6 |      MERGE JOIN                     |             |60       |1960|
|7 |       EXCHANGE IN MERGE SORT DISTR  |             |100      |1315|
|8 |        EXCHANGE OUT DISTR (PKEY)    |:EX10001     |100      |1310|
|9 |         MERGE SEMI JOIN             |             |100      |1310|
|10|          SORT                       |             |500      |966 |
|11|           PX PARTITION ITERATOR     |             |500      |331 |
|12|            TABLE SCAN               |t1           |500      |331 |
|13|          SORT                       |             |100      |203 |
|14|           EXCHANGE IN DISTR         |             |100      |95  |
|15|            EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |90  |
|16|             TABLE SCAN              |t4(idx_t4_c3)|100      |90  |
|17|       SORT                          |             |300      |554 |
|18|        PX PARTITION ITERATOR        |             |300      |192 |
|19|         TABLE SCAN                  |t2           |300      |192 |
|20|   SORT                              |             |200      |372 |
|21|    PX PARTITION ITERATOR            |             |200      |140 |
|22|     TABLE SCAN                      |t3           |200      |140 |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t1.c1], [t2.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1]), filter(nil)
  6 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  8 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  10 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter(nil)
  15 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  16 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  17 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  18 - output([t2.c1]), filter(nil)
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  20 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  21 - output([t3.c1]), filter(nil)
  22 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t2"@"SEL$1" )"opt.t3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t3"@"SEL$1" ) PARTITION NONE)
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c3")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 105(end)  ************** 

***************   Case 106   ***************

SQL: select /*+index(@SEL$3 t5@SEL$3 idx_t5_c2) index(@SEL$4 t4 idx_t4_c3)*/ t1.c1 from t1, (select t2.c1 from t2, (select t5.c1 from t5 group by t5.c2) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

====================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |HASH JOIN                         |             |20       |4094|
|1 | PX COORDINATOR                   |             |60       |1965|
|2 |  EXCHANGE OUT DISTR              |:EX10002     |60       |1960|
|3 |   MERGE JOIN                     |             |60       |1960|
|4 |    EXCHANGE IN MERGE SORT DISTR  |             |100      |1315|
|5 |     EXCHANGE OUT DISTR (PKEY)    |:EX10001     |100      |1310|
|6 |      MERGE SEMI JOIN             |             |100      |1310|
|7 |       SORT                       |             |500      |966 |
|8 |        PX PARTITION ITERATOR     |             |500      |331 |
|9 |         TABLE SCAN               |t1           |500      |331 |
|10|       SORT                       |             |100      |203 |
|11|        EXCHANGE IN DISTR         |             |100      |95  |
|12|         EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |90  |
|13|          TABLE SCAN              |t4(idx_t4_c3)|100      |90  |
|14|    SORT                          |             |300      |554 |
|15|     PX PARTITION ITERATOR        |             |300      |192 |
|16|      TABLE SCAN                  |t2           |300      |192 |
|17| PX COORDINATOR                   |             |100      |2008|
|18|  EXCHANGE OUT DISTR              |:EX20001     |100      |2003|
|19|   SUBPLAN SCAN                   |t_a          |100      |2003|
|20|    MERGE GROUP BY                |             |100      |1989|
|21|     EXCHANGE IN MERGE SORT DISTR |             |100      |1923|
|22|      EXCHANGE OUT DISTR (HASH)   |:EX20000     |100      |1909|
|23|       PX PARTITION ITERATOR      |             |100      |1909|
|24|        MERGE GROUP BY            |             |100      |1909|
|25|         TABLE SCAN               |t5(idx_t5_c2)|300      |1842|
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t_a.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t2.c1]), filter(nil)
  2 - output([t1.c1], [t2.c1]), filter(nil), dop=1
  3 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  5 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t4.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  10 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  11 - output([t4.c1]), filter(nil)
  12 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  15 - output([t2.c1]), filter(nil)
  16 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  17 - output([t_a.c1]), filter(nil)
  18 - output([t_a.c1]), filter(nil), dop=1
  19 - output([t_a.c1]), filter(nil), 
      access([t_a.c1])
  20 - output([t5.c1]), filter(nil), 
      group([t5.c2]), agg_func(nil)
  21 - output([t5.c1], [t5.c2]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  22 - (#keys=1, [t5.c2]), output([t5.c1], [t5.c2]), filter(nil), dop=1
  23 - output([t5.c1], [t5.c2]), filter(nil)
  24 - output([t5.c1], [t5.c2]), filter(nil), 
      group([t5.c2]), agg_func(nil)
  25 - output([t5.c2], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t2"@"SEL$1" )"t_a"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("t_a"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      INDEX(@"SEL$1" "opt.t4"@"SEL$1" "idx_t4_c3")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      NO_USE_HASH_AGGREGATION(@"SEL$3")
      NO_USE_HASH_AGGREGATION(@"SEL$3")
      INDEX(@"SEL$3" "opt.t5"@"SEL$3" "idx_t5_c2")
      END_OUTLINE_DATA
  */

*************** Case 106(end)  ************** 

***************   Case 107   ***************

SQL: select c2 from t_idx use index(t_c2); 

==================================================
|ID|OPERATOR  |NAME               |EST. ROWS|COST|
--------------------------------------------------
|0 |TABLE SCAN|t_idx(idx_t_idx_c2)|100      |54  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx.c2]), filter(nil), 
      access([t_idx.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t_idx"@"SEL$1" "idx_t_idx_c2")
      END_OUTLINE_DATA
  */

*************** Case 107(end)  ************** 

***************   Case 108   ***************

SQL: select c120 from t_idx use index (idx_t_idx_c2, idx_t_idx_c3, idx_t_idx_c4, idx_t_idx_c5, idx_t_idx_c6, idx_t_idx_c7, idx_t_idx_c8, idx_t_idx_c9, idx_t_idx_c10, idx_t_idx_c11, idx_t_idx_c12, idx_t_idx_c13, idx_t_idx_c14, idx_t_idx_c15, idx_t_idx_c16, idx_t_idx_c17, idx_t_idx_c18, idx_t_idx_c19, idx_t_idx_c20, idx_t_idx_c21, idx_t_idx_c22, idx_t_idx_c23, idx_t_idx_c24, idx_t_idx_c25, idx_t_idx_c26, idx_t_idx_c27, idx_t_idx_c28, idx_t_idx_c29, idx_t_idx_c30, idx_t_idx_c31, idx_t_idx_c32, idx_t_idx_c33, idx_t_idx_c34, idx_t_idx_c35, idx_t_idx_c36, idx_t_idx_c37, idx_t_idx_c38, idx_t_idx_c39, idx_t_idx_c40, idx_t_idx_c41, idx_t_idx_c42, idx_t_idx_c43, idx_t_idx_c44, idx_t_idx_c45, idx_t_idx_c46, idx_t_idx_c47, idx_t_idx_c48, idx_t_idx_c49, idx_t_idx_c50, idx_t_idx_c51, idx_t_idx_c52, idx_t_idx_c53, idx_t_idx_c54, idx_t_idx_c55, idx_t_idx_c56, idx_t_idx_c57, idx_t_idx_c58, idx_t_idx_c59, idx_t_idx_c60, idx_t_idx_c61, idx_t_idx_c62, idx_t_idx_c63, idx_t_idx_c64, idx_t_idx_c65, idx_t_idx_c66, idx_t_idx_c67, idx_t_idx_c68, idx_t_idx_c69, idx_t_idx_c70, idx_t_idx_c71, idx_t_idx_c72, idx_t_idx_c73, idx_t_idx_c74, idx_t_idx_c75, idx_t_idx_c76, idx_t_idx_c77, idx_t_idx_c78, idx_t_idx_c79, idx_t_idx_c80, idx_t_idx_c81, idx_t_idx_c82, idx_t_idx_c83, idx_t_idx_c84, idx_t_idx_c85, idx_t_idx_c86, idx_t_idx_c87, idx_t_idx_c88, idx_t_idx_c89, idx_t_idx_c90, idx_t_idx_c91, idx_t_idx_c92, idx_t_idx_c93, idx_t_idx_c94, idx_t_idx_c95, idx_t_idx_c96, idx_t_idx_c97, idx_t_idx_c98, idx_t_idx_c99, idx_t_idx_c100, idx_t_idx_c101, idx_t_idx_c102, idx_t_idx_c103, idx_t_idx_c104, idx_t_idx_c105, idx_t_idx_c106, idx_t_idx_c107, idx_t_idx_c108, idx_t_idx_c109, idx_t_idx_c110, idx_t_idx_c111, idx_t_idx_c112, idx_t_idx_c113, idx_t_idx_c114, idx_t_idx_c115, idx_t_idx_c116, idx_t_idx_c117, idx_t_idx_c118, idx_t_idx_c119, idx_t_idx_c120, idx_t_idx_c121, idx_t_idx_c122, idx_t_idx_c123, idx_t_idx_c124, idx_t_idx_c125, idx_t_idx_c126, idx_t_idx_c127, idx_t_idx_c128, idx_t_idx_c129) where c120 = 1; 

====================================================
|ID|OPERATOR  |NAME                 |EST. ROWS|COST|
----------------------------------------------------
|0 |TABLE SCAN|t_idx(idx_t_idx_c120)|100      |54  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx.c120]), filter(nil), 
      access([t_idx.c120]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t_idx"@"SEL$1" "idx_t_idx_c120")
      END_OUTLINE_DATA
  */

*************** Case 108(end)  ************** 

***************   Case 109   ***************

SQL: select c120 from t_idx use index (idx_t_idx_c2, idx_t_idx_c2, idx_t_idx_c3, idx_t_idx_c4, idx_t_idx_c5, idx_t_idx_c6, idx_t_idx_c7, idx_t_idx_c8, idx_t_idx_c9, idx_t_idx_c10, idx_t_idx_c11, idx_t_idx_c12, idx_t_idx_c13, idx_t_idx_c14, idx_t_idx_c15, idx_t_idx_c16, idx_t_idx_c17, idx_t_idx_c18, idx_t_idx_c19, idx_t_idx_c20, idx_t_idx_c21, idx_t_idx_c22, idx_t_idx_c23, idx_t_idx_c24, idx_t_idx_c25, idx_t_idx_c26, idx_t_idx_c27, idx_t_idx_c28, idx_t_idx_c29, idx_t_idx_c30, idx_t_idx_c31, idx_t_idx_c32, idx_t_idx_c33, idx_t_idx_c34, idx_t_idx_c35, idx_t_idx_c36, idx_t_idx_c37, idx_t_idx_c38, idx_t_idx_c39, idx_t_idx_c40, idx_t_idx_c41, idx_t_idx_c42, idx_t_idx_c43, idx_t_idx_c44, idx_t_idx_c45, idx_t_idx_c46, idx_t_idx_c47, idx_t_idx_c48, idx_t_idx_c49, idx_t_idx_c50, idx_t_idx_c51, idx_t_idx_c52, idx_t_idx_c53, idx_t_idx_c54, idx_t_idx_c55, idx_t_idx_c56, idx_t_idx_c57, idx_t_idx_c58, idx_t_idx_c59, idx_t_idx_c60, idx_t_idx_c61, idx_t_idx_c62, idx_t_idx_c63, idx_t_idx_c64, idx_t_idx_c65, idx_t_idx_c66, idx_t_idx_c67, idx_t_idx_c68, idx_t_idx_c69, idx_t_idx_c70, idx_t_idx_c71, idx_t_idx_c72, idx_t_idx_c73, idx_t_idx_c74, idx_t_idx_c75, idx_t_idx_c76, idx_t_idx_c77, idx_t_idx_c78, idx_t_idx_c79, idx_t_idx_c80, idx_t_idx_c81, idx_t_idx_c82, idx_t_idx_c83, idx_t_idx_c84, idx_t_idx_c85, idx_t_idx_c86, idx_t_idx_c87, idx_t_idx_c88, idx_t_idx_c89, idx_t_idx_c90, idx_t_idx_c91, idx_t_idx_c92, idx_t_idx_c93, idx_t_idx_c94, idx_t_idx_c95, idx_t_idx_c96, idx_t_idx_c97, idx_t_idx_c98, idx_t_idx_c99, idx_t_idx_c100, idx_t_idx_c101, idx_t_idx_c102, idx_t_idx_c103, idx_t_idx_c104, idx_t_idx_c105, idx_t_idx_c106, idx_t_idx_c107, idx_t_idx_c108, idx_t_idx_c109, idx_t_idx_c110, idx_t_idx_c111, idx_t_idx_c112, idx_t_idx_c113, idx_t_idx_c114, idx_t_idx_c115, idx_t_idx_c116, idx_t_idx_c117, idx_t_idx_c118, idx_t_idx_c119, idx_t_idx_c120, idx_t_idx_c121, idx_t_idx_c122, idx_t_idx_c123, idx_t_idx_c124, idx_t_idx_c125, idx_t_idx_c126, idx_t_idx_c127, idx_t_idx_c128, idx_t_idx_c129) where c120 = 1; 

====================================================
|ID|OPERATOR  |NAME                 |EST. ROWS|COST|
----------------------------------------------------
|0 |TABLE SCAN|t_idx(idx_t_idx_c120)|100      |54  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx.c120]), filter(nil), 
      access([t_idx.c120]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.t_idx"@"SEL$1" "idx_t_idx_c120")
      END_OUTLINE_DATA
  */

*************** Case 109(end)  ************** 

***************   Case 110   ***************

SQL: select /*+use_plan_cache(none)*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      USE_PLAN_CACHE("NONE")
      END_OUTLINE_DATA
  */

*************** Case 110(end)  ************** 

***************   Case 111   ***************

SQL: select /*+use_plan_cache(meaningless)*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 111(end)  ************** 

***************   Case 112   ***************

SQL: select /*+ index(t1 primary) */ * from hint.t1 order by a desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t1(Reverse)|100      |90  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 112(end)  ************** 

***************   Case 113   ***************

SQL: select min(a) from z1 za where za.a in (select a from z1); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY|     |1        |37  |
|1 | SUBPLAN SCAN  |VIEW2|1        |37  |
|2 |  TABLE SCAN   |za   |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW2.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.a)])
  1 - output([VIEW2.a]), filter(nil), 
      access([VIEW2.a])
  2 - output([za.a]), filter(nil), 
      access([za.a]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$3" "opt.za"@"SEL$3")
      END_OUTLINE_DATA
  */

*************** Case 113(end)  ************** 

***************   Case 114   ***************

SQL: select /*+ INDEX(@SEL$3 opt.z1@SEL$2 z1_b)*/ min(a) from z1 za where za.a in (select a from z1); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY|     |1        |37  |
|1 | SUBPLAN SCAN  |VIEW2|1        |37  |
|2 |  TABLE SCAN   |za   |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW2.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.a)])
  1 - output([VIEW2.a]), filter(nil), 
      access([VIEW2.a])
  2 - output([za.a]), filter(nil), 
      access([za.a]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$3" "opt.za"@"SEL$3")
      END_OUTLINE_DATA
  */

*************** Case 114(end)  ************** 

***************   Case 115   ***************

SQL: select /*+index(z1 z1_b)*/ * from z1 ignore key(a); 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|z1(z1_b)|100      |621 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.z1"@"SEL$1" "z1_b")
      END_OUTLINE_DATA
  */

*************** Case 115(end)  ************** 

***************   Case 116   ***************

SQL: select /*+index(z1 z1_b)*/ * from z1 ignore key(z1_b); 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|z1(z1_b)|100      |621 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt.z1"@"SEL$1" "z1_b")
      END_OUTLINE_DATA
  */

*************** Case 116(end)  ************** 

***************   Case 117   ***************

SQL: select /*+use_hash(t1,t2) no_use_hash_aggregation*/* from t1 left join t2 using(c2) group by t1.c2 order by t1.c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |MERGE GROUP BY            |             |101      |6491|
|1 | SORT                     |             |1421     |6176|
|2 |  HASH OUTER JOIN         |             |1421     |2259|
|3 |   PX COORDINATOR         |             |500      |389 |
|4 |    EXCHANGE OUT DISTR    |:EX10000     |500      |342 |
|5 |     PX PARTITION ITERATOR|             |500      |342 |
|6 |      TABLE SCAN          |t1(idx_t1_c2)|500      |342 |
|7 |   PX COORDINATOR         |             |300      |290 |
|8 |    EXCHANGE OUT DISTR    |:EX20000     |300      |205 |
|9 |     PX PARTITION ITERATOR|             |300      |205 |
|10|      TABLE SCAN          |t2           |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  1 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      NO_USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 117(end)  ************** 

***************   Case 118   ***************

SQL: select /*+use_hash(t1,t2) no_use_hash_aggregation*/* from t1 left join t2 using(c2) group by t1.c2 order by t2.c3 limit 3; 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |LIMIT                       |             |3        |6655|
|1 | TOP-N SORT                 |             |3        |6655|
|2 |  MERGE GROUP BY            |             |101      |6491|
|3 |   SORT                     |             |1421     |6176|
|4 |    HASH OUTER JOIN         |             |1421     |2259|
|5 |     PX COORDINATOR         |             |500      |389 |
|6 |      EXCHANGE OUT DISTR    |:EX10000     |500      |342 |
|7 |       PX PARTITION ITERATOR|             |500      |342 |
|8 |        TABLE SCAN          |t1(idx_t1_c2)|500      |342 |
|9 |     PX COORDINATOR         |             |300      |290 |
|10|      EXCHANGE OUT DISTR    |:EX20000     |300      |205 |
|11|       PX PARTITION ITERATOR|             |300      |205 |
|12|        TABLE SCAN          |t2           |300      |205 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), limit(3), offset(nil)
  1 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), sort_keys([t2.c3, ASC]), topn(3)
  2 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  3 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC])
  4 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      NO_USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 118(end)  ************** 

***************   Case 119   ***************

SQL: select /*+ use_bnl(hint.t2, opt.t1)*/ * from hint.t2, opt.t1 where opt.t1.c2 = hint.t2.a; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |MERGE JOIN                 |             |490      |1585|
|1 | TABLE SCAN                |t2           |100      |90  |
|2 | PX COORDINATOR MERGE SORT |             |500      |1122|
|3 |  EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|4 |   SORT                    |             |500      |1074|
|5 |    PX PARTITION ITERATOR  |             |500      |342 |
|6 |     TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.a]), other_conds(nil)
  1 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint.t2"@"SEL$1")
      INDEX(@"SEL$1" "opt.t1"@"SEL$1" "idx_t1_c2")
      END_OUTLINE_DATA
  */

*************** Case 119(end)  ************** 

***************   Case 120   ***************

SQL: select /*+ leading (b a) */ distinct * from hint_t1 a, hint_v1 b; 

========================================================
|ID|OPERATOR                   |NAME   |EST. ROWS|COST |
--------------------------------------------------------
|0 |HASH DISTINCT              |       |10000    |18304|
|1 | NESTED-LOOP JOIN CARTESIAN|       |10000    |7284 |
|2 |  TABLE SCAN               |hint_t2|100      |95   |
|3 |  MATERIAL                 |       |100      |113  |
|4 |   TABLE SCAN              |a      |100      |95   |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [hint_t2.c2]), filter(nil), 
      distinct([a.c1], [hint_t2.c2])
  1 - output([a.c1], [hint_t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([hint_t2.c2]), filter(nil), 
      access([hint_t2.c2]), partitions(p0)
  3 - output([a.c1]), filter(nil)
  4 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.hint_t2"@"SEL$1" "opt.a"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.a"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.a"@"SEL$1" ))
      FULL(@"SEL$1" "opt.hint_t2"@"SEL$1")
      FULL(@"SEL$1" "opt.a"@"SEL$1")
      END_OUTLINE_DATA
  */

*************** Case 120(end)  ************** 

***************   Case 121   ***************

SQL: select /*+read_consistency(weak)*/ * from (select distinct * from hint_t1) as a limit 5; 

==========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST|
------------------------------------------
|0 |LIMIT         |       |5        |43  |
|1 | HASH DISTINCT|       |5        |43  |
|2 |  TABLE SCAN  |hint_t1|5        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([hint_t1.c1]), filter(nil), limit(5), offset(nil)
  1 - output([hint_t1.c1]), filter(nil), 
      distinct([hint_t1.c1])
  2 - output([hint_t1.c1]), filter(nil), 
      access([hint_t1.c1]), partitions(p0), 
      hint(read_consistency:2)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.hint_t1"@"SEL$2")
      READ_CONSISTENCY("WEAK")
      END_OUTLINE_DATA
  */

*************** Case 121(end)  ************** 

