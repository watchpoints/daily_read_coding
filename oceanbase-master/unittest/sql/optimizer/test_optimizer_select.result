***************   Case 1   ***************

SQL: select * from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 1(end)  ************** 

***************   Case 2   ***************

SQL: select c1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 2(end)  ************** 

***************   Case 3   ***************

SQL: select c2 from t1 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500      |1122|
|1 | EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|2 |  SORT                    |             |500      |1074|
|3 |   PX PARTITION ITERATOR  |             |500      |342 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 3(end)  ************** 

***************   Case 4   ***************

SQL: select c1, c2 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 4(end)  ************** 

***************   Case 5   ***************

SQL: select c1 + c2 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + t1.c2]), filter(nil)
  1 - output([t1.c1 + t1.c2]), filter(nil), dop=1
  2 - output([t1.c1 + t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1 + t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 5(end)  ************** 

***************   Case 6   ***************

SQL: select c1 from t1 limit 100; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |100      |107 |
|1 | PX COORDINATOR         |        |100      |93  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|100      |88  |
|3 |   PX PARTITION ITERATOR|        |100      |88  |
|4 |    TABLE SCAN          |t1      |100      |88  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 6(end)  ************** 

***************   Case 7   ***************

SQL: select * from t1 limit 100; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |100      |113 |
|1 | PX COORDINATOR         |        |100      |100 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|100      |90  |
|3 |   PX PARTITION ITERATOR|        |100      |90  |
|4 |    TABLE SCAN          |t1      |100      |90  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 7(end)  ************** 

***************   Case 8   ***************

SQL: select * from t1 order by c1,c2 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |241 |
|1 | PX COORDINATOR MERGE SORT |        |100      |227 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |217 |
|3 |   SORT                    |        |100      |217 |
|4 |    PX PARTITION ITERATOR  |        |100      |90  |
|5 |     TABLE SCAN            |t1      |100      |90  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 8(end)  ************** 

***************   Case 9   ***************

SQL: select c1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |214 |
|1 | PX COORDINATOR MERGE SORT |        |100      |200 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |196 |
|3 |   SORT                    |        |100      |196 |
|4 |    PX PARTITION ITERATOR  |        |100      |88  |
|5 |     TABLE SCAN            |t1      |100      |88  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 9(end)  ************** 

***************   Case 10   ***************

SQL: select c1 from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |241 |
|1 | PX COORDINATOR MERGE SORT |             |100      |227 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |217 |
|3 |   SORT                    |             |100      |217 |
|4 |    PX PARTITION ITERATOR  |             |100      |90  |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |90  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 10(end)  ************** 

***************   Case 11   ***************

SQL: select c1 from t1 where c1 > 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |257 |
|1 | PX COORDINATOR MERGE SORT |             |100      |243 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |234 |
|3 |   SORT                    |             |100      |234 |
|4 |    PX PARTITION ITERATOR  |             |100      |107 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |107 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 11(end)  ************** 

***************   Case 12   ***************

SQL: select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |10       |437 |
|1 | PX COORDINATOR MERGE SORT |             |10       |436 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |10       |435 |
|3 |   SORT                    |             |10       |435 |
|4 |    PX PARTITION ITERATOR  |             |10       |426 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|10       |426 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(NULL,MAX ; 0,MIN), 
      range_cond([t1.c2 < ?])

*************** Case 12(end)  ************** 

***************   Case 13   ***************

SQL: select c1 from t1 group by c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 13(end)  ************** 

***************   Case 14   ***************

SQL: select c2, sum(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |635 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |626 |
|2 |  MERGE GROUP BY               |             |100      |626 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |489 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |479 |
|5 |     PX PARTITION ITERATOR     |             |100      |479 |
|6 |      MERGE GROUP BY           |             |100      |479 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  1 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 14(end)  ************** 

***************   Case 15   ***************

SQL: select c2, avg(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |688 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |679 |
|2 |  MERGE GROUP BY               |             |100      |679 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |515 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |506 |
|5 |     PX PARTITION ITERATOR     |             |100      |506 |
|6 |      MERGE GROUP BY           |             |100      |506 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 15(end)  ************** 

***************   Case 16   ***************

SQL: select c1, c1 + c2 from t1 where c1 > 0 limit 100; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |100      |113 |
|1 | PX COORDINATOR         |        |100      |100 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|100      |90  |
|3 |   PX PARTITION ITERATOR|        |100      |90  |
|4 |    TABLE SCAN          |t1      |100      |90  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 16(end)  ************** 

***************   Case 17   ***************

SQL: select c1 from t1 where c1 > 0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 17(end)  ************** 

***************   Case 18   ***************

SQL: select c2 from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |610 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |596 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |587 |
|3 |   LIMIT                         |             |100      |587 |
|4 |    MERGE GROUP BY               |             |100      |573 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |462 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |453 |
|7 |       PX PARTITION ITERATOR     |             |100      |453 |
|8 |        MERGE GROUP BY           |             |100      |453 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c2]), filter(nil), dop=1
  3 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  7 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 18(end)  ************** 

***************   Case 19   ***************

SQL: select sum(c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |663 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |649 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |640 |
|3 |   LIMIT                         |             |100      |640 |
|4 |    MERGE GROUP BY               |             |100      |626 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |489 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |479 |
|7 |       PX PARTITION ITERATOR     |             |100      |479 |
|8 |        MERGE GROUP BY           |             |100      |479 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 19(end)  ************** 

***************   Case 20   ***************

SQL: select sum(c1) from t1 where c1 > 0 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |747 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |733 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |724 |
|3 |   LIMIT                         |             |100      |724 |
|4 |    MERGE GROUP BY               |             |100      |710 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |572 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |563 |
|7 |       PX PARTITION ITERATOR     |             |100      |563 |
|8 |        MERGE GROUP BY           |             |100      |563 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500      |426 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 20(end)  ************** 

***************   Case 21   ***************

SQL: select count(c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |663 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |649 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |640 |
|3 |   LIMIT                         |             |100      |640 |
|4 |    MERGE GROUP BY               |             |100      |626 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |489 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |479 |
|7 |       PX PARTITION ITERATOR     |             |100      |479 |
|8 |        MERGE GROUP BY           |             |100      |479 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  5 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 21(end)  ************** 

***************   Case 22   ***************

SQL: select count(distinct c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |663 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |649 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |640 |
|3 |   LIMIT                         |             |100      |640 |
|4 |    MERGE GROUP BY               |             |100      |626 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |489 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |479 |
|7 |       PX PARTITION ITERATOR     |             |100      |479 |
|8 |        MERGE GROUP BY           |             |100      |479 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  5 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 22(end)  ************** 

***************   Case 23   ***************

SQL: select count(*) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |663 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |649 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |640 |
|3 |   LIMIT                         |             |100      |640 |
|4 |    MERGE GROUP BY               |             |100      |626 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |489 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |479 |
|7 |       PX PARTITION ITERATOR     |             |100      |479 |
|8 |        MERGE GROUP BY           |             |100      |479 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(*)])
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 23(end)  ************** 

***************   Case 24   ***************

SQL: select sum(c1), count(*) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |716 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |702 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |693 |
|3 |   LIMIT                         |             |100      |693 |
|4 |    MERGE GROUP BY               |             |100      |679 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |515 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |506 |
|7 |       PX PARTITION ITERATOR     |             |100      |506 |
|8 |        MERGE GROUP BY           |             |100      |506 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), dop=1
  7 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 24(end)  ************** 

***************   Case 25   ***************

SQL: select c2, count(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |635 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |626 |
|2 |  MERGE GROUP BY               |             |100      |626 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |489 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |479 |
|5 |     PX PARTITION ITERATOR     |             |100      |479 |
|6 |      MERGE GROUP BY           |             |100      |479 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 25(end)  ************** 

***************   Case 26   ***************

SQL: select t1.c1 from t1, t2 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |381 |
|1 | NESTED-LOOP JOIN CARTESIAN|        |100      |367 |
|2 |  PX COORDINATOR           |        |1        |36  |
|3 |   EXCHANGE OUT DISTR      |:EX10000|1        |36  |
|4 |    PX PARTITION ITERATOR  |        |1        |36  |
|5 |     TABLE SCAN            |t1      |1        |36  |
|6 |  MATERIAL                 |        |300      |261 |
|7 |   PX COORDINATOR          |        |300      |206 |
|8 |    EXCHANGE OUT DISTR     |:EX20000|300      |192 |
|9 |     PX PARTITION ITERATOR |        |300      |192 |
|10|      TABLE SCAN           |t2      |300      |192 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), dop=1
  9 - output([1]), filter(nil), 
      force partition granule, asc.
  10 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 26(end)  ************** 

***************   Case 27   ***************

SQL: select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |LIMIT                            |        |100      |841 |
|1 | PX COORDINATOR                  |        |100      |827 |
|2 |  EXCHANGE OUT DISTR             |:EX10001|100      |817 |
|3 |   LIMIT                         |        |100      |817 |
|4 |    MERGE JOIN                   |        |100      |804 |
|5 |     SORT                        |        |289      |537 |
|6 |      PX PARTITION ITERATOR      |        |289      |190 |
|7 |       TABLE SCAN                |t1      |289      |190 |
|8 |     EXCHANGE IN MERGE SORT DISTR|        |174      |144 |
|9 |      EXCHANGE OUT DISTR (PKEY)  |:EX10000|174      |135 |
|10|       PX PARTITION ITERATOR     |        |174      |135 |
|11|        TABLE SCAN               |t2      |174      |135 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  9 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  10 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 27(end)  ************** 

***************   Case 28   ***************

SQL: select t1.c1 from t1, t2, t3 where t1.c1=t2.c1       and t1.c2>t2.c2       and t2.c3=t3.c3       and t3.c1>10; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH JOIN                       |        |184      |2290|
|1 | PX COORDINATOR                 |        |100      |1497|
|2 |  EXCHANGE OUT DISTR            |:EX10001|100      |1459|
|3 |   MERGE JOIN                   |        |100      |1459|
|4 |    EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|5 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|6 |      PX PARTITION ITERATOR     |        |500      |342 |
|7 |       TABLE SCAN               |t1      |500      |342 |
|8 |    SORT                        |        |300      |859 |
|9 |     PX PARTITION ITERATOR      |        |300      |205 |
|10|      TABLE SCAN                |t2      |300      |205 |
|11| PX COORDINATOR                 |        |200      |191 |
|12|  EXCHANGE OUT DISTR            |:EX20000|200      |144 |
|13|   PX PARTITION ITERATOR        |        |200      |144 |
|14|    TABLE SCAN                  |t3      |200      |144 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t2.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  5 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t3.c3]), filter(nil)
  12 - output([t3.c3]), filter(nil), dop=1
  13 - output([t3.c3]), filter(nil), 
      force partition granule, asc.
  14 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(10 ; MAX), 
      range_cond([t3.c1 > ?])

*************** Case 28(end)  ************** 

***************   Case 29   ***************

SQL: select opt.t3.c2 from opt.t1,t2,t3 where t1.c1+t2.c1=t3.c1; 

==============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST  |
--------------------------------------------------------------
|0 |PX COORDINATOR                 |        |150000   |304515|
|1 | EXCHANGE OUT DISTR            |:EX10003|150000   |276117|
|2 |  HASH JOIN                    |        |150000   |276117|
|3 |   PX PARTITION ITERATOR       |        |200      |144   |
|4 |    TABLE SCAN                 |t3      |200      |144   |
|5 |   EXCHANGE IN DISTR           |        |150000   |121052|
|6 |    EXCHANGE OUT DISTR (PKEY)  |:EX10002|150000   |106853|
|7 |     NESTED-LOOP JOIN CARTESIAN|        |150000   |106853|
|8 |      MATERIAL                 |        |500      |446   |
|9 |       EXCHANGE IN DISTR       |        |500      |354   |
|10|        EXCHANGE OUT DISTR     |:EX10000|500      |331   |
|11|         PX PARTITION ITERATOR |        |500      |331   |
|12|          TABLE SCAN           |t1      |500      |331   |
|13|      MATERIAL                 |        |300      |261   |
|14|       EXCHANGE IN DISTR       |        |300      |206   |
|15|        EXCHANGE OUT DISTR     |:EX10001|300      |192   |
|16|         PX PARTITION ITERATOR |        |300      |192   |
|17|          TABLE SCAN           |t2      |300      |192   |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c2]), filter(nil)
  1 - output([t3.c2]), filter(nil), dop=1
  2 - output([t3.c2]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1 + t2.c1]), filter(nil), is_single, dop=1
  7 - output([t1.c1 + t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  13 - output([t2.c1]), filter(nil)
  14 - output([t2.c1]), filter(nil)
  15 - output([t2.c1]), filter(nil), dop=1
  16 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  17 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 29(end)  ************** 

***************   Case 30   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH JOIN                       |        |6        |2262|
|1 | PX COORDINATOR                 |        |200      |1202|
|2 |  EXCHANGE OUT DISTR            |:EX10001|200      |1135|
|3 |   MERGE JOIN                   |        |200      |1135|
|4 |    EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|5 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|6 |      PX PARTITION ITERATOR     |        |500      |342 |
|7 |       TABLE SCAN               |t1      |500      |342 |
|8 |    SORT                        |        |200      |532 |
|9 |     PX PARTITION ITERATOR      |        |200      |144 |
|10|      TABLE SCAN                |t3      |200      |144 |
|11| PX COORDINATOR                 |        |300      |290 |
|12|  EXCHANGE OUT DISTR            |:EX20000|300      |205 |
|13|   PX PARTITION ITERATOR        |        |300      |205 |
|14|    TABLE SCAN                  |t2      |300      |205 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  5 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t3.c3], [t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  9 - output([t3.c1], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  11 - output([t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c2], [t2.c3]), filter(nil), dop=1
  13 - output([t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  14 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 30(end)  ************** 

***************   Case 31   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t2.c1 and t1.c1+t2.c1=t3.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |300      |2204|
|1 | EXCHANGE OUT DISTR               |:EX10002|300      |2161|
|2 |  HASH JOIN                       |        |300      |2161|
|3 |   PX PARTITION ITERATOR          |        |200      |140 |
|4 |    TABLE SCAN                    |t3      |200      |140 |
|5 |   EXCHANGE IN DISTR              |        |300      |1488|
|6 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1460|
|7 |     MERGE JOIN                   |        |300      |1460|
|8 |      SORT                        |        |500      |966 |
|9 |       PX PARTITION ITERATOR      |        |500      |331 |
|10|        TABLE SCAN                |t1      |500      |331 |
|11|      EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|12|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|13|        PX PARTITION ITERATOR     |        |300      |192 |
|14|         TABLE SCAN               |t2      |300      |192 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c1 + t2.c1]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c1 + t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  12 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  13 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  14 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 31(end)  ************** 

***************   Case 32   ***************

SQL: select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

======================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST  |
----------------------------------------------------------------------
|0 |NESTED-LOOP JOIN                  |             |577      |109492|
|1 | MERGE JOIN                       |             |961      |3564  |
|2 |  PX COORDINATOR MERGE SORT       |             |200      |1776  |
|3 |   EXCHANGE OUT DISTR             |:EX10001     |200      |1748  |
|4 |    SORT                          |             |200      |1748  |
|5 |     MERGE JOIN                   |             |200      |1438  |
|6 |      SORT                        |             |500      |1074  |
|7 |       PX PARTITION ITERATOR      |             |500      |342   |
|8 |        TABLE SCAN                |t1           |500      |342   |
|9 |      EXCHANGE IN MERGE SORT DISTR|             |200      |149   |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000     |200      |140   |
|11|        PX PARTITION ITERATOR     |             |200      |140   |
|12|         TABLE SCAN               |t3           |200      |140   |
|13|  PX COORDINATOR MERGE SORT       |             |500      |1122  |
|14|   EXCHANGE OUT DISTR             |:EX20000     |500      |1074  |
|15|    SORT                          |             |500      |1074  |
|16|     PX PARTITION ITERATOR        |             |500      |342   |
|17|      TABLE SCAN                  |tt(idx_t1_c2)|500      |342   |
|18| MATERIAL                         |             |300      |261   |
|19|  PX COORDINATOR                  |             |300      |206   |
|20|   EXCHANGE OUT DISTR             |:EX30000     |300      |192   |
|21|    PX PARTITION ITERATOR         |             |300      |192   |
|22|     TABLE SCAN                   |t2           |300      |192   |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  11 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([tt.c1], [tt.c2]), filter(nil), sort_keys([tt.c2, ASC])
  14 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  15 - output([tt.c1], [tt.c2]), filter(nil), sort_keys([tt.c2, ASC]), local merge sort
  16 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c2], [tt.c1]), range(MIN,MIN ; MAX,MAX)always true
  18 - output([t2.c1]), filter(nil)
  19 - output([t2.c1]), filter(nil)
  20 - output([t2.c1]), filter(nil), dop=1
  21 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  22 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 32(end)  ************** 

***************   Case 33   ***************

SQL: select t1.c1 from t1, (select * from t2) as t where t1.c1=t.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1488|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1460|
|2 |  MERGE JOIN                   |        |300      |1460|
|3 |   SORT                        |        |500      |966 |
|4 |    PX PARTITION ITERATOR      |        |500      |331 |
|5 |     TABLE SCAN                |t1      |500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 33(end)  ************** 

***************   Case 34   ***************

SQL: select t1.c1 from t1, (select * from t2 where c2>1 order by c1 limit 10) as t where t1.c1=t.c1; 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |10       |412 |
|1 | EXCHANGE OUT DISTR                |:EX10002|10       |411 |
|2 |  NESTED-LOOP JOIN                 |        |10       |411 |
|3 |   EXCHANGE IN DISTR               |        |10       |44  |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10001|10       |44  |
|5 |     SUBPLAN SCAN                  |t       |10       |44  |
|6 |      LIMIT                        |        |10       |42  |
|7 |       EXCHANGE IN MERGE SORT DISTR|        |10       |41  |
|8 |        EXCHANGE OUT DISTR         |:EX10000|10       |40  |
|9 |         PX PARTITION ITERATOR     |        |10       |40  |
|10|          TABLE SCAN               |t2      |10       |40  |
|11|   PX PARTITION ITERATOR           |        |1        |36  |
|12|    TABLE GET                      |t1      |1        |36  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t.c1]), batch_join=false
  3 - output([t.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t.c1]), output([t.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  5 - output([t.c1]), filter(nil), 
      access([t.c1])
  6 - output([t2.c1]), filter(nil), limit(10), offset(nil)
  7 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      limit(10), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 34(end)  ************** 

***************   Case 35   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 order by c2 + c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |1122|
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |1074|
|2 |  SORT                    |        |500      |1074|
|3 |   PX PARTITION ITERATOR  |        |500      |342 |
|4 |    TABLE SCAN            |t1      |500      |342 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  1 - output([t1.c1], [t1.c1 + t1.c2], [t1.c2 + t1.c1]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c1 + t1.c2], [t1.c2 + t1.c1]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t1.c2 + t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2], [t1.c2 + t1.c1]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 35(end)  ************** 

***************   Case 36   ***************

SQL: select * from t1,t2 where t1.c1 = t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 36(end)  ************** 

***************   Case 37   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1600|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1501|
|2 |  MERGE JOIN                   |        |300      |1501|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |354 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |331 |
|5 |     PX PARTITION ITERATOR     |        |500      |331 |
|6 |      TABLE SCAN               |t1      |500      |331 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 37(end)  ************** 

***************   Case 38   ***************

SQL: select c2 from t1 order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |1122|
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |1074|
|2 |  SORT                    |        |500      |1074|
|3 |   PX PARTITION ITERATOR  |        |500      |342 |
|4 |    TABLE SCAN            |t1      |500      |342 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c2], [t1.c1]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 38(end)  ************** 

***************   Case 39   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1 order by t1.c2; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |        |300      |2420|
|1 | EXCHANGE OUT DISTR             |:EX10001|300      |2306|
|2 |  SORT                          |        |300      |2306|
|3 |   MERGE JOIN                   |        |300      |1536|
|4 |    EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|5 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|6 |      PX PARTITION ITERATOR     |        |500      |342 |
|7 |       TABLE SCAN               |t1      |500      |342 |
|8 |    SORT                        |        |300      |859 |
|9 |     PX PARTITION ITERATOR      |        |300      |205 |
|10|      TABLE SCAN                |t2      |300      |205 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  5 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 39(end)  ************** 

***************   Case 40   ***************

SQL: select /*+ INDEX(t1 INVALID_INDEX) */ c1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 40(end)  ************** 

***************   Case 41   ***************

SQL: select c1 from t1 as t order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |990 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |966 |
|2 |  SORT                    |        |500      |966 |
|3 |   PX PARTITION ITERATOR  |        |500      |331 |
|4 |    TABLE SCAN            |t       |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil), sort_keys([t.c1, ASC])
  1 - output([t.c1]), filter(nil), dop=1
  2 - output([t.c1]), filter(nil), sort_keys([t.c1, ASC]), local merge sort
  3 - output([t.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 41(end)  ************** 

***************   Case 42   ***************

SQL: select c1,c2 from t19 where c1 = 1 order by c1, c2 desc; 

===========================================
|ID|OPERATOR  |NAME        |EST. ROWS|COST|
-------------------------------------------
|0 |TABLE SCAN|t19(Reverse)|100      |95  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2]), filter(nil), 
      access([t19.c1], [t19.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 42(end)  ************** 

***************   Case 43   ***************

SQL: select c1,c2 from t19 where c1 = 1 and c2 = 1 order by c2, c3 desc; 

===========================================
|ID|OPERATOR  |NAME        |EST. ROWS|COST|
-------------------------------------------
|0 |TABLE SCAN|t19(Reverse)|100      |95  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2]), filter(nil), 
      access([t19.c1], [t19.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,1,MIN,MIN ; 1,1,MAX,MAX), 
      range_cond([t19.c1 = ?], [t19.c2 = ?])

*************** Case 43(end)  ************** 

***************   Case 44   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 limit 1, 10; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |10       |41  |
|1 | PX COORDINATOR         |        |11       |39  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|11       |38  |
|3 |   PX PARTITION ITERATOR|        |11       |38  |
|4 |    TABLE SCAN          |t1      |11       |38  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(10), offset(?)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(10 + ?), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 44(end)  ************** 

***************   Case 45   ***************

SQL: select * from t1 where c1 in (3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |58  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |57  |
|2 |  PX PARTITION ITERATOR|        |2        |57  |
|3 |   TABLE GET           |t1      |2        |57  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[3-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?)])

*************** Case 45(end)  ************** 

***************   Case 46   ***************

SQL: select * from t1 where c1 in (3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 46(end)  ************** 

***************   Case 47   ***************

SQL: select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |23       |1284|
|1 | EXCHANGE OUT DISTR            |:EX10001|23       |1271|
|2 |  MERGE JOIN                   |        |23       |1271|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|8 |     PX PARTITION ITERATOR     |        |200      |149 |
|9 |      TABLE SCAN               |t3      |200      |149 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  7 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 47(end)  ************** 

***************   Case 48   ***************

SQL: select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |279      |1303|
|1 | EXCHANGE OUT DISTR            |:EX10001|279      |1263|
|2 |  MERGE JOIN                   |        |279      |1263|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |354 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |331 |
|5 |     PX PARTITION ITERATOR     |        |500      |331 |
|6 |      TABLE SCAN               |t1      |500      |331 |
|7 |   SORT                        |        |279      |636 |
|8 |    PX PARTITION ITERATOR      |        |279      |248 |
|9 |     TABLE SCAN                |t2      |279      |248 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 48(end)  ************** 

***************   Case 49   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |1768|
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |1579|
|2 |  MERGE OUTER JOIN             |        |500      |1579|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > ?])
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(1 ; MAX), 
      range_cond([t2.c1 > ?])

*************** Case 49(end)  ************** 

***************   Case 50   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null; 

========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST  |
--------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |        |25       |136439|
|1 | PX COORDINATOR          |        |500      |389   |
|2 |  EXCHANGE OUT DISTR     |:EX10000|500      |342   |
|3 |   PX PARTITION ITERATOR |        |500      |342   |
|4 |    TABLE SCAN           |t1      |500      |342   |
|5 | MATERIAL                |        |300      |621   |
|6 |  PX COORDINATOR         |        |300      |290   |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300      |205   |
|8 |    PX PARTITION ITERATOR|        |300      |205   |
|9 |     TABLE SCAN          |t2      |300      |205   |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS, t2.c1, NULL, 0)]), 
      conds([t1.c1 > ?]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 50(end)  ************** 

***************   Case 51   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1; 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |108575|
|1 | PX COORDINATOR           |        |300      |290   |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |205   |
|3 |   PX PARTITION ITERATOR  |        |300      |205   |
|4 |    TABLE SCAN            |t2      |300      |205   |
|5 | MATERIAL                 |        |500      |573   |
|6 |  PX COORDINATOR          |        |500      |389   |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |342   |
|8 |    PX PARTITION ITERATOR |        |500      |342   |
|9 |     TABLE SCAN           |t1      |500      |342   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 51(end)  ************** 

***************   Case 52   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2119|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2090|
|2 |  MERGE JOIN                      |        |200      |2090|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1349|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1330|
|5 |     MERGE JOIN                   |        |200      |1330|
|6 |      SORT                        |        |500      |966 |
|7 |       PX PARTITION ITERATOR      |        |500      |331 |
|8 |        TABLE SCAN                |t1      |500      |331 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |149 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |140 |
|11|        PX PARTITION ITERATOR     |        |200      |140 |
|12|         TABLE SCAN               |t3      |200      |140 |
|13|   SORT                           |        |300      |554 |
|14|    PX PARTITION ITERATOR         |        |300      |192 |
|15|     TABLE SCAN                   |t2      |300      |192 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  4 - (#keys=1, [t3.c1]), output([t1.c1], [t3.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  11 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  14 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 52(end)  ************** 

***************   Case 53   ***************

SQL: select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

======================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST  |
----------------------------------------------------------------------
|0 |NESTED-LOOP JOIN                  |             |577      |109492|
|1 | MERGE JOIN                       |             |961      |3564  |
|2 |  PX COORDINATOR MERGE SORT       |             |200      |1776  |
|3 |   EXCHANGE OUT DISTR             |:EX10001     |200      |1748  |
|4 |    SORT                          |             |200      |1748  |
|5 |     MERGE JOIN                   |             |200      |1438  |
|6 |      SORT                        |             |500      |1074  |
|7 |       PX PARTITION ITERATOR      |             |500      |342   |
|8 |        TABLE SCAN                |t1           |500      |342   |
|9 |      EXCHANGE IN MERGE SORT DISTR|             |200      |149   |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000     |200      |140   |
|11|        PX PARTITION ITERATOR     |             |200      |140   |
|12|         TABLE SCAN               |t3           |200      |140   |
|13|  PX COORDINATOR MERGE SORT       |             |500      |1122  |
|14|   EXCHANGE OUT DISTR             |:EX20000     |500      |1074  |
|15|    SORT                          |             |500      |1074  |
|16|     PX PARTITION ITERATOR        |             |500      |342   |
|17|      TABLE SCAN                  |tt(idx_t1_c2)|500      |342   |
|18| MATERIAL                         |             |300      |261   |
|19|  PX COORDINATOR                  |             |300      |206   |
|20|   EXCHANGE OUT DISTR             |:EX30000     |300      |192   |
|21|    PX PARTITION ITERATOR         |             |300      |192   |
|22|     TABLE SCAN                   |t2           |300      |192   |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  11 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([tt.c1], [tt.c2]), filter(nil), sort_keys([tt.c2, ASC])
  14 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  15 - output([tt.c1], [tt.c2]), filter(nil), sort_keys([tt.c2, ASC]), local merge sort
  16 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c2], [tt.c1]), range(MIN,MIN ; MAX,MAX)always true
  18 - output([t2.c1]), filter(nil)
  19 - output([t2.c1]), filter(nil)
  20 - output([t2.c1]), filter(nil), dop=1
  21 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  22 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 53(end)  ************** 

***************   Case 54   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

=========================================================================
|ID|OPERATOR                               |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------------
|0 |PX COORDINATOR                         |             |2        |3919|
|1 | EXCHANGE OUT DISTR                    |:EX10003     |2        |3918|
|2 |  MERGE JOIN                           |             |2        |3918|
|3 |   SORT                                |             |200      |2743|
|4 |    EXCHANGE IN DISTR                  |             |200      |2393|
|5 |     EXCHANGE OUT DISTR (PKEY)         |:EX10002     |200      |2355|
|6 |      MATERIAL                         |             |200      |2355|
|7 |       MERGE JOIN                      |             |200      |2208|
|8 |        EXCHANGE IN MERGE SORT DISTR   |             |200      |1467|
|9 |         EXCHANGE OUT DISTR (PKEY)     |:EX10001     |200      |1438|
|10|          MERGE JOIN                   |             |200      |1438|
|11|           SORT                        |             |500      |1074|
|12|            PX PARTITION ITERATOR      |             |500      |342 |
|13|             TABLE SCAN                |t1           |500      |342 |
|14|           EXCHANGE IN MERGE SORT DISTR|             |200      |149 |
|15|            EXCHANGE OUT DISTR (PKEY)  |:EX10000     |200      |140 |
|16|             PX PARTITION ITERATOR     |             |200      |140 |
|17|              TABLE SCAN               |t3           |200      |140 |
|18|        SORT                           |             |300      |554 |
|19|         PX PARTITION ITERATOR         |             |300      |192 |
|20|          TABLE SCAN                   |t2           |300      |192 |
|21|   SORT                                |             |500      |1078|
|22|    PX PARTITION ITERATOR              |             |500      |342 |
|23|     TABLE SCAN                        |tt(idx_t1_c2)|500      |342 |
=========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2], [t1.c1 + t2.c1 = tt.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t1.c1 + t2.c1]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1 + t2.c1, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c1 + t2.c1]), filter(nil)
  5 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c2], [t1.c1 + t2.c1]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2], [t1.c1 + t2.c1]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2], [t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  9 - (#keys=1, [t3.c1]), output([t1.c1], [t1.c2], [t3.c1]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2], [t3.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  11 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  14 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  15 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  16 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  17 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  18 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  19 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  20 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  21 - output([tt.c2], [tt.c1]), filter(nil), sort_keys([tt.c2, ASC], [tt.c1, ASC]), local merge sort
  22 - output([tt.c1], [tt.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  23 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c2], [tt.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 54(end)  ************** 

***************   Case 55   ***************

SQL: select * from t1 where true; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 55(end)  ************** 

***************   Case 56   ***************

SQL: select * from t1 where 1=2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 56(end)  ************** 

***************   Case 57   ***************

SQL: select * from t1, t2 where 1+1=2 and t1.c1=t2.c1+1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1707|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1593|
|2 |  HASH JOIN                  |        |300      |1593|
|3 |   PX PARTITION ITERATOR     |        |500      |342 |
|4 |    TABLE SCAN               |t1      |500      |342 |
|5 |   EXCHANGE IN DISTR         |        |300      |290 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |205 |
|7 |     PX PARTITION ITERATOR   |        |300      |205 |
|8 |      TABLE SCAN             |t2      |300      |205 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1 + ?]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil)
  6 - (#keys=1, [t2.c1 + ?]), output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3], [t2.c1 + ?]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 57(end)  ************** 

***************   Case 58   ***************

SQL: select * from t1 left join t2 t on t1.c1=t.c1 where false; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |1725|
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |1536|
|2 |  MERGE OUTER JOIN             |        |500      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t       |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), sort_keys([t.c1, ASC]), local merge sort
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      access([t.c1], [t.c2], [t.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 58(end)  ************** 

***************   Case 59   ***************

SQL: select * from t1 left join t2 t on 1=1 where false; 

========================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST  |
--------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |        |150000   |127547|
|1 | PX COORDINATOR          |        |500      |389   |
|2 |  EXCHANGE OUT DISTR     |:EX10000|500      |342   |
|3 |   PX PARTITION ITERATOR |        |500      |342   |
|4 |    TABLE SCAN           |t1      |500      |342   |
|5 | MATERIAL                |        |300      |621   |
|6 |  PX COORDINATOR         |        |300      |290   |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300      |205   |
|8 |    PX PARTITION ITERATOR|        |300      |205   |
|9 |     TABLE SCAN          |t       |300      |205   |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      conds([1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t.c1], [t.c2], [t.c3]), filter(nil)
  6 - output([t.c1], [t.c2], [t.c3]), filter(nil)
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), dop=1
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t.c1], [t.c2], [t.c3]), filter(nil), startup_filter([0]), 
      access([t.c1], [t.c2], [t.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 59(end)  ************** 

***************   Case 60   ***************

SQL: select * from t_time where c1 is NULL; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[0000-00-00 ; 0000-00-00], 
      range_cond([(T_OP_IS, t_time.c1, NULL, 1)])

*************** Case 60(end)  ************** 

***************   Case 61   ***************

SQL: select * from t_time where c1 is NULL and c1 < '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[0000-00-00 ; 0000-00-00], 
      range_cond([t_time.c1 < ?], [(T_OP_IS, t_time.c1, NULL, 1)])

*************** Case 61(end)  ************** 

***************   Case 62   ***************

SQL: select * from t_time where c1 is NULL or c1 < '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(NULL ; 2017-01-02), 
      range_cond([(T_OP_IS, t_time.c1, NULL, 1) OR t_time.c1 < ?])

*************** Case 62(end)  ************** 

***************   Case 63   ***************

SQL: select * from t_time where c1 is NULL and c1 > '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(MAX ; MIN)always false, 
      range_cond([t_time.c1 > ?], [(T_OP_IS, t_time.c1, NULL, 1)])

*************** Case 63(end)  ************** 

***************   Case 64   ***************

SQL: select * from t_time where c1 is NULL or c1 > '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|101      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[0000-00-00 ; 0000-00-00], (2017-01-02 ; MAX), 
      range_cond([(T_OP_IS, t_time.c1, NULL, 1) OR t_time.c1 > ?])

*************** Case 64(end)  ************** 

***************   Case 65   ***************

SQL: select * from t_time where c1 <=> '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([t_time.c1 <=> ?])

*************** Case 65(end)  ************** 

***************   Case 66   ***************

SQL: select * from t_time where not c1 <=> '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|99       |96  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter([(T_OP_NOT, t_time.c1 <=> ?)]), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_time.c1]), range(MIN ; MAX)always true

*************** Case 66(end)  ************** 

***************   Case 67   ***************

SQL: select * from t_time where c1 > '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(2017-01-02 ; MAX), 
      range_cond([t_time.c1 > ?])

*************** Case 67(end)  ************** 

***************   Case 68   ***************

SQL: select * from t_time where c1 < '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(NULL ; 2017-01-02), 
      range_cond([t_time.c1 < ?])

*************** Case 68(end)  ************** 

***************   Case 69   ***************

SQL: select * from t_time where c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([t_time.c1 = ?])

*************** Case 69(end)  ************** 

***************   Case 70   ***************

SQL: select * from t_time where c1 > '2017-01-02' and c1 < '2017-01-03'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(2017-01-02 ; 2017-01-03), 
      range_cond([t_time.c1 > ?], [t_time.c1 < ?])

*************** Case 70(end)  ************** 

***************   Case 71   ***************

SQL: select * from t_time where c1 > '2017-01-02' and c1 < '2017-01-03' and c1 < '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(MAX ; MIN)always false, 
      range_cond([t_time.c1 > ?], [t_time.c1 < ?], [t_time.c1 < ?])

*************** Case 71(end)  ************** 

***************   Case 72   ***************

SQL: select * from t_time where c1 > '2017-01-01' and c1 < '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([t_time.c1 > ?], [t_time.c1 < ?], [t_time.c1 = ?])

*************** Case 72(end)  ************** 

***************   Case 73   ***************

SQL: select * from t_time where c1 > '2017-01-02' and c1 < '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(MAX ; MIN)always false, 
      range_cond([t_time.c1 > ?], [t_time.c1 < ?], [t_time.c1 = ?])

*************** Case 73(end)  ************** 

***************   Case 74   ***************

SQL: select * from t_time where c1 >= '2017-01-02' and c1 <= '2017-01-03'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-03], 
      range_cond([t_time.c1 >= ?], [t_time.c1 <= ?])

*************** Case 74(end)  ************** 

***************   Case 75   ***************

SQL: select * from t_time where c1 >= '2017-01-02' and c1 <= '2017-01-03' and c1 <= '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|1        |52  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([t_time.c1 >= ?], [t_time.c1 <= ?], [t_time.c1 <= ?])

*************** Case 75(end)  ************** 

***************   Case 76   ***************

SQL: select * from t_time where c1 >= '2017-01-01' and c1 <= '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([t_time.c1 >= ?], [t_time.c1 <= ?], [t_time.c1 = ?])

*************** Case 76(end)  ************** 

***************   Case 77   ***************

SQL: select * from t_time where c1 >= '2017-01-02' and c1 <= '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([t_time.c1 >= ?], [t_time.c1 <= ?], [t_time.c1 = ?])

*************** Case 77(end)  ************** 

***************   Case 78   ***************

SQL: select usec_to_time(c1) as modify_time_us from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([usec_to_time(t1.c1)]), filter(nil)
  1 - output([usec_to_time(t1.c1)]), filter(nil), dop=1
  2 - output([usec_to_time(t1.c1)]), filter(nil), 
      force partition granule, asc.
  3 - output([usec_to_time(t1.c1)]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 78(end)  ************** 

***************   Case 79   ***************

SQL: select c1, repeat('ob', 2) as db_name from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |241 |
|1 | PX COORDINATOR MERGE SORT |             |100      |227 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |217 |
|3 |   SORT                    |             |100      |217 |
|4 |    PX PARTITION ITERATOR  |             |100      |90  |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |90  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 79(end)  ************** 

***************   Case 80   ***************

SQL: select 'ob' from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil), dop=1
  2 - output([?]), filter(nil), 
      force partition granule, asc.
  3 - output([?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 80(end)  ************** 

***************   Case 81   ***************

SQL: select c1, 'ob' from t1 where c1 > 100 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500      |1205|
|1 | EXCHANGE OUT DISTR       |:EX10000     |500      |1158|
|2 |  SORT                    |             |500      |1158|
|3 |   PX PARTITION ITERATOR  |             |500      |426 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500      |426 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c1], [?], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [?], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 81(end)  ************** 

***************   Case 82   ***************

SQL: select c1, 1 + 1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil)
  1 - output([t1.c1], [?]), filter(nil), dop=1
  2 - output([t1.c1], [?]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 82(end)  ************** 

***************   Case 83   ***************

SQL: select c1, 1 + 1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |214 |
|1 | PX COORDINATOR MERGE SORT |        |100      |200 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |196 |
|3 |   SORT                    |        |100      |196 |
|4 |    PX PARTITION ITERATOR  |        |100      |88  |
|5 |     TABLE SCAN            |t1      |100      |88  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 83(end)  ************** 

***************   Case 84   ***************

SQL: select c1 from t1 union select c2 from t2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE UNION DISTINCT       |        |800      |1900|
|1 | PX COORDINATOR MERGE SORT |        |500      |990 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|500      |966 |
|3 |   SORT                    |        |500      |966 |
|4 |    PX PARTITION ITERATOR  |        |500      |331 |
|5 |     TABLE SCAN            |t1      |500      |331 |
|6 | PX COORDINATOR MERGE SORT |        |300      |647 |
|7 |  EXCHANGE OUT DISTR       |:EX20000|300      |619 |
|8 |   SORT                    |        |300      |619 |
|9 |    PX PARTITION ITERATOR  |        |300      |198 |
|10|     TABLE SCAN            |t2      |300      |198 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  7 - output([t2.c2]), filter(nil), dop=1
  8 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 84(end)  ************** 

***************   Case 85   ***************

SQL: select c1 from t1 union all select c2 from t2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |UNION ALL               |        |800      |844 |
|1 | PX COORDINATOR         |        |500      |354 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|3 |   PX PARTITION ITERATOR|        |500      |331 |
|4 |    TABLE SCAN          |t1      |500      |331 |
|5 | PX COORDINATOR         |        |300      |227 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |198 |
|7 |   PX PARTITION ITERATOR|        |300      |198 |
|8 |    TABLE SCAN          |t2      |300      |198 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter(nil), dop=1
  7 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 85(end)  ************** 

***************   Case 86   ***************

SQL: (select c1 from t1) except (select c2 from t2) order by c1; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |500      |1882|
|1 | EXCHANGE OUT DISTR           |:EX10001|500      |1835|
|2 |  MERGE EXCEPT DISTINCT       |        |500      |1835|
|3 |   SORT                       |        |500      |966 |
|4 |    PX PARTITION ITERATOR     |        |500      |331 |
|5 |     TABLE SCAN               |t1      |500      |331 |
|6 |   SORT                       |        |300      |647 |
|7 |    EXCHANGE IN DISTR         |        |300      |227 |
|8 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |198 |
|9 |      PX PARTITION ITERATOR   |        |300      |198 |
|10|       TABLE SCAN             |t2      |300      |198 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])]), filter(nil), sort_keys([EXCEPT([1]), ASC])
  1 - output([EXCEPT([1])]), filter(nil), dop=1
  2 - output([EXCEPT([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  7 - output([t2.c2]), filter(nil)
  8 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 86(end)  ************** 

***************   Case 87   ***************

SQL: (select c1 from t1) intersect (select c2 from t2) order by c1 limit 100; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                           |        |100      |1844|
|1 | PX COORDINATOR MERGE SORT      |        |100      |1831|
|2 |  EXCHANGE OUT DISTR            |:EX10001|100      |1821|
|3 |   LIMIT                        |        |100      |1821|
|4 |    MERGE INTERSECT DISTINCT    |        |100      |1807|
|5 |     SORT                       |        |500      |966 |
|6 |      PX PARTITION ITERATOR     |        |500      |331 |
|7 |       TABLE SCAN               |t1      |500      |331 |
|8 |     SORT                       |        |300      |647 |
|9 |      EXCHANGE IN DISTR         |        |300      |227 |
|10|       EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |198 |
|11|        PX PARTITION ITERATOR   |        |300      |198 |
|12|         TABLE SCAN             |t2      |300      |198 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  1 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC])
  2 - output([INTERSECT([1])]), filter(nil), dop=1
  3 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  4 - output([INTERSECT([1])]), filter(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c2]), filter(nil)
  10 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  11 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 87(end)  ************** 

***************   Case 88   ***************

SQL: (select c1 from t1) union (select c1 from t2) order by c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |800      |1472|
|1 | EXCHANGE OUT DISTR            |:EX10001|800      |1435|
|2 |  MERGE UNION DISTINCT         |        |800      |1435|
|3 |   SORT                        |        |500      |966 |
|4 |    PX PARTITION ITERATOR      |        |500      |331 |
|5 |     TABLE SCAN                |t1      |500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 88(end)  ************** 

***************   Case 89   ***************

SQL: (select c1 from t1) union all (select c1 from t2) order by c1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SORT                     |        |800      |1885|
|1 | UNION ALL               |        |800      |823 |
|2 |  PX COORDINATOR         |        |500      |354 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
|6 |  PX COORDINATOR         |        |300      |206 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300      |192 |
|8 |    PX PARTITION ITERATOR|        |300      |192 |
|9 |     TABLE SCAN          |t2      |300      |192 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 89(end)  ************** 

***************   Case 90   ***************

SQL: (select c2 from t1 order by c1) union (select c1 from t1 order by c2); 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT       |             |1000     |2440|
|1 | PX COORDINATOR MERGE SORT |             |500      |1122|
|2 |  EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|3 |   SORT                    |             |500      |1074|
|4 |    PX PARTITION ITERATOR  |             |500      |342 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
|6 | PX COORDINATOR MERGE SORT |             |500      |990 |
|7 |  EXCHANGE OUT DISTR       |:EX20000     |500      |966 |
|8 |   SORT                    |             |500      |966 |
|9 |    PX PARTITION ITERATOR  |             |500      |331 |
|10|     TABLE SCAN            |t1           |500      |331 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c2]), filter(nil), dop=1
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 90(end)  ************** 

***************   Case 91   ***************

SQL: (select c2 from t1 order by c1) union all (select c1 from t1 order by c2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1000     |1096|
|1 | EXCHANGE OUT DISTR    |:EX10000|1000     |1001|
|2 |  PX PARTITION ITERATOR|        |1000     |1001|
|3 |   UNION ALL           |        |1000     |1001|
|4 |    TABLE SCAN         |t1      |500      |342 |
|5 |    TABLE SCAN         |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 91(end)  ************** 

***************   Case 92   ***************

SQL: (select c1 from t1 order by c2) union (select c1 from t2 order by c2 limit 2); 

=================================================================
|ID|OPERATOR                            |NAME    |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                      |        |502      |1502|
|1 | EXCHANGE OUT DISTR                 |:EX10002|502      |1454|
|2 |  MERGE UNION DISTINCT              |        |502      |1454|
|3 |   SORT                             |        |500      |966 |
|4 |    PX PARTITION ITERATOR           |        |500      |331 |
|5 |     TABLE SCAN                     |t1      |500      |331 |
|6 |   SORT                             |        |2        |323 |
|7 |    EXCHANGE IN DISTR               |        |2        |322 |
|8 |     EXCHANGE OUT DISTR (PKEY)      |:EX10001|2        |322 |
|9 |      MATERIAL                      |        |2        |322 |
|10|       LIMIT                        |        |2        |321 |
|11|        EXCHANGE IN MERGE SORT DISTR|        |2        |321 |
|12|         EXCHANGE OUT DISTR         |:EX10000|2        |320 |
|13|          LIMIT                     |        |2        |320 |
|14|           TOP-N SORT               |        |2        |320 |
|15|            PX PARTITION ITERATOR   |        |300      |198 |
|16|             TABLE SCAN             |t2      |300      |198 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  7 - output([t2.c1]), filter(nil)
  8 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), is_single, dop=1
  9 - output([t2.c1]), filter(nil)
  10 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  11 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  12 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  13 - output([t2.c1], [t2.c2]), filter(nil), limit(2), offset(nil)
  14 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  15 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  16 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 92(end)  ************** 

***************   Case 93   ***************

SQL: (select c1 from t1 order by c2) union all (select c1 from t2 order by c2 limit 2); 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |UNION ALL                   |        |502      |840 |
|1 | PX COORDINATOR             |        |500      |354 |
|2 |  EXCHANGE OUT DISTR        |:EX10000|500      |331 |
|3 |   PX PARTITION ITERATOR    |        |500      |331 |
|4 |    TABLE SCAN              |t1      |500      |331 |
|5 | LIMIT                      |        |2        |321 |
|6 |  PX COORDINATOR MERGE SORT |        |2        |321 |
|7 |   EXCHANGE OUT DISTR       |:EX20000|2        |320 |
|8 |    LIMIT                   |        |2        |320 |
|9 |     TOP-N SORT             |        |2        |320 |
|10|      PX PARTITION ITERATOR |        |300      |198 |
|11|       TABLE SCAN           |t2      |300      |198 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2]), filter(nil), limit(2), offset(nil)
  9 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 93(end)  ************** 

***************   Case 94   ***************

SQL: (select c1 from t1 order by c2) union (select c1 from t2 order by c2 limit 2) union (select c1 from t1 order by c1); 

====================================================================
|ID|OPERATOR                               |NAME    |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |PX COORDINATOR                         |        |1002     |2892|
|1 | EXCHANGE OUT DISTR                    |:EX10003|1002     |2797|
|2 |  MERGE UNION DISTINCT                 |        |1002     |2797|
|3 |   EXCHANGE IN MERGE SORT DISTR        |        |502      |1502|
|4 |    EXCHANGE OUT DISTR (PKEY)          |:EX10002|502      |1454|
|5 |     MERGE UNION DISTINCT              |        |502      |1454|
|6 |      SORT                             |        |500      |966 |
|7 |       PX PARTITION ITERATOR           |        |500      |331 |
|8 |        TABLE SCAN                     |t1      |500      |331 |
|9 |      SORT                             |        |2        |323 |
|10|       EXCHANGE IN DISTR               |        |2        |322 |
|11|        EXCHANGE OUT DISTR (PKEY)      |:EX10001|2        |322 |
|12|         MATERIAL                      |        |2        |322 |
|13|          LIMIT                        |        |2        |321 |
|14|           EXCHANGE IN MERGE SORT DISTR|        |2        |321 |
|15|            EXCHANGE OUT DISTR         |:EX10000|2        |320 |
|16|             LIMIT                     |        |2        |320 |
|17|              TOP-N SORT               |        |2        |320 |
|18|               PX PARTITION ITERATOR   |        |300      |198 |
|19|                TABLE SCAN             |t2      |300      |198 |
|20|   SORT                                |        |500      |966 |
|21|    PX PARTITION ITERATOR              |        |500      |331 |
|22|     TABLE SCAN                        |t1      |500      |331 |
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  4 - (#keys=1, [UNION([1])]), output([UNION([1])]), filter(nil), dop=1
  5 - output([UNION([1])]), filter(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil)
  11 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), is_single, dop=1
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  14 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  15 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  16 - output([t2.c1], [t2.c2]), filter(nil), limit(2), offset(nil)
  17 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  18 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  19 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  20 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  21 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  22 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 94(end)  ************** 

***************   Case 95   ***************

SQL: (select c1 from t1 order by c2) union all (select c1 from t2 order by c2 limit 2) union all (select c1 from t1 order by c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |UNION ALL                    |        |1002     |1524|
|1 | UNION ALL                   |        |502      |840 |
|2 |  PX COORDINATOR             |        |500      |354 |
|3 |   EXCHANGE OUT DISTR        |:EX10000|500      |331 |
|4 |    PX PARTITION ITERATOR    |        |500      |331 |
|5 |     TABLE SCAN              |t1      |500      |331 |
|6 |  LIMIT                      |        |2        |321 |
|7 |   PX COORDINATOR MERGE SORT |        |2        |321 |
|8 |    EXCHANGE OUT DISTR       |:EX20000|2        |320 |
|9 |     LIMIT                   |        |2        |320 |
|10|      TOP-N SORT             |        |2        |320 |
|11|       PX PARTITION ITERATOR |        |300      |198 |
|12|        TABLE SCAN           |t2      |300      |198 |
|13| PX COORDINATOR              |        |500      |354 |
|14|  EXCHANGE OUT DISTR         |:EX30000|500      |331 |
|15|   PX PARTITION ITERATOR     |        |500      |331 |
|16|    TABLE SCAN               |t1      |500      |331 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  8 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2]), filter(nil), limit(2), offset(nil)
  10 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1]), filter(nil)
  14 - output([t1.c1]), filter(nil), dop=1
  15 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 95(end)  ************** 

***************   Case 96   ***************

SQL: (select c1 from t1 order by c2 limit 2) union (select c1 from t2 order by c2 limit 2); 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |HASH UNION DISTINCT         |             |4        |363 |
|1 | LIMIT                      |             |2        |39  |
|2 |  PX COORDINATOR MERGE SORT |             |2        |38  |
|3 |   EXCHANGE OUT DISTR       |:EX10000     |2        |38  |
|4 |    SORT                    |             |2        |38  |
|5 |     PX PARTITION ITERATOR  |             |2        |37  |
|6 |      TABLE SCAN            |t1(idx_t1_c2)|2        |37  |
|7 | LIMIT                      |             |2        |321 |
|8 |  PX COORDINATOR MERGE SORT |             |2        |321 |
|9 |   EXCHANGE OUT DISTR       |:EX20000     |2        |320 |
|10|    LIMIT                   |             |2        |320 |
|11|     TOP-N SORT             |             |2        |320 |
|12|      PX PARTITION ITERATOR |             |300      |198 |
|13|       TABLE SCAN           |t2           |300      |198 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), limit(2), offset(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), limit(2), offset(nil)
  11 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  13 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 96(end)  ************** 

***************   Case 97   ***************

SQL: (select c1 from t1 order by c2 limit 2) union all (select c1 from t2 order by c2 limit 2); 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |UNION ALL                   |             |4        |360 |
|1 | LIMIT                      |             |2        |39  |
|2 |  PX COORDINATOR MERGE SORT |             |2        |38  |
|3 |   EXCHANGE OUT DISTR       |:EX10000     |2        |38  |
|4 |    SORT                    |             |2        |38  |
|5 |     PX PARTITION ITERATOR  |             |2        |37  |
|6 |      TABLE SCAN            |t1(idx_t1_c2)|2        |37  |
|7 | LIMIT                      |             |2        |321 |
|8 |  PX COORDINATOR MERGE SORT |             |2        |321 |
|9 |   EXCHANGE OUT DISTR       |:EX20000     |2        |320 |
|10|    LIMIT                   |             |2        |320 |
|11|     TOP-N SORT             |             |2        |320 |
|12|      PX PARTITION ITERATOR |             |300      |198 |
|13|       TABLE SCAN           |t2           |300      |198 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), limit(2), offset(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), limit(2), offset(nil)
  11 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  13 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 97(end)  ************** 

***************   Case 98   ***************

SQL: (select c1 from t1) union (select c2 from t1) union (select c2 from t2); 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT        |             |1300     |3515|
|1 | MERGE UNION DISTINCT       |             |1000     |2440|
|2 |  PX COORDINATOR MERGE SORT |             |500      |990 |
|3 |   EXCHANGE OUT DISTR       |:EX10000     |500      |966 |
|4 |    SORT                    |             |500      |966 |
|5 |     PX PARTITION ITERATOR  |             |500      |331 |
|6 |      TABLE SCAN            |t1           |500      |331 |
|7 |  PX COORDINATOR MERGE SORT |             |500      |1122|
|8 |   EXCHANGE OUT DISTR       |:EX20000     |500      |1074|
|9 |    SORT                    |             |500      |1074|
|10|     PX PARTITION ITERATOR  |             |500      |342 |
|11|      TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
|12| PX COORDINATOR MERGE SORT  |             |300      |647 |
|13|  EXCHANGE OUT DISTR        |:EX30000     |300      |619 |
|14|   SORT                     |             |300      |619 |
|15|    PX PARTITION ITERATOR   |             |300      |198 |
|16|     TABLE SCAN             |t2           |300      |198 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  8 - output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  10 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  11 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  12 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  13 - output([t2.c2]), filter(nil), dop=1
  14 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  15 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  16 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 98(end)  ************** 

***************   Case 99   ***************

SQL: (select /*+no_use_px*/ c1 from t1) union (select c2 from t1) union (select c2 from t2) order by c1 limit 100; 

=======================================================================
|ID|OPERATOR                             |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------------
|0 |LIMIT                                |             |100      |1694|
|1 | MERGE UNION DISTINCT                |             |100      |1680|
|2 |  LIMIT                              |             |100      |903 |
|3 |   MERGE UNION DISTINCT              |             |100      |890 |
|4 |    LIMIT                            |             |100      |214 |
|5 |     PX COORDINATOR MERGE SORT       |             |100      |200 |
|6 |      EXCHANGE OUT DISTR             |:EX10000     |100      |196 |
|7 |       SORT                          |             |100      |196 |
|8 |        PX PARTITION ITERATOR        |             |100      |88  |
|9 |         TABLE SCAN                  |t1           |100      |88  |
|10|    LIMIT                            |             |100      |610 |
|11|     PX COORDINATOR MERGE SORT       |             |100      |596 |
|12|      EXCHANGE OUT DISTR             |:EX20001     |100      |587 |
|13|       LIMIT                         |             |100      |587 |
|14|        MERGE DISTINCT               |             |100      |573 |
|15|         EXCHANGE IN MERGE SORT DISTR|             |100      |462 |
|16|          EXCHANGE OUT DISTR (HASH)  |:EX20000     |100      |453 |
|17|           PX PARTITION ITERATOR     |             |100      |453 |
|18|            MERGE DISTINCT           |             |100      |453 |
|19|             TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
|20|  LIMIT                              |             |100      |712 |
|21|   PX COORDINATOR MERGE SORT         |             |100      |698 |
|22|    EXCHANGE OUT DISTR               |:EX30001     |100      |689 |
|23|     LIMIT                           |             |100      |689 |
|24|      TOP-N SORT                     |             |100      |675 |
|25|       HASH DISTINCT                 |             |100      |548 |
|26|        EXCHANGE IN DISTR            |             |100      |378 |
|27|         EXCHANGE OUT DISTR (HASH)   |:EX30000     |100      |368 |
|28|          HASH DISTINCT              |             |100      |368 |
|29|           PX PARTITION ITERATOR     |             |300      |198 |
|30|            TABLE SCAN               |t2           |300      |198 |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), limit(100), offset(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([UNION([1])]), filter(nil), limit(100), offset(nil)
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), dop=1
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  11 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  12 - output([t1.c2]), filter(nil), dop=1
  13 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  14 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  15 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  16 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  17 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  18 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  19 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  20 - output([t2.c2]), filter(nil), limit(100), offset(nil)
  21 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  22 - output([t2.c2]), filter(nil), dop=1
  23 - output([t2.c2]), filter(nil), limit(100), offset(nil)
  24 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(100)
  25 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  26 - output([t2.c2]), filter(nil)
  27 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  28 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  29 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  30 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 99(end)  ************** 

***************   Case 100   ***************

SQL: (select c1 from t1) union (select c2 from t1) intersect (select c2 from t2) order by c1 limit 100; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |LIMIT                        |             |100      |3390|
|1 | MERGE INTERSECT DISTINCT    |             |100      |3377|
|2 |  MERGE UNION DISTINCT       |             |1000     |2440|
|3 |   PX COORDINATOR MERGE SORT |             |500      |990 |
|4 |    EXCHANGE OUT DISTR       |:EX10000     |500      |966 |
|5 |     SORT                    |             |500      |966 |
|6 |      PX PARTITION ITERATOR  |             |500      |331 |
|7 |       TABLE SCAN            |t1           |500      |331 |
|8 |   PX COORDINATOR MERGE SORT |             |500      |1122|
|9 |    EXCHANGE OUT DISTR       |:EX20000     |500      |1074|
|10|     SORT                    |             |500      |1074|
|11|      PX PARTITION ITERATOR  |             |500      |342 |
|12|       TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
|13|  PX COORDINATOR MERGE SORT  |             |300      |647 |
|14|   EXCHANGE OUT DISTR        |:EX30000     |300      |619 |
|15|    SORT                     |             |300      |619 |
|16|     PX PARTITION ITERATOR   |             |300      |198 |
|17|      TABLE SCAN             |t2           |300      |198 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  1 - output([INTERSECT([1])]), filter(nil)
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  9 - output([t1.c2]), filter(nil), dop=1
  10 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  11 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  13 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  14 - output([t2.c2]), filter(nil), dop=1
  15 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  16 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 100(end)  ************** 

***************   Case 101   ***************

SQL: select distinct(c2) from t1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |582 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |573 |
|2 |  MERGE DISTINCT               |             |100      |573 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |462 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |453 |
|5 |     PX PARTITION ITERATOR     |             |100      |453 |
|6 |      MERGE DISTINCT           |             |100      |453 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 101(end)  ************** 

***************   Case 102   ***************

SQL: select/*+(use_order_distinct)*/ distinct(c1) from t4; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE DISTINCT|    |100      |112 |
|1 | TABLE SCAN   |t4  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 102(end)  ************** 

***************   Case 103   ***************

SQL: select distinct c1, c2 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 103(end)  ************** 

***************   Case 104   ***************

SQL: select distinct c1, c2 from t4; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |54  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 104(end)  ************** 

***************   Case 105   ***************

SQL: select distinct(t1.c2), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |300      |2033|
|1 | EXCHANGE OUT DISTR               |:EX10002|300      |1976|
|2 |  HASH DISTINCT                   |        |300      |1976|
|3 |   EXCHANGE IN DISTR              |        |300      |1645|
|4 |    EXCHANGE OUT DISTR (HASH)     |:EX10001|300      |1589|
|5 |     MERGE JOIN                   |        |300      |1589|
|6 |      SORT                        |        |500      |1074|
|7 |       PX PARTITION ITERATOR      |        |500      |342 |
|8 |        TABLE SCAN                |t1      |500      |342 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |300      |227 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |198 |
|11|        PX PARTITION ITERATOR     |        |300      |198 |
|12|         TABLE SCAN               |t2      |300      |198 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c2]), filter(nil)
  1 - output([t1.c2], [t2.c2]), filter(nil), dop=1
  2 - output([t1.c2], [t2.c2]), filter(nil), 
      distinct([t1.c2], [t2.c2])
  3 - output([t1.c2], [t2.c2]), filter(nil)
  4 - (#keys=2, [t1.c2], [t2.c2]), output([t1.c2], [t2.c2]), filter(nil), dop=1
  5 - output([t1.c2], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  10 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2]), filter(nil), dop=1
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 105(end)  ************** 

***************   Case 106   ***************

SQL: select distinct(t1.c1), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1304|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1261|
|2 |  MERGE JOIN                   |        |300      |1261|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |354 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |331 |
|5 |     PX PARTITION ITERATOR     |        |500      |331 |
|6 |      TABLE SCAN               |t1      |500      |331 |
|7 |   SORT                        |        |300      |619 |
|8 |    PX PARTITION ITERATOR      |        |300      |198 |
|9 |     TABLE SCAN                |t2      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2]), filter(nil)
  1 - output([t1.c1], [t2.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 106(end)  ************** 

***************   Case 107   ***************

SQL: select distinct t4.c1, t4.c2, t2.c2 from t4, t2 where t4.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |852 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |833 |
|2 |  MERGE JOIN                 |        |100      |833 |
|3 |   EXCHANGE IN DISTR         |        |100      |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|5 |     TABLE SCAN              |t4      |100      |90  |
|6 |   SORT                      |        |300      |619 |
|7 |    PX PARTITION ITERATOR    |        |300      |198 |
|8 |     TABLE SCAN              |t2      |300      |198 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil)
  1 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [t4.c2]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 107(end)  ************** 

***************   Case 108   ***************

SQL: select distinct c1 as ali_name from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 108(end)  ************** 

***************   Case 109   ***************

SQL: select distinct c2 as ali_name from t1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |582 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |573 |
|2 |  MERGE DISTINCT               |             |100      |573 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |462 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |453 |
|5 |     PX PARTITION ITERATOR     |             |100      |453 |
|6 |      MERGE DISTINCT           |             |100      |453 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 109(end)  ************** 

***************   Case 110   ***************

SQL: select distinct c1 * c2 from t1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |958 |
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |911 |
|2 |  HASH DISTINCT              |        |500      |911 |
|3 |   EXCHANGE IN DISTR         |        |500      |389 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR   |        |500      |342 |
|6 |      TABLE SCAN             |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 * t1.c2]), filter(nil)
  1 - output([t1.c1 * t1.c2]), filter(nil), dop=1
  2 - output([t1.c1 * t1.c2]), filter(nil), 
      distinct([t1.c1 * t1.c2])
  3 - output([t1.c1 * t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1 * t1.c2]), output([t1.c1 * t1.c2]), filter(nil), dop=1
  5 - output([t1.c1 * t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1 * t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 110(end)  ************** 

***************   Case 111   ***************

SQL: select distinct 1, 2 from t1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |1        |37  |
|1 | PX COORDINATOR         |        |1        |36  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|3 |   PX PARTITION ITERATOR|        |1        |36  |
|4 |    TABLE SCAN          |t1      |1        |36  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(1), offset(nil)
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), dop=1
  3 - output([1]), filter(nil), 
      force partition granule, asc.
  4 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 111(end)  ************** 

***************   Case 112   ***************

SQL: select distinct c2 from t4 order by c2 limit 3; 

=================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST|
-------------------------------------------------
|0 |LIMIT          |             |3        |38  |
|1 | MERGE DISTINCT|             |3        |37  |
|2 |  TABLE SCAN   |t4(idx_t4_c2)|3        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 112(end)  ************** 

***************   Case 113   ***************

SQL: select distinct c2 from t4 order by c2; 

================================================
|ID|OPERATOR      |NAME         |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE DISTINCT|             |100      |77  |
|1 | TABLE SCAN   |t4(idx_t4_c2)|100      |54  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  1 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 113(end)  ************** 

***************   Case 114   ***************

SQL: select distinct c2 from t4 order by c3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |SORT           |                |100      |242 |
|1 | MERGE DISTINCT|                |100      |115 |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|100      |92  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC])
  1 - output([t4.c2], [t4.c3]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 114(end)  ************** 

***************   Case 115   ***************

SQL: select distinct c1, c2 from t4 order by c3; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c3)|100      |92  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 115(end)  ************** 

***************   Case 116   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

=====================================================
|ID|OPERATOR        |NAME            |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT           |                |3        |161 |
|1 | TOP-N SORT     |                |3        |161 |
|2 |  MERGE DISTINCT|                |100      |115 |
|3 |   TABLE SCAN   |t4(idx_t4_c2_c3)|100      |92  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      distinct([t4.c2])
  3 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 116(end)  ************** 

***************   Case 117   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

=====================================================
|ID|OPERATOR        |NAME            |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT           |                |3        |161 |
|1 | TOP-N SORT     |                |3        |161 |
|2 |  MERGE DISTINCT|                |100      |115 |
|3 |   TABLE SCAN   |t4(idx_t4_c2_c3)|100      |92  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      distinct([t4.c2])
  3 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 117(end)  ************** 

***************   Case 118   ***************

SQL: select distinct c2 from t5 order by c3 limit 3; 

====================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |LIMIT                             |             |3        |352 |
|1 | PX COORDINATOR MERGE SORT        |             |3        |352 |
|2 |  EXCHANGE OUT DISTR              |:EX10001     |3        |351 |
|3 |   LIMIT                          |             |3        |351 |
|4 |    TOP-N SORT                    |             |3        |351 |
|5 |     MERGE DISTINCT               |             |100      |305 |
|6 |      EXCHANGE IN MERGE SORT DISTR|             |100      |238 |
|7 |       EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |229 |
|8 |        PX PARTITION ITERATOR     |             |100      |229 |
|9 |         MERGE DISTINCT           |             |100      |229 |
|10|          TABLE SCAN              |t5(idx_t5_c2)|300      |162 |
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3]), filter(nil), limit(3), offset(nil)
  4 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC]), topn(3)
  5 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  6 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  7 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3]), filter(nil), dop=1
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  10 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 118(end)  ************** 

***************   Case 119   ***************

SQL: select distinct c2 from t5 order by c3; 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |             |100      |441 |
|1 | EXCHANGE OUT DISTR             |:EX10001     |100      |432 |
|2 |  SORT                          |             |100      |432 |
|3 |   MERGE DISTINCT               |             |100      |305 |
|4 |    EXCHANGE IN MERGE SORT DISTR|             |100      |238 |
|5 |     EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |229 |
|6 |      PX PARTITION ITERATOR     |             |100      |229 |
|7 |       MERGE DISTINCT           |             |100      |229 |
|8 |        TABLE SCAN              |t5(idx_t5_c2)|300      |162 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), sort_keys([t5.c3, ASC])
  1 - output([t5.c2], [t5.c3]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  3 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  4 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  5 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3]), filter(nil), dop=1
  6 - output([t5.c2], [t5.c3]), filter(nil), 
      force partition granule, asc.
  7 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 119(end)  ************** 

***************   Case 120   ***************

SQL: select * from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 120(end)  ************** 

***************   Case 121   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |58  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |57  |
|2 |  PX PARTITION ITERATOR|        |2        |57  |
|3 |   TABLE GET           |t1      |2        |57  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])

*************** Case 121(end)  ************** 

***************   Case 122   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7 or c1 = 8; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |3        |63  |
|1 | EXCHANGE OUT DISTR    |:EX10000|3        |63  |
|2 |  PX PARTITION ITERATOR|        |3        |63  |
|3 |   TABLE GET           |t1      |3        |63  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p[2-3]), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], [8 ; 8], 
      range_cond([(T_OP_OR, t1.c1 = ?, t1.c1 = ?, t1.c1 = ?)])

*************** Case 122(end)  ************** 

***************   Case 123   ***************

SQL: select c1 as alias_name from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 123(end)  ************** 

***************   Case 124   ***************

SQL: select * from t5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |247 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |205 |
|2 |  PX PARTITION ITERATOR|        |300      |205 |
|3 |   TABLE SCAN          |t5      |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 124(end)  ************** 

***************   Case 125   ***************

SQL: select * from t5 where c2 =3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |247 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |205 |
|2 |  PX PARTITION ITERATOR|        |300      |205 |
|3 |   TABLE SCAN          |t5      |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(3,MIN ; 3,MAX), 
      range_cond([t5.c2 = ?])

*************** Case 125(end)  ************** 

***************   Case 126   ***************

SQL: select * from t5 where c2 = 5 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t5  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[5,7 ; 5,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 126(end)  ************** 

***************   Case 127   ***************

SQL: select * from t5 where c2 = 6 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t5  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[6,7 ; 6,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 127(end)  ************** 

***************   Case 128   ***************

SQL: select * from t5 where c2 = 11 and c3 = 8; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t5  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[11,8 ; 11,8], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 128(end)  ************** 

***************   Case 129   ***************

SQL: select c1 from t6; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |206 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |192 |
|2 |  PX PARTITION ITERATOR|        |300      |192 |
|3 |   TABLE SCAN          |t6      |300      |192 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1]), filter(nil)
  1 - output([t6.c1]), filter(nil), dop=1
  2 - output([t6.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 129(end)  ************** 

***************   Case 130   ***************

SQL: select * from t6 where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t6  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t6.c1]), range[3 ; 3], 
      range_cond([t6.c1 = ?])

*************** Case 130(end)  ************** 

***************   Case 131   ***************

SQL: select * from t6 where c1 = 10; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t6  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t6.c1]), range[10 ; 10], 
      range_cond([t6.c1 = ?])

*************** Case 131(end)  ************** 

***************   Case 132   ***************

SQL: select t1.c2 + t2.c1 from t1, t2 where t1.c1 = t2.c2 and t1.c1 and t1.c1 = 1 and t2.c1 = 2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |53  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t2      |1        |53  |
|4 | PX COORDINATOR           |        |1        |53  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |53  |
|6 |   TABLE GET              |t1      |1        |53  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1]), filter(nil)
  2 - output([t2.c1]), filter(nil), is_single, dop=1
  3 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2]), partitions(p2), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c2]), filter(nil)
  5 - output([t1.c2]), filter(nil), is_single, dop=1
  6 - output([t1.c2]), filter([t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 132(end)  ************** 

***************   Case 133   ***************

SQL: select t1.c1 from t1,t2 where t1.c1+1=t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1290|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1262|
|2 |  HASH JOIN                  |        |300      |1262|
|3 |   PX PARTITION ITERATOR     |        |300      |192 |
|4 |    TABLE SCAN               |t2      |300      |192 |
|5 |   EXCHANGE IN DISTR         |        |500      |354 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |331 |
|7 |     PX PARTITION ITERATOR   |        |500      |331 |
|8 |      TABLE SCAN             |t1      |500      |331 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c1 + ?]), filter(nil)
  6 - (#keys=1, [t1.c1 + ?]), output([t1.c1], [t1.c1 + ?]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      force partition granule, asc.
  8 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 133(end)  ************** 

***************   Case 134   ***************

SQL: select t1.c1, t2.c1 from t1, t2 where t1.c1 = 1 and t2.c1 = 1 and t1.c1 = t2.c1; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |105 |
|1 | EXCHANGE OUT REMOTE        |    |1        |105 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|3 |   TABLE GET                |t1  |1        |52  |
|4 |   TABLE GET                |t2  |1        |52  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil)
  1 - output([t1.c1], [t2.c1]), filter(nil)
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?], [t1.c1 = ?])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?], [t2.c1 = ?])

*************** Case 134(end)  ************** 

***************   Case 135   ***************

SQL: select /*+ leading(t2 t1 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2544|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2411|
|2 |  MERGE JOIN                      |        |200      |2411|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |300      |1649|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1536|
|5 |     MERGE JOIN                   |        |300      |1536|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|11|        PX PARTITION ITERATOR     |        |500      |342 |
|12|         TABLE SCAN               |t1      |500      |342 |
|13|   SORT                           |        |200      |575 |
|14|    PX PARTITION ITERATOR         |        |200      |149 |
|15|     TABLE SCAN                   |t3      |200      |149 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  10 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 135(end)  ************** 

***************   Case 136   ***************

SQL: select /*+ leading(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2786|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2654|
|2 |  MERGE JOIN                      |        |200      |2654|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1365|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1251|
|5 |     MERGE JOIN                   |        |200      |1251|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|11|        PX PARTITION ITERATOR     |        |200      |149 |
|12|         TABLE SCAN               |t3      |200      |149 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 136(end)  ************** 

***************   Case 137   ***************

SQL: select /*+ use_merge(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2786|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2654|
|2 |  MERGE JOIN                      |        |200      |2654|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1365|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1251|
|5 |     MERGE JOIN                   |        |200      |1251|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|11|        PX PARTITION ITERATOR     |        |200      |149 |
|12|         TABLE SCAN               |t3      |200      |149 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 137(end)  ************** 

***************   Case 138   ***************

SQL: select /*+ use_merge(t1)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2786|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2654|
|2 |  MERGE JOIN                      |        |200      |2654|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1365|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1251|
|5 |     MERGE JOIN                   |        |200      |1251|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|11|        PX PARTITION ITERATOR     |        |200      |149 |
|12|         TABLE SCAN               |t3      |200      |149 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 138(end)  ************** 

***************   Case 139   ***************

SQL: select /*+ use_merge(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2786|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2654|
|2 |  MERGE JOIN                      |        |200      |2654|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1365|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1251|
|5 |     MERGE JOIN                   |        |200      |1251|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|11|        PX PARTITION ITERATOR     |        |200      |149 |
|12|         TABLE SCAN               |t3      |200      |149 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 139(end)  ************** 

***************   Case 140   ***************

SQL: select /*+ use_nl(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2544|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2411|
|2 |  MERGE JOIN                      |        |200      |2411|
|3 |   SORT                           |        |200      |575 |
|4 |    PX PARTITION ITERATOR         |        |200      |149 |
|5 |     TABLE SCAN                   |t3      |200      |149 |
|6 |   EXCHANGE IN MERGE SORT DISTR   |        |300      |1649|
|7 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1536|
|8 |     MERGE JOIN                   |        |300      |1536|
|9 |      SORT                        |        |300      |859 |
|10|       PX PARTITION ITERATOR      |        |300      |205 |
|11|        TABLE SCAN                |t2      |300      |205 |
|12|      EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|13|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|14|        PX PARTITION ITERATOR     |        |500      |342 |
|15|         TABLE SCAN               |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  7 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  13 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 140(end)  ************** 

***************   Case 141   ***************

SQL: select /*+ use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2786|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2654|
|2 |  MERGE JOIN                      |        |200      |2654|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1365|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1251|
|5 |     MERGE JOIN                   |        |200      |1251|
|6 |      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|8 |        PX PARTITION ITERATOR     |        |200      |149 |
|9 |         TABLE SCAN               |t3      |200      |149 |
|10|      SORT                        |        |300      |859 |
|11|       PX PARTITION ITERATOR      |        |300      |205 |
|12|        TABLE SCAN                |t2      |300      |205 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  7 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 141(end)  ************** 

***************   Case 142   ***************

SQL: select /*+ ordered, use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST |
----------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |12802|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |12670|
|2 |  NESTED-LOOP JOIN                |        |200      |12670|
|3 |   EXCHANGE IN DISTR              |        |300      |1649 |
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1536 |
|5 |     MERGE JOIN                   |        |300      |1536 |
|6 |      EXCHANGE IN MERGE SORT DISTR|        |500      |389  |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342  |
|8 |        PX PARTITION ITERATOR     |        |500      |342  |
|9 |         TABLE SCAN               |t1      |500      |342  |
|10|      SORT                        |        |300      |859  |
|11|       PX PARTITION ITERATOR      |        |300      |205  |
|12|        TABLE SCAN                |t2      |300      |205  |
|13|   PX PARTITION ITERATOR          |        |1        |36   |
|14|    TABLE GET                     |t3      |1        |36   |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 142(end)  ************** 

***************   Case 143   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2786|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2654|
|2 |  MERGE JOIN                      |        |200      |2654|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1365|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1251|
|5 |     MERGE JOIN                   |        |200      |1251|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|11|        PX PARTITION ITERATOR     |        |200      |149 |
|12|         TABLE SCAN               |t3      |200      |149 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 143(end)  ************** 

***************   Case 144   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2786|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2654|
|2 |  MERGE JOIN                      |        |200      |2654|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1365|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1251|
|5 |     MERGE JOIN                   |        |200      |1251|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|11|        PX PARTITION ITERATOR     |        |200      |149 |
|12|         TABLE SCAN               |t3      |200      |149 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 144(end)  ************** 

***************   Case 145   ***************

SQL: select /*+ ordered, use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST |
----------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |20976|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |20844|
|2 |  MERGE JOIN                      |        |200      |20844|
|3 |   SORT                           |        |300      |20082|
|4 |    EXCHANGE IN DISTR             |        |300      |19311|
|5 |     EXCHANGE OUT DISTR (PKEY)    |:EX10001|300      |19198|
|6 |      MATERIAL                    |        |300      |19198|
|7 |       NESTED-LOOP JOIN           |        |300      |18757|
|8 |        EXCHANGE IN DISTR         |        |500      |389  |
|9 |         EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |342  |
|10|          PX PARTITION ITERATOR   |        |500      |342  |
|11|           TABLE SCAN             |t1      |500      |342  |
|12|        PX PARTITION ITERATOR     |        |1        |36   |
|13|         TABLE GET                |t2      |1        |36   |
|14|   SORT                           |        |200      |575  |
|15|    PX PARTITION ITERATOR         |        |200      |149  |
|16|     TABLE SCAN                   |t3      |200      |149  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - (#keys=1, [t2.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  8 - output([t1.c1], [t1.c2], [PARTITION_ID]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2], [PARTITION_ID]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  15 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  16 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 145(end)  ************** 

***************   Case 146   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |1868|
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |1867|
|2 |  PX PARTITION ITERATOR|             |6        |1867|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |1867|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 146(end)  ************** 

***************   Case 147   ***************

SQL: select /*+ index(t5 idx_t5_c3) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |1868|
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |1867|
|2 |  PX PARTITION ITERATOR|             |6        |1867|
|3 |   TABLE SCAN          |t5(idx_t5_c3)|6        |1867|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 147(end)  ************** 

***************   Case 148   ***************

SQL: select /*+ index(t5 primary) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |231 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |230 |
|2 |  PX PARTITION ITERATOR|        |6        |230 |
|3 |   TABLE SCAN          |t5      |6        |230 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 148(end)  ************** 

***************   Case 149   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ * from t5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |300      |1885|
|1 | EXCHANGE OUT DISTR    |:EX10000     |300      |1842|
|2 |  PX PARTITION ITERATOR|             |300      |1842|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|300      |1842|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 149(end)  ************** 

***************   Case 150   ***************

SQL: select /*+ full(t5) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |231 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |230 |
|2 |  PX PARTITION ITERATOR|        |6        |230 |
|3 |   TABLE SCAN          |t5      |6        |230 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 150(end)  ************** 

***************   Case 151   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |1868|
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |1867|
|2 |  PX PARTITION ITERATOR|             |6        |1867|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |1867|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 151(end)  ************** 

***************   Case 152   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2, primary) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |231 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |230 |
|2 |  PX PARTITION ITERATOR|        |6        |230 |
|3 |   TABLE SCAN          |t5      |6        |230 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 152(end)  ************** 

***************   Case 153   ***************

SQL: select c1, c2 from t5 use index for order by (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |1868|
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |1867|
|2 |  PX PARTITION ITERATOR|             |6        |1867|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |1867|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 153(end)  ************** 

***************   Case 154   ***************

SQL: select c1, c2 from t5 force index for group by (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |1868|
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |1867|
|2 |  PX PARTITION ITERATOR|             |6        |1867|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |1867|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 154(end)  ************** 

***************   Case 155   ***************

SQL: select c1, c2 from t5 use index (primary) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |231 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |230 |
|2 |  PX PARTITION ITERATOR|        |6        |230 |
|3 |   TABLE SCAN          |t5      |6        |230 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 155(end)  ************** 

***************   Case 156   ***************

SQL: select c1, c2 from t1 ignore index (idx_t1_c2) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |384 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |384 |
|2 |  PX PARTITION ITERATOR|        |6        |384 |
|3 |   TABLE SCAN          |t1      |6        |384 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = ? OR t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 156(end)  ************** 

***************   Case 157   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |231 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |230 |
|2 |  PX PARTITION ITERATOR|        |6        |230 |
|3 |   TABLE SCAN          |t5      |6        |230 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 157(end)  ************** 

***************   Case 158   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2, idx_t5_c3) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |231 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |230 |
|2 |  PX PARTITION ITERATOR|        |6        |230 |
|3 |   TABLE SCAN          |t5      |6        |230 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 158(end)  ************** 

***************   Case 159   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c3, primary) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |1868|
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |1867|
|2 |  PX PARTITION ITERATOR|             |6        |1867|
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |1867|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2]), filter(nil)
  1 - output([t5.c2], [t5.c1]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 159(end)  ************** 

***************   Case 160   ***************

SQL: select max(c2) from t1 where c1 = 2; 

==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |EXCHANGE IN REMOTE  |     |1        |53  |
|1 | EXCHANGE OUT REMOTE|     |1        |53  |
|2 |  SCALAR GROUP BY   |     |1        |53  |
|3 |   SUBPLAN SCAN     |VIEW1|1        |53  |
|4 |    TABLE GET       |t1   |1        |53  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.c2)]), filter(nil)
  1 - output([T_FUN_MAX(VIEW1.c2)]), filter(nil)
  2 - output([T_FUN_MAX(VIEW1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.c2)])
  3 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  4 - output([t1.c2]), filter([(T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c2]), partitions(p2), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 160(end)  ************** 

***************   Case 161   ***************

SQL: select @@sql_mode, c1 from t1 limit 1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |1        |37  |
|1 | PX COORDINATOR         |        |1        |36  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|3 |   PX PARTITION ITERATOR|        |1        |36  |
|4 |    TABLE SCAN          |t1      |1        |36  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 161(end)  ************** 

***************   Case 162   ***************

SQL: select 1+2 from dual; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 162(end)  ************** 

***************   Case 163   ***************

SQL: select 1 + 2 from dual where 1 > 2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter([0])
      values({?})

*************** Case 163(end)  ************** 

***************   Case 164   ***************

SQL: select c1 from t1 where c1 = 0 and c2 = 2; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[0 ; 0], 
      range_cond([t1.c1 = ?])

*************** Case 164(end)  ************** 

***************   Case 165   ***************

SQL: select /*+ ordered, use_merge(t3) */ * from t2, t3 where t2.c2 = t3.c1 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |53  |
|1 | TABLE GET                |t2  |1        |53  |
|2 | TABLE GET                |t3  |1        |53  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])

*************** Case 165(end)  ************** 

***************   Case 166   ***************

SQL: select /*+ use_merge(t3) */ * from t2, t3 where t2.c1 = t3.c2 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |53  |
|1 | TABLE GET                |t3  |1        |53  |
|2 | TABLE GET                |t2  |1        |53  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter([t3.c2 = ?]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])

*************** Case 166(end)  ************** 

***************   Case 167   ***************

SQL: select c1 as c from t1 partition (p4, p3) as t where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t   |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil)
  1 - output([t.c1]), filter(nil)
  2 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t.c1]), range[3 ; 3], 
      range_cond([t.c1 = ?])

*************** Case 167(end)  ************** 

***************   Case 168   ***************

SQL: select c1 from t1 partition (p1) where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 168(end)  ************** 

***************   Case 169   ***************

SQL: select count(*) from t1 partition(p1); 

==============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST |
----------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |78755|
|1 | EXCHANGE OUT REMOTE|    |1        |78755|
|2 |  SCALAR GROUP BY   |    |1        |78755|
|3 |   TABLE SCAN       |t1  |100000   |59654|
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil)
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 169(end)  ************** 

***************   Case 170   ***************

SQL: select * from t1 partition(p1) join t2 partition(p2) on t1.c1 = t2.c1; 

===================================================
|ID|OPERATOR            |NAME    |EST. ROWS|COST  |
---------------------------------------------------
|0 |MERGE JOIN          |        |100001   |250702|
|1 | PX COORDINATOR     |        |100000   |71326 |
|2 |  EXCHANGE OUT DISTR|:EX10000|100000   |61860 |
|3 |   TABLE SCAN       |t1      |100000   |61860 |
|4 | PX COORDINATOR     |        |100000   |92464 |
|5 |  EXCHANGE OUT DISTR|:EX20000|100000   |64066 |
|6 |   TABLE SCAN       |t2      |100000   |64066 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), is_single, dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 170(end)  ************** 

***************   Case 171   ***************

SQL: explain select * from t1; 

=================================
|ID|OPERATOR|NAME|EST. ROWS|COST|
---------------------------------
|0 |VALUES  |    |0        |0   |
=================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil)

*************** Case 171(end)  ************** 

***************   Case 172   ***************

SQL: explain format = json select * from t1; 

=================================
|ID|OPERATOR|NAME|EST. ROWS|COST|
---------------------------------
|0 |VALUES  |    |0        |0   |
=================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil)

*************** Case 172(end)  ************** 

***************   Case 173   ***************

SQL: select sum(c1) from t1 where c1 = 3 group by c2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil)
  1 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil)
  2 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 173(end)  ************** 

***************   Case 174   ***************

SQL: select sum(1) as c from t1 where c1 = 3 group by c2 having c2 = 5 order by c1 limit 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t1  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil)
  2 - output([?]), filter([t1.c2 = ?]), 
      access([t1.c2]), partitions(p3), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 174(end)  ************** 

***************   Case 175   ***************

SQL: select sum(t7.c2) from t7, t8  where t7.c1 = t8.c1 and t7.c2 = 4 group by t7.c1 order by t7.c1 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |144 |
|1 | NESTED-LOOP JOIN|    |1        |144 |
|2 |  TABLE SCAN     |t7  |1        |107 |
|3 |  TABLE GET      |t8  |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t7.c2, DECIMAL(11, 0))]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  2 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 175(end)  ************** 

***************   Case 176   ***************

SQL: select c1, sum(c1+c2) from t2_no_part where c3 > 100 group by c2, c1; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t2_no_part|1        |109 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_no_part.c1], [cast(t2_no_part.c1 + t2_no_part.c2, DECIMAL(12, 0))]), filter([t2_no_part.c3 > ?]), 
      access([t2_no_part.c3], [t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 176(end)  ************** 

***************   Case 177   ***************

SQL: select * from t2_no_part X, t2_no_part Y where X.c1 = Y.c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|X   |100      |92  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c3], [X.c1], [X.c2], [X.c3]), filter(nil), 
      access([X.c1], [X.c2], [X.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([X.c1]), range(MIN ; MAX)always true

*************** Case 177(end)  ************** 

***************   Case 178   ***************

SQL: select count(*) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |52  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil)
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 178(end)  ************** 

***************   Case 179   ***************

SQL: select sum(c2) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  1 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  2 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 179(end)  ************** 

***************   Case 180   ***************

SQL: select sum(c1) + count(c2) from t2_no_part; 

==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |SCALAR GROUP BY|          |1        |115 |
|1 | TABLE SCAN    |t2_no_part|100      |90  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1) + T_FUN_COUNT(t2_no_part.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2_no_part.c1)], [T_FUN_COUNT(t2_no_part.c2)])
  1 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 180(end)  ************** 

***************   Case 181   ***************

SQL: select sum(c1) from t2_no_part group by c2 order by sum(c1); 

=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |SORT          |          |100      |383 |
|1 | HASH GROUP BY|          |100      |200 |
|2 |  TABLE SCAN  |t2_no_part|100      |90  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), sort_keys([T_FUN_SUM(t2_no_part.c1), ASC])
  1 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), 
      group([t2_no_part.c2]), agg_func([T_FUN_SUM(t2_no_part.c1)])
  2 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 181(end)  ************** 

***************   Case 182   ***************

SQL: select * from t4 where c2 = 3 and c3 = 4; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|100      |92  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3], [t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(3,4,MIN ; 3,4,MAX), 
      range_cond([t4.c2 = ?], [t4.c3 = ?])

*************** Case 182(end)  ************** 

***************   Case 183   ***************

SQL: select * from t4 where c1 = 2 and c2 = 3; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[2,3 ; 2,3], 
      range_cond([t4.c1 = ?], [t4.c2 = ?])

*************** Case 183(end)  ************** 

***************   Case 184   ***************

SQL: select * from t4, t7 where t4.c1 + 2 + 2 = t7.c1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |416 |
|1 | TABLE SCAN|t7  |100      |90  |
|2 | TABLE SCAN|t4  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 + ? + ? = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3], [t4.c1 + ? + ?]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 184(end)  ************** 

***************   Case 185   ***************

SQL: select sum(c1 + 1) from t4 group by c1, c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |54  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t4.c1 + ?, DECIMAL(12, 0))]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 185(end)  ************** 

***************   Case 186   ***************

SQL: select /*+ frozen_version(10) */ * from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      hint(frozen_version:"10-0-0", read_consistency:1), 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 186(end)  ************** 

***************   Case 187   ***************

SQL: select /*+index(t4 idx_t4_c2_c3)*/ c2, c3 from t4 where c2 = 3 and c3 = 4 and c1 = 5; 

==============================================
|ID|OPERATOR |NAME            |EST. ROWS|COST|
----------------------------------------------
|0 |TABLE GET|t4(idx_t4_c2_c3)|1        |53  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range[3,4,5 ; 3,4,5], 
      range_cond([t4.c2 = ?], [t4.c3 = ?], [t4.c1 = ?])

*************** Case 187(end)  ************** 

***************   Case 188   ***************

SQL: select * from t4 where c1 = 1 and c2 > 5 and c3 > 8; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |61       |109 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c3 > ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(1,5 ; 1,MAX), 
      range_cond([t4.c1 = ?], [t4.c2 > ?])

*************** Case 188(end)  ************** 

***************   Case 189   ***************

SQL: select * from t4 where c1 in (1) and c2 in (1, 2, 3, 4, 5); 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |5        |73  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[1,1 ; 1,1], [1,2 ; 1,2], [1,3 ; 1,3], [1,4 ; 1,4], [1,5 ; 1,5], 
      range_cond([t4.c1 = ?], [t4.c2 IN (?, ?, ?, ?, ?)])

*************** Case 189(end)  ************** 

***************   Case 190   ***************

SQL: select * from t1 where c1 in (c1, 2, 3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |431 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |384 |
|2 |  PX PARTITION ITERATOR|        |500      |384 |
|3 |   TABLE SCAN          |t1      |500      |384 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 IN (t1.c1, ?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 190(end)  ************** 

***************   Case 191   ***************

SQL: select * from t1 where (1+ 1) in (2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 191(end)  ************** 

***************   Case 192   ***************

SQL: select * from t1 where 1 in (c1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])

*************** Case 192(end)  ************** 

***************   Case 193   ***************

SQL: select * from t1 where 1 in (c1, c2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |384 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |384 |
|2 |  PX PARTITION ITERATOR|        |6        |384 |
|3 |   TABLE SCAN          |t1      |6        |384 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([? IN (t1.c1, t1.c2)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 193(end)  ************** 

***************   Case 194   ***************

SQL: select * from t1 where c1 = 1 or c2 = 1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |384 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |384 |
|2 |  PX PARTITION ITERATOR|        |6        |384 |
|3 |   TABLE SCAN          |t1      |6        |384 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = ? OR t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 194(end)  ************** 

***************   Case 195   ***************

SQL: select * from t1 where (1+ 1) in (1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 195(end)  ************** 

***************   Case 196   ***************

SQL: select * from t1 where c1 in (1, 2, 3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |4        |68  |
|1 | EXCHANGE OUT DISTR    |:EX10000|4        |68  |
|2 |  PX PARTITION ITERATOR|        |4        |68  |
|3 |   TABLE GET           |t1      |4        |68  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[1-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], [2 ; 2], [3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?, ?, ?)])

*************** Case 196(end)  ************** 

***************   Case 197   ***************

SQL: select * from t1 where exists (select * from t2 limit 0); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SUBPLAN FILTER           |        |250      |458 |
|1 | PX COORDINATOR          |        |500      |389 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|500      |342 |
|3 |   PX PARTITION ITERATOR |        |500      |342 |
|4 |    TABLE SCAN           |t1      |500      |342 |
|5 | LIMIT                   |        |0        |0   |
|6 |  PX COORDINATOR         |        |0        |0   |
|7 |   EXCHANGE OUT DISTR    |:EX20000|0        |0   |
|8 |    PX PARTITION ITERATOR|        |0        |0   |
|9 |     TABLE SCAN          |t2      |0        |0   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), limit(0), offset(nil)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), dop=1
  8 - output([1]), filter(nil), 
      force partition granule, asc.
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(0), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 197(end)  ************** 

***************   Case 198   ***************

SQL: select * from t7,t8 where t7.c1=t8.c1 order by t7.c1,t7.c2; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |267 |
|1 | TABLE SCAN|t7  |100      |90  |
|2 | TABLE SCAN|t8  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 198(end)  ************** 

***************   Case 199   ***************

SQL: select * from t7,t8 where t7.c1=t8.c2 order by t7.c1,t7.c2; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |394 |
|1 | TABLE SCAN |t7  |100      |90  |
|2 | SORT       |    |100      |217 |
|3 |  TABLE SCAN|t8  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c2]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  3 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 199(end)  ************** 

***************   Case 200   ***************

SQL: select c1/c2 as v,sum(c1) from t1 group by v order by v; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |500      |1723|
|1 | EXCHANGE OUT DISTR           |:EX10001|500      |1676|
|2 |  MERGE GROUP BY              |        |500      |1676|
|3 |   SORT                       |        |500      |1497|
|4 |    EXCHANGE IN DISTR         |        |500      |389 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|500      |342 |
|6 |      PX PARTITION ITERATOR   |        |500      |342 |
|7 |       TABLE SCAN             |t1      |500      |342 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 / t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c1 / t1.c2, ASC])
  1 - output([T_FUN_SUM(t1.c1)], [t1.c1 / t1.c2]), filter(nil), dop=1
  2 - output([T_FUN_SUM(t1.c1)], [t1.c1 / t1.c2]), filter(nil), 
      group([t1.c1 / t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil), sort_keys([t1.c1 / t1.c2, ASC])
  4 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil)
  5 - (#keys=1, [t1.c1 / t1.c2]), output([t1.c1], [t1.c1 / t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c1 / t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 200(end)  ************** 

***************   Case 201   ***************

SQL: select c2 from t1 for update; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 201(end)  ************** 

***************   Case 202   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1) for update; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1424|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1325|
|2 |  MERGE JOIN                   |        |300      |1325|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t6      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1]), filter(nil), dop=1
  8 - output([t6.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 202(end)  ************** 

***************   Case 203   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4 order by c3, c2; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |100      |183 |
|1 | TABLE SCAN|t4(idx_t4_c3)|100      |92  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), sort_keys([t4.c3, ASC], [t4.c2, ASC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c3], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c3], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 203(end)  ************** 

***************   Case 204   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4, t9 where t4.c1 = t9.c1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t4  |100      |90  |
|2 | TABLE SCAN|t9  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), 
      equal_conds([t4.c1 = t9.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t9.c1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 204(end)  ************** 

***************   Case 205   ***************

SQL: select * from t4 where t4.c1 = 1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |100      |92  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 205(end)  ************** 

***************   Case 206   ***************

SQL: select * from t7 group by c1 order by c1 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|100      |90  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 206(end)  ************** 

***************   Case 207   ***************

SQL: select * from t4 order by c1,c2 desc; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |100      |183 |
|1 | TABLE SCAN|t4  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC], [t4.c2, DESC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 207(end)  ************** 

***************   Case 208   ***************

SQL: select * from t4 order by c1 desc,c2 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t4(Reverse)|100      |92  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 208(end)  ************** 

***************   Case 209   ***************

SQL: select * from t1 order by c1 limit 2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |2        |39  |
|1 | PX COORDINATOR MERGE SORT |        |2        |38  |
|2 |  EXCHANGE OUT DISTR       |:EX10000|2        |38  |
|3 |   SORT                    |        |2        |38  |
|4 |    PX PARTITION ITERATOR  |        |2        |37  |
|5 |     TABLE SCAN            |t1      |2        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 209(end)  ************** 

***************   Case 210   ***************

SQL: select * from t1 order by c2 limit 2; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |2        |39  |
|1 | PX COORDINATOR MERGE SORT |             |2        |38  |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |2        |38  |
|3 |   SORT                    |             |2        |38  |
|4 |    PX PARTITION ITERATOR  |             |2        |37  |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|2        |37  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 210(end)  ************** 

***************   Case 211   ***************

SQL: select * from t2 order by c1 limit 2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |2        |41  |
|1 | PX COORDINATOR MERGE SORT |        |2        |40  |
|2 |  EXCHANGE OUT DISTR       |:EX10000|2        |40  |
|3 |   SORT                    |        |2        |40  |
|4 |    PX PARTITION ITERATOR  |        |2        |37  |
|5 |     TABLE SCAN            |t2      |2        |37  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(2), offset(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 211(end)  ************** 

***************   Case 212   ***************

SQL: select * from t2 order by c2 limit 2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |2        |439 |
|1 | PX COORDINATOR MERGE SORT |        |2        |439 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|2        |438 |
|3 |   LIMIT                   |        |2        |438 |
|4 |    TOP-N SORT             |        |2        |438 |
|5 |     PX PARTITION ITERATOR |        |300      |205 |
|6 |      TABLE SCAN           |t2      |300      |205 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(2), offset(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, ASC])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(2), offset(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 212(end)  ************** 

***************   Case 213   ***************

SQL: select * from (select * from t4 union select * from t4) as a; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |200      |271 |
|1 | TABLE SCAN         |t4  |100      |92  |
|2 | TABLE SCAN         |t4  |100      |92  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 213(end)  ************** 

***************   Case 214   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t2.c1=2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1386|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1196|
|2 |  MERGE OUTER JOIN           |        |500      |1196|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |t1      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |1        |53  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |53  |
|8 |     TABLE GET               |t2      |1        |53  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), is_single, dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 214(end)  ************** 

***************   Case 215   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1=2; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |106 |
|1 | EXCHANGE OUT REMOTE        |    |1        |105 |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|3 |   TABLE GET                |t1  |1        |52  |
|4 |   TABLE GET                |t2  |1        |53  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 215(end)  ************** 

***************   Case 216   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 and t2.c1=2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1066|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |953 |
|2 |  MERGE OUTER JOIN           |        |300      |953 |
|3 |   SORT                      |        |300      |859 |
|4 |    PX PARTITION ITERATOR    |        |300      |205 |
|5 |     TABLE SCAN              |t2      |300      |205 |
|6 |   EXCHANGE IN DISTR         |        |1        |53  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |52  |
|8 |     TABLE GET               |t1      |1        |52  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t2.c1 = ?])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 216(end)  ************** 

***************   Case 217   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 where t2.c1=2; 

=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |EXCHANGE IN REMOTE      |    |1        |106 |
|1 | EXCHANGE OUT REMOTE    |    |1        |105 |
|2 |  NESTED-LOOP OUTER JOIN|    |1        |105 |
|3 |   TABLE GET            |t2  |1        |53  |
|4 |   TABLE GET            |t1  |1        |52  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=true
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?], [t1.c1 = ?])

*************** Case 217(end)  ************** 

***************   Case 218   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 and t2.c1=2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |1623|
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |1434|
|2 |  MERGE FULL OUTER JOIN        |        |500      |1434|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t2.c1 = ?])
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 218(end)  ************** 

***************   Case 219   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 where t2.c1=2; 

=================================================
|ID|OPERATOR                |NAME|EST. ROWS|COST|
-------------------------------------------------
|0 |EXCHANGE IN REMOTE      |    |1        |106 |
|1 | EXCHANGE OUT REMOTE    |    |1        |105 |
|2 |  NESTED-LOOP OUTER JOIN|    |1        |105 |
|3 |   TABLE GET            |t2  |1        |53  |
|4 |   TABLE GET            |t1  |1        |52  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=true
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?], [t1.c1 = ?])

*************** Case 219(end)  ************** 

***************   Case 220   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1=t2.c1 limit 1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1610|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1568|
|2 |  MERGE JOIN                   |        |300      |1568|
|3 |   SORT                        |        |500      |1074|
|4 |    PX PARTITION ITERATOR      |        |500      |342 |
|5 |     TABLE SCAN                |t1      |500      |342 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 220(end)  ************** 

***************   Case 221   ***************

SQL: select c1 from (select c1, c2 from t1 limit 1) t; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |1        |37  |
|1 | PX COORDINATOR         |        |1        |36  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|3 |   PX PARTITION ITERATOR|        |1        |36  |
|4 |    TABLE SCAN          |t1      |1        |36  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 221(end)  ************** 

***************   Case 222   ***************

SQL: select sum(c) from (select c1 as c from t1 union select c1 as c from t1) as a; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |1510|
|1 | PX COORDINATOR           |        |1        |1319|
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |1319|
|3 |   MERGE GROUP BY         |        |1        |1319|
|4 |    SUBPLAN SCAN          |a       |1000     |1128|
|5 |     PX PARTITION ITERATOR|        |1000     |990 |
|6 |      MERGE UNION DISTINCT|        |1000     |990 |
|7 |       TABLE SCAN         |t1      |500      |331 |
|8 |       TABLE SCAN         |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(a.c))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(a.c))])
  1 - output([T_FUN_SUM(a.c)]), filter(nil)
  2 - output([T_FUN_SUM(a.c)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  4 - output([a.c]), filter(nil), 
      access([a.c])
  5 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule, asc.
  6 - output([UNION([1])]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 222(end)  ************** 

***************   Case 223   ***************

SQL: select * from t2 where 'cb' <= c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |3        |346 |
|1 | EXCHANGE OUT DISTR    |:EX10000|3        |345 |
|2 |  PX PARTITION ITERATOR|        |3        |345 |
|3 |   TABLE SCAN          |t2      |3        |345 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter([? <= t2.c3]), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 223(end)  ************** 

***************   Case 224   ***************

SQL: select t7.c1 = t8.c2 from t7, t8 where t7.c1 = t8.c1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t7  |100      |88  |
|2 | TABLE SCAN|t8  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1 = t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 224(end)  ************** 

***************   Case 225   ***************

SQL: select t11.c2 from (select c1,c2 from t4 limit 1) as t11 , t6 where t11.c1>t6.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |100      |203 |
|1 | EXCHANGE OUT DISTR             |:EX10001|100      |189 |
|2 |  NESTED-LOOP JOIN              |        |100      |189 |
|3 |   EXCHANGE IN DISTR            |        |1        |37  |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|1        |37  |
|5 |     SUBPLAN SCAN               |t11     |1        |37  |
|6 |      TABLE SCAN                |t4      |1        |36  |
|7 |   PX PARTITION ITERATOR        |        |100      |88  |
|8 |    TABLE SCAN                  |t6      |100      |88  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t11.c2]), filter(nil)
  1 - output([t11.c2]), filter(nil), dop=1
  2 - output([t11.c2]), filter(nil), 
      conds(nil), nl_params_([t11.c1]), batch_join=false
  3 - output([t11.c1], [t11.c2]), filter(nil)
  4 - output([t11.c1], [t11.c2]), filter(nil), is_single, dop=1
  5 - output([t11.c1], [t11.c2]), filter(nil), 
      access([t11.c1], [t11.c2])
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([1]), filter(nil), 
      access all, force partition granule, asc.
  8 - output([1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX), 
      range_cond([? > t6.c1])

*************** Case 225(end)  ************** 

***************   Case 226   ***************

SQL: select t11.c2 from (select c1,c2 from t4) t11 left join t6 on t11.c1=1; 

============================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST |
------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |             |300      |11440|
|1 | TABLE SCAN              |t4(idx_t4_c2)|100      |54   |
|2 | MATERIAL                |             |300      |261  |
|3 |  PX COORDINATOR         |             |300      |206  |
|4 |   EXCHANGE OUT DISTR    |:EX10000     |300      |192  |
|5 |    PX PARTITION ITERATOR|             |300      |192  |
|6 |     TABLE SCAN          |t6           |300      |192  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      conds([t4.c1 = ?]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), dop=1
  5 - output([1]), filter(nil), 
      force partition granule, asc.
  6 - output([1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 226(end)  ************** 

***************   Case 227   ***************

SQL: select * from t2,t4 where t2.c1=t4.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1122|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1079|
|2 |  MERGE JOIN                 |        |100      |1079|
|3 |   SORT                      |        |300      |859 |
|4 |    PX PARTITION ITERATOR    |        |300      |205 |
|5 |     TABLE SCAN              |t2      |300      |205 |
|6 |   EXCHANGE IN DISTR         |        |100      |107 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |92  |
|8 |     TABLE SCAN              |t4      |100      |92  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 227(end)  ************** 

***************   Case 228   ***************

SQL: select * from t2,t6 where t2.c1=t6.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1459|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1346|
|2 |  MERGE JOIN                   |        |300      |1346|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |227 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |198 |
|8 |     PX PARTITION ITERATOR     |        |300      |198 |
|9 |      TABLE SCAN               |t6      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2]), filter(nil), dop=1
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 228(end)  ************** 

***************   Case 229   ***************

SQL: select * from t2,t6,t7 where t2.c1=t6.c1 and t6.c1=t7.c1; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR                   |        |100      |1945|
|1 | EXCHANGE OUT DISTR              |:EX10002|100      |1898|
|2 |  MERGE JOIN                     |        |100      |1898|
|3 |   EXCHANGE IN MERGE SORT DISTR  |        |100      |925 |
|4 |    EXCHANGE OUT DISTR (PKEY)    |:EX10001|100      |906 |
|5 |     MATERIAL                    |        |100      |906 |
|6 |      MERGE JOIN                 |        |100      |833 |
|7 |       SORT                      |        |300      |619 |
|8 |        PX PARTITION ITERATOR    |        |300      |198 |
|9 |         TABLE SCAN              |t6      |300      |198 |
|10|       EXCHANGE IN DISTR         |        |100      |100 |
|11|        EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|12|         TABLE SCAN              |t7      |100      |90  |
|13|   SORT                          |        |300      |859 |
|14|    PX PARTITION ITERATOR        |        |300      |205 |
|15|     TABLE SCAN                  |t2      |300      |205 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), sort_keys([t6.c1, ASC])
  4 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil)
  6 - output([t6.c1], [t6.c2], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t6.c1 = t7.c1]), other_conds(nil)
  7 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  10 - output([t7.c1], [t7.c2]), filter(nil)
  11 - (#keys=1, [t7.c1]), output([t7.c1], [t7.c2]), filter(nil), is_single, dop=1
  12 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  14 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 229(end)  ************** 

***************   Case 230   ***************

SQL: select c1 from t2 union select c1 from t6; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |600      |985 |
|1 | EXCHANGE OUT DISTR            |:EX10001|600      |957 |
|2 |  MERGE UNION DISTINCT         |        |600      |957 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|5 |     PX PARTITION ITERATOR     |        |300      |192 |
|6 |      TABLE SCAN               |t2      |300      |192 |
|7 |   SORT                        |        |300      |554 |
|8 |    PX PARTITION ITERATOR      |        |300      |192 |
|9 |     TABLE SCAN                |t6      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t6.c1]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  8 - output([t6.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 230(end)  ************** 

***************   Case 231   ***************

SQL: select c1 from t2 union all select c1 from t6; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |600      |608 |
|1 | EXCHANGE OUT DISTR    |:EX10000|600      |580 |
|2 |  PX PARTITION ITERATOR|        |600      |580 |
|3 |   UNION ALL           |        |600      |580 |
|4 |    TABLE SCAN         |t2      |300      |192 |
|5 |    TABLE SCAN         |t6      |300      |192 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([UNION([1])]), filter(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 231(end)  ************** 

***************   Case 232   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1424|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1325|
|2 |  MERGE JOIN                   |        |300      |1325|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t6      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1]), filter(nil), dop=1
  8 - output([t6.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 232(end)  ************** 

***************   Case 233   ***************

SQL: select * from t2 where exists (select * from t4 where t2.c1=t4.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |101      |1096|
|1 | EXCHANGE OUT DISTR          |:EX10001|101      |1068|
|2 |  MERGE SEMI JOIN            |        |101      |1068|
|3 |   SORT                      |        |300      |859 |
|4 |    PX PARTITION ITERATOR    |        |300      |205 |
|5 |     TABLE SCAN              |t2      |300      |205 |
|6 |   EXCHANGE IN DISTR         |        |100      |95  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|8 |     TABLE SCAN              |t4      |100      |90  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t4.c1]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 233(end)  ************** 

***************   Case 234   ***************

SQL: select * from t2 where exists (select * from t1 where t2.c1=t1.c1 limit 1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1600|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1501|
|2 |  MERGE JOIN                   |        |300      |1501|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |354 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |331 |
|8 |     PX PARTITION ITERATOR     |        |500      |331 |
|9 |      TABLE SCAN               |t1      |500      |331 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 234(end)  ************** 

***************   Case 235   ***************

SQL: select sum(c1) as c from t1 union select sum(c1) as c from t1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |MERGE UNION DISTINCT      |        |2        |1044|
|1 | SCALAR GROUP BY          |        |1        |522 |
|2 |  PX COORDINATOR          |        |1        |426 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|4 |    MERGE GROUP BY        |        |1        |426 |
|5 |     PX PARTITION ITERATOR|        |500      |331 |
|6 |      TABLE SCAN          |t1      |500      |331 |
|7 | SCALAR GROUP BY          |        |1        |522 |
|8 |  PX COORDINATOR          |        |1        |426 |
|9 |   EXCHANGE OUT DISTR     |:EX20000|1        |426 |
|10|    MERGE GROUP BY        |        |1        |426 |
|11|     PX PARTITION ITERATOR|        |500      |331 |
|12|      TABLE SCAN          |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  8 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  9 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  10 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  11 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 235(end)  ************** 

***************   Case 236   ***************

SQL: select sum(c) from (select sum(c1) as c from t1 union select sum(c1) as c from t1) as a; 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |SCALAR GROUP BY             |        |1        |1044|
|1 | SUBPLAN SCAN               |a       |2        |1044|
|2 |  MERGE UNION DISTINCT      |        |2        |1044|
|3 |   SCALAR GROUP BY          |        |1        |522 |
|4 |    PX COORDINATOR          |        |1        |426 |
|5 |     EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|6 |      MERGE GROUP BY        |        |1        |426 |
|7 |       PX PARTITION ITERATOR|        |500      |331 |
|8 |        TABLE SCAN          |t1      |500      |331 |
|9 |   SCALAR GROUP BY          |        |1        |522 |
|10|    PX COORDINATOR          |        |1        |426 |
|11|     EXCHANGE OUT DISTR     |:EX20000|1        |426 |
|12|      MERGE GROUP BY        |        |1        |426 |
|13|       PX PARTITION ITERATOR|        |500      |331 |
|14|        TABLE SCAN          |t1      |500      |331 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  1 - output([a.c]), filter(nil), 
      access([a.c])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  5 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  6 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  10 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  11 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  12 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  13 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  14 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 236(end)  ************** 

***************   Case 237   ***************

SQL: select * from t4 where c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |99       |101 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 237(end)  ************** 

***************   Case 238   ***************

SQL: select/*+index(t4 primary)*/ * from t4 where c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |99       |101 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 238(end)  ************** 

***************   Case 239   ***************

SQL: select * from t4, t4 t where t4.c1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |9900     |7460|
|1 | TABLE SCAN               |t   |100      |92  |
|2 | MATERIAL                 |    |99       |155 |
|3 |  TABLE SCAN              |t4  |99       |101 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t.c1], [t.c2], [t.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1], [t.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 239(end)  ************** 

***************   Case 240   ***************

SQL: select/*+index(t4 primary)*/ * from t4, t4 t where t4.c1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |9900     |7460|
|1 | TABLE SCAN               |t   |100      |92  |
|2 | MATERIAL                 |    |99       |155 |
|3 |  TABLE SCAN              |t4  |99       |101 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t.c1], [t.c2], [t.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1], [t.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 240(end)  ************** 

***************   Case 241   ***************

SQL: select * from t4 left join t4 a on t4.c1; 

===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |9900     |8311|
|1 | TABLE SCAN           |t4  |100      |92  |
|2 | MATERIAL             |    |100      |148 |
|3 |  TABLE SCAN          |a   |100      |92  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      conds([t4.c1]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([a.c1], [a.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 241(end)  ************** 

***************   Case 242   ***************

SQL: select t1.c2  from t1,t2 where t2.c1 in(t1.c1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1610|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1568|
|2 |  MERGE JOIN                   |        |300      |1568|
|3 |   SORT                        |        |500      |1074|
|4 |    PX PARTITION ITERATOR      |        |500      |342 |
|5 |     TABLE SCAN                |t1      |500      |342 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 242(end)  ************** 

***************   Case 243   ***************

SQL: select  * from t3 join t4 on t3.c1>t4.c1 where t4.c1 in (t3.c1, t3.c1); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |67       |3809|
|1 | EXCHANGE OUT DISTR             |:EX10001|67       |3780|
|2 |  NESTED-LOOP JOIN              |        |67       |3780|
|3 |   EXCHANGE IN DISTR            |        |100      |107 |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|100      |92  |
|5 |     TABLE SCAN                 |t4      |100      |92  |
|6 |   PX PARTITION ITERATOR        |        |1        |36  |
|7 |    TABLE GET                   |t3      |1        |36  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil)
  1 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), dop=1
  2 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access all, force partition granule, asc.
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 > ?], [? IN (t3.c1, t3.c1)])

*************** Case 243(end)  ************** 

***************   Case 244   ***************

SQL: select * from t1 where c1 in (select t2.c1 from t2 left join t3 on t2.c1=t3.c1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1610|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1568|
|2 |  MERGE JOIN                   |        |300      |1568|
|3 |   SORT                        |        |500      |1074|
|4 |    PX PARTITION ITERATOR      |        |500      |342 |
|5 |     TABLE SCAN                |t1      |500      |342 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 244(end)  ************** 

***************   Case 245   ***************

SQL: select /*+use_merge(t10,t11)*/* from t10, t11 where t10.c2=t11.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |361      |1288|
|1 | EXCHANGE OUT DISTR    |:EX10000|361      |1185|
|2 |  PX PARTITION ITERATOR|        |361      |1185|
|3 |   MERGE JOIN          |        |361      |1185|
|4 |    SORT               |        |200      |458 |
|5 |     TABLE SCAN        |t10     |200      |149 |
|6 |    SORT               |        |200      |458 |
|7 |     TABLE SCAN        |t11     |200      |149 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil)
  1 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), dop=1
  2 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      equal_conds([t10.c2 = t11.c2]), other_conds(nil)
  4 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), sort_keys([t10.c2, ASC])
  5 - output([t10.c2], [t10.c1], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c1], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), sort_keys([t11.c2, ASC])
  7 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil), 
      access([t11.c2], [t11.c1], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 245(end)  ************** 

***************   Case 246   ***************

SQL: select c1 from t1 where c1 not in (select c1 from t2 where c2 not in (select c2 from t2)); 

==============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST |
--------------------------------------------------------------
|0 |PX COORDINATOR                  |        |491      |28215|
|1 | EXCHANGE OUT DISTR             |:EX10003|491      |28192|
|2 |  MERGE ANTI JOIN               |        |491      |28192|
|3 |   SORT                         |        |500      |966  |
|4 |    PX PARTITION ITERATOR       |        |500      |331  |
|5 |     TABLE SCAN                 |t1      |500      |331  |
|6 |   SORT                         |        |10       |27151|
|7 |    EXCHANGE IN DISTR           |        |10       |27143|
|8 |     EXCHANGE OUT DISTR (PKEY)  |:EX10002|10       |27143|
|9 |      SUBPLAN SCAN              |VIEW2   |10       |27143|
|10|       NESTED-LOOP ANTI JOIN    |        |10       |27142|
|11|        MATERIAL                |        |300      |337  |
|12|         EXCHANGE IN DISTR      |        |300      |227  |
|13|          EXCHANGE OUT DISTR    |:EX10000|300      |198  |
|14|           PX PARTITION ITERATOR|        |300      |198  |
|15|            TABLE SCAN          |t2      |300      |198  |
|16|        MATERIAL                |        |300      |337  |
|17|         EXCHANGE IN DISTR      |        |300      |227  |
|18|          EXCHANGE OUT DISTR    |:EX10001|300      |198  |
|19|           PX PARTITION ITERATOR|        |300      |198  |
|20|            TABLE SCAN          |t2      |300      |198  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([VIEW2.c1]), filter(nil), sort_keys([VIEW2.c1, ASC])
  7 - output([VIEW2.c1]), filter(nil)
  8 - (#keys=1, [VIEW2.c1]), output([VIEW2.c1]), filter(nil), is_single, dop=1
  9 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  10 - output([t2.c1]), filter(nil), 
      conds([(T_OP_OR, t2.c2 = t2.c2, (T_OP_IS, t2.c2, NULL, 0), (T_OP_IS, t2.c2, NULL, 0))]), nl_params_(nil), batch_join=false
  11 - output([t2.c1], [t2.c2]), filter(nil)
  12 - output([t2.c1], [t2.c2]), filter(nil)
  13 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  14 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  16 - output([t2.c2]), filter(nil)
  17 - output([t2.c2]), filter(nil)
  18 - output([t2.c2]), filter(nil), dop=1
  19 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  20 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 246(end)  ************** 

***************   Case 247   ***************

SQL: select distinct c1 from t1 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500      |1122|
|1 | EXCHANGE OUT DISTR       |:EX10000     |500      |1074|
|2 |  SORT                    |             |500      |1074|
|3 |   PX PARTITION ITERATOR  |             |500      |342 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 247(end)  ************** 

***************   Case 248   ***************

SQL: SELECT c1, c2  FROM t1 WHERE c2 IN (ROUND(-1), 0, '5', '1'); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |2000     |1448|
|1 | EXCHANGE OUT DISTR    |:EX10000     |2000     |1258|
|2 |  PX PARTITION ITERATOR|             |2000     |1258|
|3 |   TABLE SCAN          |t1(idx_t1_c2)|2000     |1258|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(-1,MIN ; -1,MAX), (0,MIN ; 0,MAX), (5,MIN ; 5,MAX), (1,MIN ; 1,MAX), 
      range_cond([t1.c2 IN (?, ?, ?, ?)])

*************** Case 248(end)  ************** 

***************   Case 249   ***************

SQL: select count(*) from (select count(*) as a  from t4) t ; 

===================================================
|ID|OPERATOR         |NAME         |EST. ROWS|COST|
---------------------------------------------------
|0 |SCALAR GROUP BY  |             |1        |74  |
|1 | SUBPLAN SCAN    |t            |1        |74  |
|2 |  SCALAR GROUP BY|             |1        |74  |
|3 |   TABLE SCAN    |t4(idx_t4_c2)|100      |54  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil), 
      access(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output([1]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 249(end)  ************** 

***************   Case 250   ***************

SQL: (select * from t1 where c1 = 2) union all (select * from t1 where c1 = 2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |105 |
|1 | EXCHANGE OUT REMOTE|    |2        |105 |
|2 |  UNION ALL         |    |2        |105 |
|3 |   TABLE GET        |t1  |1        |52  |
|4 |   TABLE GET        |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 250(end)  ************** 

***************   Case 251   ***************

SQL: select * from t1 X, t1 Y where X.c1 = Y.c1 and X.c1 = 1 and Y.c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |X   |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c1], [X.c2]), filter(nil)
  1 - output([X.c1], [X.c2]), filter(nil)
  2 - output([X.c1], [X.c2]), filter(nil), 
      access([X.c1], [X.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([X.c1]), range[1 ; 1], 
      range_cond([X.c1 = ?], [X.c1 = ?])

*************** Case 251(end)  ************** 

***************   Case 252   ***************

SQL: select distinct c2, c1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t1.c1]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 252(end)  ************** 

***************   Case 253   ***************

SQL: select (select c1 from t7),c2 from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |192 |
|1 | TABLE SCAN   |t8  |100      |90  |
|2 | TABLE SCAN   |t7  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 253(end)  ************** 

***************   Case 254   ***************

SQL: select (select c1 from t7 where c2=t8.c2), c2 from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |9926|
|1 | TABLE SCAN   |t8  |100      |90  |
|2 | TABLE SCAN   |t7  |1        |99  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([subquery(1)], [t8.c2]), filter(nil), 
      exec_params_([t8.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 254(end)  ************** 

***************   Case 255   ***************

SQL: select c1 from t7 group by (select c1 from t8), c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |100      |296 |
|1 | SUBPLAN FILTER|    |100      |192 |
|2 |  TABLE SCAN   |t7  |100      |90  |
|3 |  TABLE SCAN   |t8  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 255(end)  ************** 

***************   Case 256   ***************

SQL: select c1 from t7 group by (select c1 from t8 where c2=t7.c2),c2; 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |HASH GROUP BY  |    |100      |10036|
|1 | SUBPLAN FILTER|    |100      |9926 |
|2 |  TABLE SCAN   |t7  |100      |90   |
|3 |  TABLE SCAN   |t8  |1        |99   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([subquery(1)], [t7.c2]), agg_func(nil)
  1 - output([t7.c1], [subquery(1)], [t7.c2]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 256(end)  ************** 

***************   Case 257   ***************

SQL: select c1, sum(c2) from t4 group by c1 having sum(c2) < (select 1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |5        |118 |
|1 | TABLE SCAN   |t4  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [T_FUN_SUM(t4.c2)]), filter([T_FUN_SUM(t4.c2) < ?]), 
      group([t4.c1]), agg_func([T_FUN_SUM(t4.c2)])
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 257(end)  ************** 

***************   Case 258   ***************

SQL: select c1 from t7 order by (select c1 from t8), c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SORT           |    |100      |319 |
|1 | SUBPLAN FILTER|    |100      |192 |
|2 |  TABLE SCAN   |t7  |100      |90  |
|3 |  TABLE SCAN   |t8  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 258(end)  ************** 

***************   Case 259   ***************

SQL: select c1 from t7 order by (select c1 from t8 where c2=t7.c2),c2; 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SORT           |    |100      |10053|
|1 | SUBPLAN FILTER|    |100      |9926 |
|2 |  TABLE SCAN   |t7  |100      |90   |
|3 |  TABLE SCAN   |t8  |1        |99   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([subquery(1), ASC], [t7.c2, ASC])
  1 - output([t7.c1], [subquery(1)], [t7.c2]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 259(end)  ************** 

***************   Case 260   ***************

SQL: select (select 1, 2, 3)=row(1, 2, 3); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) = (?, ?, ?)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?], [?], [?]), filter(nil)
      values({?, ?, ?})

*************** Case 260(end)  ************** 

***************   Case 261   ***************

SQL: select count(1) from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |522 |
|1 | PX COORDINATOR          |        |1        |426 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|3 |   MERGE GROUP BY        |        |1        |426 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  1 - output([T_FUN_COUNT(?)]), filter(nil)
  2 - output([T_FUN_COUNT(?)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 261(end)  ************** 

***************   Case 262   ***************

SQL: select (select 1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 262(end)  ************** 

***************   Case 263   ***************

SQL: (select (select 1)) union (select (select 1)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 263(end)  ************** 

***************   Case 264   ***************

SQL: SELECT distinct '' , 1 FROM DUAL limit 2 offset 1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |LIMIT      |    |0        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(2), offset(?)
  1 - output([1]), filter(nil)
      values({1})

*************** Case 264(end)  ************** 

***************   Case 265   ***************

SQL: select * from t1,t1 t; 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |250000   |180482|
|1 | PX COORDINATOR           |        |500      |389   |
|2 |  EXCHANGE OUT DISTR      |:EX10000|500      |342   |
|3 |   PX PARTITION ITERATOR  |        |500      |342   |
|4 |    TABLE SCAN            |t1      |500      |342   |
|5 | MATERIAL                 |        |500      |573   |
|6 |  PX COORDINATOR          |        |500      |389   |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |342   |
|8 |    PX PARTITION ITERATOR |        |500      |342   |
|9 |     TABLE SCAN           |t       |500      |342   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t.c1], [t.c2]), filter(nil)
  6 - output([t.c1], [t.c2]), filter(nil)
  7 - output([t.c1], [t.c2]), filter(nil), dop=1
  8 - output([t.c1], [t.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 265(end)  ************** 

***************   Case 266   ***************

SQL: select * from t1,t1 t where t1.c1<t.c1; 

===============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST  |
---------------------------------------------------------------
|0 |PX COORDINATOR                  |        |83334    |138980|
|1 | EXCHANGE OUT DISTR             |:EX10001|83334    |123203|
|2 |  NESTED-LOOP JOIN              |        |83334    |123203|
|3 |   EXCHANGE IN DISTR            |        |500      |389   |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|500      |342   |
|5 |     PX PARTITION ITERATOR      |        |500      |342   |
|6 |      TABLE SCAN                |t1      |500      |342   |
|7 |   PX PARTITION ITERATOR        |        |167      |138   |
|8 |    TABLE SCAN                  |t       |167      |138   |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t.c1], [t.c2]), filter(nil), 
      access all, force partition granule, asc.
  8 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX), 
      range_cond([? < t.c1])

*************** Case 266(end)  ************** 

***************   Case 267   ***************

SQL: (select * from t4) union (select * from t4) order by (select c1 from t4 limit 1); 

==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |SUBPLAN FILTER       |    |200      |335 |
|1 | MERGE UNION DISTINCT|    |200      |271 |
|2 |  TABLE SCAN         |t4  |100      |92  |
|3 |  TABLE SCAN         |t4  |100      |92  |
|4 | TABLE SCAN          |t4  |1        |36  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  4 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 267(end)  ************** 

***************   Case 268   ***************

SQL: select 1 from dual where 1 in (select 1 from dual); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter([?])
      values({?})

*************** Case 268(end)  ************** 

***************   Case 269   ***************

SQL: select count(c1) + 1 from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |522 |
|1 | PX COORDINATOR          |        |1        |426 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|3 |   MERGE GROUP BY        |        |1        |426 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 269(end)  ************** 

***************   Case 270   ***************

SQL: select count(c1) + 1 + 1 from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |522 |
|1 | PX COORDINATOR          |        |1        |426 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|3 |   MERGE GROUP BY        |        |1        |426 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ? + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 270(end)  ************** 

***************   Case 271   ***************

SQL: SELECT (select max(t1.c1) from t1) as field from t1 group by field; 

================================================================
|ID|OPERATOR                        |NAME       |EST. ROWS|COST|
----------------------------------------------------------------
|0 |HASH GROUP BY                   |           |1        |880 |
|1 | NESTED-LOOP JOIN CARTESIAN     |           |500      |715 |
|2 |  SUBPLAN SCAN                  |VIEW4      |1        |38  |
|3 |   SCALAR GROUP BY              |           |1        |37  |
|4 |    SUBPLAN SCAN                |VIEW5      |1        |37  |
|5 |     LIMIT                      |           |1        |37  |
|6 |      PX COORDINATOR MERGE SORT |           |1        |37  |
|7 |       EXCHANGE OUT DISTR       |:EX10000   |1        |37  |
|8 |        SORT                    |           |1        |37  |
|9 |         PX PARTITION ITERATOR  |           |1        |36  |
|10|          TABLE SCAN            |t1(Reverse)|1        |36  |
|11|  PX COORDINATOR                |           |500      |354 |
|12|   EXCHANGE OUT DISTR           |:EX20000   |500      |331 |
|13|    PX PARTITION ITERATOR       |           |500      |331 |
|14|     TABLE SCAN                 |t1         |500      |331 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW4.max(t1.c1)]), filter(nil), 
      group([VIEW4.max(t1.c1)]), agg_func(nil)
  1 - output([VIEW4.max(t1.c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW4.max(t1.c1)]), filter(nil), 
      access([VIEW4.max(t1.c1)])
  3 - output([T_FUN_MAX(VIEW5.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW5.c1)])
  4 - output([VIEW5.c1]), filter(nil), 
      access([VIEW5.c1])
  5 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC])
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC]), local merge sort
  9 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), dop=1
  13 - output([1]), filter(nil), 
      force partition granule, asc.
  14 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 271(end)  ************** 

***************   Case 272   ***************

SQL: ( SELECT * FROM t12 WHERE 69 > ROUND ( 3075 ) ) UNION ALL ( SELECT * FROM t12  ) UNION ( SELECT * FROM t13) ; 

============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |HASH UNION DISTINCT|    |300      |711 |
|1 | UNION ALL         |    |200      |271 |
|2 |  TABLE SCAN       |t12 |100      |92  |
|3 |  TABLE SCAN       |t12 |100      |92  |
|4 | TABLE SCAN        |t13 |100      |92  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([cast(UNION([1]), CHAR(20))], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([t12.a], [t12.b], [t12.c]), filter(nil), startup_filter([0]), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  3 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  4 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.b], [t13.c], [t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 272(end)  ************** 

***************   Case 273   ***************

SQL: select t1.c1, nvl(t2.c2,0) from (select c1,c2 from t1 where c1=0 or c1=1) as t1 left join (select c1,c2 from t1 where c1=0) as t2 on t1.c1=t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |112 |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |112 |
|2 |  MERGE OUTER JOIN           |        |2        |112 |
|3 |   SORT                      |        |2        |59  |
|4 |    PX PARTITION ITERATOR    |        |2        |57  |
|5 |     TABLE GET               |t1      |2        |57  |
|6 |   EXCHANGE IN DISTR         |        |1        |53  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |52  |
|8 |     TABLE GET               |t1      |1        |52  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [nvl(t1.c2, ?)]), filter(nil)
  1 - output([t1.c1], [nvl(t1.c2, ?)]), filter(nil), dop=1
  2 - output([t1.c1], [nvl(t1.c2, ?)]), filter(nil), 
      equal_conds([t1.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t1.c1]), range[0 ; 0], [1 ; 1], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[0 ; 0], 
      range_cond([t1.c1 = ?])

*************** Case 273(end)  ************** 

***************   Case 274   ***************

SQL: (select * from t12 where a != 1 limit 7 ) union (select * from t13) union ( select * from t13); 

==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE UNION DISTINCT |    |207      |368 |
|1 | MERGE UNION DISTINCT|    |107      |186 |
|2 |  SORT               |    |7        |48  |
|3 |   TABLE SCAN        |t12 |7        |38  |
|4 |  TABLE SCAN         |t13 |100      |92  |
|5 | TABLE SCAN          |t13 |100      |92  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([cast(t12.a, CHAR(20))], [t12.b], [t12.c]), filter(nil), sort_keys([t12.c, ASC], [cast(t12.a, CHAR(20)), ASC], [t12.b, ASC])
  3 - output([t12.b], [t12.c], [cast(t12.a, CHAR(20))]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      limit(7), offset(nil), 
      is_index_back=false, 
      range_key([t12.a]), range(NULL ; 1), (1 ; MAX), 
      range_cond([t12.a != ?])
  4 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.b], [t13.c], [t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  5 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.b], [t13.c], [t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 274(end)  ************** 

***************   Case 275   ***************

SQL: select /*+ leading(t3, t2, t1) use_merge(t3,t2) */* from t1,t2,t3; 

============================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST    |
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |30000000 |21589400|
|1 | NESTED-LOOP JOIN CARTESIAN|        |60000    |46307   |
|2 |  PX COORDINATOR           |        |300      |290     |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |205     |
|4 |    PX PARTITION ITERATOR  |        |300      |205     |
|5 |     TABLE SCAN            |t2      |300      |205     |
|6 |  MATERIAL                 |        |200      |426     |
|7 |   PX COORDINATOR          |        |200      |205     |
|8 |    EXCHANGE OUT DISTR     |:EX20000|200      |149     |
|9 |     PX PARTITION ITERATOR |        |200      |149     |
|10|      TABLE SCAN           |t3      |200      |149     |
|11| MATERIAL                  |        |500      |573     |
|12|  PX COORDINATOR           |        |500      |389     |
|13|   EXCHANGE OUT DISTR      |:EX30000|500      |342     |
|14|    PX PARTITION ITERATOR  |        |500      |342     |
|15|     TABLE SCAN            |t1      |500      |342     |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1], [t1.c2]), filter(nil)
  12 - output([t1.c1], [t1.c2]), filter(nil)
  13 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 275(end)  ************** 

***************   Case 276   ***************

SQL: select /*+leading(t10, t11) use_nl(t11) */ * from t10 join t11 on t10.c2 = t11.c2; 

=====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST |
-----------------------------------------------------
|0 |PX COORDINATOR         |        |361      |12809|
|1 | EXCHANGE OUT DISTR    |:EX10000|361      |12707|
|2 |  PX PARTITION ITERATOR|        |361      |12707|
|3 |   NESTED-LOOP JOIN    |        |361      |12707|
|4 |    TABLE SCAN         |t10     |200      |149  |
|5 |    MATERIAL           |        |200      |259  |
|6 |     TABLE SCAN        |t11     |200      |149  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil)
  1 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), dop=1
  2 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      conds([t10.c2 = t11.c2]), nl_params_(nil), batch_join=false
  4 - output([t10.c2], [t10.c1], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c1], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil)
  6 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil), 
      access([t11.c2], [t11.c1], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 276(end)  ************** 

***************   Case 277   ***************

SQL: select * from t4 where c1 not in (select c1 from t7 where t4.c1+t7.c1 >(select c1 from t8)); 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |50       |20201|
|1 | TABLE SCAN    |t4  |100      |92   |
|2 | SUBPLAN FILTER|    |34       |197  |
|3 |  TABLE SCAN   |t7  |34       |105  |
|4 |  TABLE SCAN   |t8  |100      |88   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter([? + t7.c1 > ?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 277(end)  ************** 

***************   Case 278   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t7.c1>(select c1 from t8)); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE ANTI JOIN |     |67       |266 |
|1 | TABLE SCAN     |t4   |100      |90  |
|2 | SUBPLAN SCAN   |VIEW1|34       |138 |
|3 |  SUBPLAN FILTER|     |34       |134 |
|4 |   TABLE SCAN   |t7   |34       |42  |
|5 |   TABLE SCAN   |t8   |100      |88  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 278(end)  ************** 

***************   Case 279   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t7.c1>(select c1 from t8 where t4.c1=1)); 

==================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST |
--------------------------------------------------
|0 |SUBPLAN FILTER |             |50       |13847|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100      |54   |
|2 | SUBPLAN FILTER|             |34       |134  |
|3 |  TABLE SCAN   |t7           |34       |42   |
|4 |  TABLE SCAN   |t8           |100      |88   |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1 = ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  4 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 279(end)  ************** 

***************   Case 280   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t4.c1>(select c1 from t8)); 

==================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST |
--------------------------------------------------
|0 |SUBPLAN FILTER |             |50       |19639|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100      |54   |
|2 | SUBPLAN FILTER|             |50       |189  |
|3 |  TABLE SCAN   |t7           |100      |88   |
|4 |  TABLE SCAN   |t8           |100      |88   |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 280(end)  ************** 

***************   Case 281   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where 1>(select c1 from t8)); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE ANTI JOIN |     |50       |336 |
|1 | TABLE SCAN     |t4   |100      |90  |
|2 | SUBPLAN SCAN   |VIEW1|50       |196 |
|3 |  SUBPLAN FILTER|     |50       |189 |
|4 |   TABLE SCAN   |t7   |100      |88  |
|5 |   TABLE SCAN   |t8   |100      |88  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 281(end)  ************** 

***************   Case 282   ***************

SQL: select c1 from t7 where c1 <>ALL (select c1 from t8 where 1>(select 2)); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |MERGE ANTI JOIN|     |0        |276 |
|1 | TABLE SCAN    |t7   |100      |88  |
|2 | SUBPLAN SCAN  |VIEW1|100      |102 |
|3 |  TABLE SCAN   |t8   |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 282(end)  ************** 

***************   Case 283   ***************

SQL: select c1 from t4 where c1 in (select c1 from t7 where t4.c1>(select c1 from t8)); 

==================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST |
--------------------------------------------------
|0 |SUBPLAN FILTER |             |50       |19639|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100      |54   |
|2 | SUBPLAN FILTER|             |50       |189  |
|3 |  TABLE SCAN   |t7           |100      |88   |
|4 |  TABLE SCAN   |t8           |100      |88   |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 283(end)  ************** 

***************   Case 284   ***************

SQL: select * from t7 where c1 not in (select 1 from t8 where t8.c1 >1); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |98       |3031|
|1 | TABLE SCAN          |t7   |100      |90  |
|2 | MATERIAL            |     |100      |120 |
|3 |  SUBPLAN SCAN       |VIEW1|100      |102 |
|4 |   TABLE SCAN        |t8   |100      |88  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = VIEW1.1 OR (T_OP_IS, VIEW1.1, NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.1]), filter(nil)
  3 - output([VIEW1.1]), filter(nil), 
      access([VIEW1.1])
  4 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 284(end)  ************** 

***************   Case 285   ***************

SQL: select * from t7 where c1 not in (select t7.c1 from t8 where t8.c1 >1); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |3081|
|1 | TABLE SCAN          |t7   |100      |90  |
|2 | MATERIAL            |     |100      |120 |
|3 |  SUBPLAN SCAN       |VIEW1|100      |102 |
|4 |   TABLE SCAN        |t8   |100      |88  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = t7.c1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 285(end)  ************** 

***************   Case 286   ***************

SQL: select * from t7 where c1 not in (select (select c1 from t1) from t8 where t8.c1 >1); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SUBPLAN FILTER           |        |50       |2574|
|1 | TABLE SCAN              |t7      |100      |90  |
|2 | SUBPLAN FILTER          |        |100      |456 |
|3 |  TABLE SCAN             |t8      |100      |88  |
|4 |  PX COORDINATOR         |        |500      |354 |
|5 |   EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|6 |    PX PARTITION ITERATOR|        |500      |331 |
|7 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 286(end)  ************** 

***************   Case 287   ***************

SQL: select * from t7 where c1 in (select t8.c1 from t8 where t8.c1 >1); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t7  |100      |90  |
|2 | TABLE SCAN|t8  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(1 ; MAX), 
      range_cond([t7.c1 > ?])
  2 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 287(end)  ************** 

***************   Case 288   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >t7.c1); 

=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN CARTESIAN|     |1        |168 |
|1 | TABLE GET                     |t7   |1        |52  |
|2 | SUBPLAN SCAN                  |VIEW1|100      |102 |
|3 |  TABLE SCAN                   |t8   |100      |88  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])
  2 - output([1]), filter(nil), 
      access(nil)
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 288(end)  ************** 

***************   Case 289   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >1); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1|1        |37  |
|2 |  TABLE SCAN    |t8   |1        |36  |
|3 | TABLE GET      |t7   |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.1]), batch_join=true
  1 - output([VIEW1.1]), filter(nil), 
      access([VIEW1.1])
  2 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 289(end)  ************** 

***************   Case 290   ***************

SQL: select * from t1 where c1 = 1 and c2 in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |t1  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 290(end)  ************** 

***************   Case 291   ***************

SQL: select * from t1 partition(p1)  where c2 =1 or c2 = 2; 

======================================================
|ID|OPERATOR            |NAME         |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE  |             |1980     |1442|
|1 | EXCHANGE OUT REMOTE|             |1980     |1255|
|2 |  TABLE SCAN        |t1(idx_t1_c2)|1980     |1255|
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ? OR t1.c2 = ?])

*************** Case 291(end)  ************** 

***************   Case 292   ***************

SQL: select * from t14 partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |20       |43  |
|1 | EXCHANGE OUT REMOTE|    |20       |40  |
|2 |  TABLE SCAN        |t14 |20       |40  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil)
  2 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 292(end)  ************** 

***************   Case 293   ***************

SQL: select/*+index(t14 primary)*/* from t14  partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |20       |43  |
|1 | EXCHANGE OUT REMOTE|    |20       |40  |
|2 |  TABLE SCAN        |t14 |20       |40  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil)
  2 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 293(end)  ************** 

***************   Case 294   ***************

SQL: select c1 from t1 where (1, 2) in (select t1.c1, t2.c1 from t2); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |105 |
|1 | PX COORDINATOR           |        |1        |52  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |52  |
|3 |   TABLE GET              |t1      |1        |52  |
|4 | PX COORDINATOR           |        |1        |52  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |52  |
|6 |   TABLE GET              |t2      |1        |52  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), is_single, dop=1
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), is_single, dop=1
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 294(end)  ************** 

***************   Case 295   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where t1.c1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |5        |60  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t2      |1        |53  |
|4 | PX COORDINATOR           |        |499      |396 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|499      |373 |
|6 |   PX PARTITION ITERATOR  |        |499      |373 |
|7 |    TABLE SCAN            |t1      |499      |373 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), is_single, dop=1
  3 - output([1]), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter([t1.c1]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 295(end)  ************** 

***************   Case 296   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where (t2.c1 + 1)); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |3        |56  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t2      |1        |53  |
|4 | PX COORDINATOR           |        |500      |354 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|500      |331 |
|6 |   PX PARTITION ITERATOR  |        |500      |331 |
|7 |    TABLE SCAN            |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), is_single, dop=1
  3 - output([1]), filter([t2.c2 = ?], [t2.c1 + ?]), 
      access([t2.c1], [t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 296(end)  ************** 

***************   Case 297   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where (t1.c1 + 1)); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |3        |58  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t2      |1        |53  |
|4 | PX COORDINATOR           |        |250      |384 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|250      |373 |
|6 |   PX PARTITION ITERATOR  |        |250      |373 |
|7 |    TABLE SCAN            |t1      |250      |373 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), is_single, dop=1
  3 - output([1]), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter([t1.c1 + ?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 297(end)  ************** 

***************   Case 298   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where (t1.c1 + 1) = 2); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |56  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t2      |1        |53  |
|4 | PX COORDINATOR           |        |1        |373 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |373 |
|6 |   PX PARTITION ITERATOR  |        |1        |373 |
|7 |    TABLE SCAN            |t1      |1        |373 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), is_single, dop=1
  3 - output([1]), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter([t1.c1 + ? = ?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 298(end)  ************** 

***************   Case 299   ***************

SQL: select c1 from t1 where (1, 2) in (select distinct t1.c1, t1.c2 from t2 where t1.c1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |53  |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t1      |1        |53  |
|4 | SUBPLAN SCAN             |VIEW2   |1        |37  |
|5 |  LIMIT                   |        |1        |37  |
|6 |   PX COORDINATOR         |        |1        |36  |
|7 |    EXCHANGE OUT DISTR    |:EX20000|1        |36  |
|8 |     PX PARTITION ITERATOR|        |1        |36  |
|9 |      TABLE SCAN          |t2      |1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), is_single, dop=1
  3 - output([t1.c1]), filter([t1.c2 = ?], [t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([1]), filter(nil), 
      access(nil)
  5 - output([1]), filter(nil), limit(1), offset(nil)
  6 - output([1]), filter(nil)
  7 - output([1]), filter(nil), dop=1
  8 - output([1]), filter(nil), 
      force partition granule, asc.
  9 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 299(end)  ************** 

***************   Case 300   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1 and t1.c2 limit 1); 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |485      |850 |
|1 | PX COORDINATOR            |        |485      |471 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|485      |426 |
|3 |   PX PARTITION ITERATOR   |        |485      |426 |
|4 |    TABLE SCAN             |t1      |485      |426 |
|5 | MATERIAL                  |        |1        |37  |
|6 |  SUBPLAN SCAN             |VIEW2   |1        |37  |
|7 |   LIMIT                   |        |1        |37  |
|8 |    PX COORDINATOR         |        |1        |36  |
|9 |     EXCHANGE OUT DISTR    |:EX20000|1        |36  |
|10|      PX PARTITION ITERATOR|        |1        |36  |
|11|       TABLE SCAN          |t2      |1        |36  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c2]), filter(nil)
  2 - output([t1.c2]), filter(nil), dop=1
  3 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c2]), filter([t1.c2], [t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access(nil)
  7 - output([1]), filter(nil), limit(1), offset(nil)
  8 - output([1]), filter(nil)
  9 - output([1]), filter(nil), dop=1
  10 - output([1]), filter(nil), 
      force partition granule, asc.
  11 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 300(end)  ************** 

***************   Case 301   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7 left join t8 on t7.c1<=t8.c1 where (t7.c1,t4.c1) in (select c1,c2 from t9)); 

===================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN         |     |1        |189 |
|1 | SUBPLAN SCAN            |VIEW3|2        |152 |
|2 |  MERGE DISTINCT         |     |2        |152 |
|3 |   NESTED-LOOP OUTER JOIN|     |17       |148 |
|4 |    NESTED-LOOP JOIN     |     |1        |117 |
|5 |     TABLE SCAN          |t9   |1        |99  |
|6 |     TABLE GET           |t7   |1        |36  |
|7 |    TABLE SCAN           |t8   |34       |42  |
|8 | TABLE SCAN              |t4   |1        |36  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([VIEW3.VIEW2.t9.c2]), batch_join=true
  1 - output([VIEW3.VIEW2.t9.c2]), filter(nil), 
      access([VIEW3.VIEW2.t9.c2])
  2 - output([t9.c2], [t7.c1]), filter(nil), 
      distinct([t9.c2])
  3 - output([t9.c2], [t7.c1]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  4 - output([t9.c2], [t7.c1]), filter(nil), 
      conds(nil), nl_params_([t9.c2]), batch_join=true
  5 - output([t9.c2]), filter([t9.c2 = t9.c1]), 
      access([t9.c1], [t9.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t9.c1]), range(MIN ; MAX)always true
  6 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([? = t7.c1])
  7 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? <= t8.c1])
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN ; MAX), 
      range_cond([t4.c1 = ?])

*************** Case 301(end)  ************** 

***************   Case 302   ***************

SQL: select * from t7 where 1 in (select c1 from t8 where t7.c1); 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |99       |215 |
|1 | TABLE GET                |t8  |1        |52  |
|2 | TABLE SCAN               |t7  |99       |99  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[1 ; 1], 
      range_cond([t8.c1 = ?])
  2 - output([t7.c1], [t7.c2]), filter([t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 302(end)  ************** 

***************   Case 303   ***************

SQL: select * from t7 where 1 not in (select 2 from t8 where t7.c1=t8.c1); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |MERGE ANTI JOIN|     |0        |278 |
|1 | TABLE SCAN    |t7   |100      |90  |
|2 | SUBPLAN SCAN  |VIEW1|100      |102 |
|3 |  TABLE SCAN   |t8   |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.t8.c1]), filter(nil), 
      access([VIEW1.t8.c1])
  3 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 303(end)  ************** 

***************   Case 304   ***************

SQL: select * from t4 where (select c1 from t7)+1 in (select 2 from t8 where t4.c1=t8.c1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |368 |
|1 | MERGE JOIN   |    |100      |267 |
|2 |  TABLE SCAN  |t4  |100      |92  |
|3 |  TABLE SCAN  |t8  |100      |88  |
|4 | TABLE SCAN   |t7  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([?]), 
      exec_params_(nil), onetime_exprs_([subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t8.c1]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 304(end)  ************** 

***************   Case 305   ***************

SQL: select * from t4 where (select 2)+(select c1 from t7)+1 in (select 2 from t8 where t4.c1=t8.c1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |368 |
|1 | MERGE JOIN   |    |100      |267 |
|2 |  TABLE SCAN  |t4  |100      |92  |
|3 |  TABLE SCAN  |t8  |100      |88  |
|4 | TABLE SCAN   |t7  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? + subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = t8.c1]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 305(end)  ************** 

***************   Case 306   ***************

SQL: select sum(c1)+sum(c2), sum(c1) from t1 group by c2 having sum(c1) > 5; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |95       |687 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |95       |678 |
|2 |  MERGE GROUP BY               |             |95       |678 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |95       |515 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |95       |506 |
|5 |     PX PARTITION ITERATOR     |             |95       |506 |
|6 |      MERGE GROUP BY           |             |95       |506 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c2))])
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 306(end)  ************** 

***************   Case 307   ***************

SQL: select sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |5        |670 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |5        |670 |
|2 |  MERGE GROUP BY               |             |5        |670 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |5        |506 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |5        |506 |
|5 |     PX PARTITION ITERATOR     |             |5        |506 |
|6 |      MERGE GROUP BY           |             |5        |506 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 307(end)  ************** 

***************   Case 308   ***************

SQL: select distinct sum(c1) from t1 group by c2 having sum(c1) > 5; 

====================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |PX COORDINATOR                    |             |95       |741 |
|1 | EXCHANGE OUT DISTR               |:EX10002     |95       |733 |
|2 |  HASH DISTINCT                   |             |95       |733 |
|3 |   EXCHANGE IN DISTR              |             |95       |634 |
|4 |    EXCHANGE OUT DISTR (HASH)     |:EX10001     |95       |625 |
|5 |     MERGE GROUP BY               |             |95       |625 |
|6 |      EXCHANGE IN MERGE SORT DISTR|             |95       |488 |
|7 |       EXCHANGE OUT DISTR (HASH)  |:EX10000     |95       |479 |
|8 |        PX PARTITION ITERATOR     |             |95       |479 |
|9 |         MERGE GROUP BY           |             |95       |479 |
|10|          TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil)
  4 - (#keys=1, [T_FUN_SUM(T_FUN_SUM(t1.c1))]), output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  7 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 308(end)  ************** 

***************   Case 309   ***************

SQL: select distinct sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |5        |670 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |5        |670 |
|2 |  MERGE GROUP BY               |             |5        |670 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |5        |506 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |5        |506 |
|5 |     PX PARTITION ITERATOR     |             |5        |506 |
|6 |      MERGE GROUP BY           |             |5        |506 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 309(end)  ************** 

***************   Case 310   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |5        |670 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |5        |670 |
|2 |  MERGE GROUP BY               |             |5        |670 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |5        |506 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |5        |506 |
|5 |     PX PARTITION ITERATOR     |             |5        |506 |
|6 |      MERGE GROUP BY           |             |5        |506 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 310(end)  ************** 

***************   Case 311   ***************

SQL: select distinct sum(c1)+1, sum(c1) + 2 from t1 group by c2 having sum(c1) > 5 and count(c1) + 2 > 2; 

====================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |PX COORDINATOR                    |             |5        |676 |
|1 | EXCHANGE OUT DISTR               |:EX10002     |5        |676 |
|2 |  HASH DISTINCT                   |             |5        |676 |
|3 |   EXCHANGE IN DISTR              |             |5        |670 |
|4 |    EXCHANGE OUT DISTR (HASH)     |:EX10001     |5        |670 |
|5 |     MERGE GROUP BY               |             |5        |670 |
|6 |      EXCHANGE IN MERGE SORT DISTR|             |5        |506 |
|7 |       EXCHANGE OUT DISTR (HASH)  |:EX10000     |5        |506 |
|8 |        PX PARTITION ITERATOR     |             |5        |506 |
|9 |         MERGE GROUP BY           |             |5        |506 |
|10|          TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?])
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil)
  4 - (#keys=2, [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), dop=1
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ? > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  7 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  9 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 311(end)  ************** 

***************   Case 312   ***************

SQL: select * from t1, t2 where t1.c1 > any(select t3.c2 from t2,t3 where t2.c1 > any(select t4.c1 from t4,t5 where exists (select c1 from t2 ))); 

=========================================================================
|ID|OPERATOR                            |NAME         |EST. ROWS|COST   |
-------------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN          |             |50000    |2913831|
|1 | PX COORDINATOR                     |             |300      |290    |
|2 |  EXCHANGE OUT DISTR                |:EX10000     |300      |205    |
|3 |   PX PARTITION ITERATOR            |             |300      |205    |
|4 |    TABLE SCAN                      |t2           |300      |205    |
|5 | MATERIAL                           |             |167      |2877637|
|6 |  NESTED-LOOP SEMI JOIN             |             |167      |2877576|
|7 |   PX COORDINATOR                   |             |500      |389    |
|8 |    EXCHANGE OUT DISTR              |:EX20000     |500      |342    |
|9 |     PX PARTITION ITERATOR          |             |500      |342    |
|10|      TABLE SCAN                    |t1           |500      |342    |
|11|   MATERIAL                         |             |20000    |57043  |
|12|    SUBPLAN SCAN                    |VIEW2        |20000    |53368  |
|13|     NESTED-LOOP JOIN CARTESIAN     |             |20000    |50607  |
|14|      PX COORDINATOR                |             |200      |163    |
|15|       EXCHANGE OUT DISTR           |:EX30000     |200      |144    |
|16|        PX PARTITION ITERATOR       |             |200      |144    |
|17|         TABLE SCAN                 |t3           |200      |144    |
|18|      MATERIAL                      |             |100      |36292  |
|19|       NESTED-LOOP SEMI JOIN        |             |100      |36273  |
|20|        PX COORDINATOR              |             |300      |206    |
|21|         EXCHANGE OUT DISTR         |:EX40000     |300      |192    |
|22|          PX PARTITION ITERATOR     |             |300      |192    |
|23|           TABLE SCAN               |t2           |300      |192    |
|24|        SUBPLAN SCAN                |VIEW1        |1        |120    |
|25|         SUBPLAN FILTER             |             |1        |120    |
|26|          NESTED-LOOP JOIN CARTESIAN|             |1        |84     |
|27|           PX COORDINATOR           |             |1        |36     |
|28|            EXCHANGE OUT DISTR      |:EX50000     |1        |36     |
|29|             PX PARTITION ITERATOR  |             |1        |36     |
|30|              TABLE SCAN            |t5(idx_t5_c2)|1        |36     |
|31|           MATERIAL                 |             |34       |48     |
|32|            TABLE SCAN              |t4           |34       |42     |
|33|          LIMIT                     |             |1        |37     |
|34|           PX COORDINATOR           |             |1        |36     |
|35|            EXCHANGE OUT DISTR      |:EX60000     |1        |36     |
|36|             PX PARTITION ITERATOR  |             |1        |36     |
|37|              TABLE SCAN            |t2           |1        |36     |
=========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW2.c2]), nl_params_(nil), batch_join=false
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([VIEW2.c2]), filter(nil)
  12 - output([VIEW2.c2]), filter(nil), 
      access([VIEW2.c2])
  13 - output([t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  14 - output([t3.c2]), filter(nil)
  15 - output([t3.c2]), filter(nil), dop=1
  16 - output([t3.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  18 - output([1]), filter(nil)
  19 - output([1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  20 - output([t2.c1]), filter(nil)
  21 - output([t2.c1]), filter(nil), dop=1
  22 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  23 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  24 - output([1]), filter(nil), 
      access([VIEW1.c1])
  25 - output([t4.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  26 - output([t4.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  27 - output([1]), filter(nil)
  28 - output([1]), filter(nil), dop=1
  29 - output([1]), filter(nil), 
      force partition granule, asc.
  30 - output([1]), filter(nil), 
      access([t5.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  31 - output([t4.c1]), filter(nil)
  32 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true, 
      range_cond([? > t4.c1])
  33 - output([1]), filter(nil), limit(1), offset(nil)
  34 - output([1]), filter(nil)
  35 - output([1]), filter(nil), dop=1
  36 - output([1]), filter(nil), 
      force partition granule, asc.
  37 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 312(end)  ************** 

***************   Case 313   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8); 

========================================================
|ID|OPERATOR                     |NAME |EST. ROWS|COST |
--------------------------------------------------------
|0 |HASH JOIN                    |     |5000     |24065|
|1 | SUBPLAN SCAN                |VIEW2|100      |9502 |
|2 |  MERGE DISTINCT             |     |100      |9488 |
|3 |   NESTED-LOOP JOIN CARTESIAN|     |10000    |7270 |
|4 |    TABLE SCAN               |t7   |100      |88   |
|5 |    MATERIAL                 |     |100      |106  |
|6 |     TABLE SCAN              |t8   |100      |88   |
|7 | NESTED-LOOP JOIN CARTESIAN  |     |10000    |7525 |
|8 |  TABLE SCAN                 |t4   |100      |92   |
|9 |  MATERIAL                   |     |100      |148  |
|10|   TABLE SCAN                |t5   |100      |92   |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t4.c1 + t5.c1 = VIEW2.VIEW1.c1]), other_conds(nil)
  1 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  2 - output([t7.c1]), filter(nil), 
      distinct([t7.c1])
  3 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  7 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t4.c1 + t5.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  9 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  10 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 313(end)  ************** 

***************   Case 314   ***************

SQL: select * from t4,t4 t5 where t4.c1 in (select t7.c1 from t7,t8); 

=========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST |
---------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN    |     |9901     |11285|
|1 | NESTED-LOOP JOIN             |     |100      |3926 |
|2 |  TABLE SCAN                  |t4   |100      |92   |
|3 |  SUBPLAN SCAN                |VIEW2|1        |38   |
|4 |   LIMIT                      |     |1        |38   |
|5 |    NESTED-LOOP JOIN CARTESIAN|     |1        |38   |
|6 |     TABLE GET                |t7   |1        |36   |
|7 |     TABLE SCAN               |t8   |100      |88   |
|8 | MATERIAL                     |     |100      |148  |
|9 |  TABLE SCAN                  |t5   |100      |92   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  4 - output([t7.c1]), filter(nil), limit(1), offset(nil)
  5 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  6 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t7.c1])
  7 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  8 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  9 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 314(end)  ************** 

***************   Case 315   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8 where t7.c1=t8.c1); 

======================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST |
------------------------------------------------------
|0 |HASH JOIN                   |    |5000     |19455|
|1 | TABLE SCAN                 |t8  |100      |88   |
|2 | HASH JOIN                  |    |5000     |14651|
|3 |  TABLE SCAN                |t7  |100      |88   |
|4 |  NESTED-LOOP JOIN CARTESIAN|    |10000    |7525 |
|5 |   TABLE SCAN               |t4  |100      |92   |
|6 |   MATERIAL                 |    |100      |148  |
|7 |    TABLE SCAN              |t5  |100      |92   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t7.c1]), filter(nil), 
      equal_conds([t4.c1 + t5.c1 = t7.c1]), other_conds(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t4.c1 + t5.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  7 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 315(end)  ************** 

***************   Case 316   ***************

SQL: select count(*) v from t1 where c2 = 1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SCALAR GROUP BY          |             |1        |533 |
|1 | PX COORDINATOR          |             |1        |437 |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |437 |
|3 |   MERGE GROUP BY        |             |1        |437 |
|4 |    PX PARTITION ITERATOR|             |500      |342 |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|500      |342 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 316(end)  ************** 

***************   Case 317   ***************

SQL: select count(*) v, sum(c1) as v2 from t1 where c1 > 0; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |575 |
|1 | PX COORDINATOR          |        |1        |453 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |453 |
|3 |   MERGE GROUP BY        |        |1        |453 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))])
  1 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 317(end)  ************** 

***************   Case 318   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) as alias from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1 and alias > 100; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |1        |670 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |670 |
|2 |  MERGE GROUP BY               |             |1        |670 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |506 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |506 |
|5 |     PX PARTITION ITERATOR     |             |1        |506 |
|6 |      MERGE GROUP BY           |             |1        |506 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 318(end)  ************** 

***************   Case 319   ***************

SQL: select 1 from t15; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |400      |280 |
|1 | EXCHANGE OUT DISTR    |:EX10000|400      |261 |
|2 |  PX PARTITION ITERATOR|        |400      |261 |
|3 |   TABLE SCAN          |t15     |400      |261 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil), dop=1
  2 - output([?]), filter(nil), 
      force partition granule, asc.
  3 - output([?]), filter(nil), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 319(end)  ************** 

***************   Case 320   ***************

SQL: select c1 from t15 where false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |400      |289 |
|1 | EXCHANGE OUT DISTR    |:EX10000|400      |270 |
|2 |  PX PARTITION ITERATOR|        |400      |270 |
|3 |   TABLE SCAN          |t15     |400      |270 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t15.c1]), filter(nil)
  1 - output([t15.c1]), filter(nil), dop=1
  2 - output([t15.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t15.c1]), filter(nil), startup_filter([0]), 
      access([t15.c1]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 320(end)  ************** 

***************   Case 321   ***************

SQL: select count(1) from t15 where false; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |414 |
|1 | PX COORDINATOR          |        |1        |337 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |337 |
|3 |   MERGE GROUP BY        |        |1        |337 |
|4 |    PX PARTITION ITERATOR|        |400      |261 |
|5 |     TABLE SCAN          |t15     |400      |261 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  1 - output([T_FUN_COUNT(?)]), filter(nil)
  2 - output([T_FUN_COUNT(?)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), startup_filter([0]), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 321(end)  ************** 

***************   Case 322   ***************

SQL: select * from t1 order by c2,c1,c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500      |1125|
|1 | EXCHANGE OUT DISTR       |:EX10000     |500      |1078|
|2 |  SORT                    |             |500      |1078|
|3 |   PX PARTITION ITERATOR  |             |500      |342 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 322(end)  ************** 

***************   Case 323   ***************

SQL: select * from t1 left outer join t2 using(c1) order by t1.c1 desc, t2.c1; 

===============================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |           |500      |1725|
|1 | EXCHANGE OUT DISTR            |:EX10001   |500      |1536|
|2 |  MERGE OUTER JOIN             |           |500      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|           |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000   |500      |342 |
|5 |     PX PARTITION ITERATOR     |           |500      |342 |
|6 |      TABLE SCAN               |t1(Reverse)|500      |342 |
|7 |   SORT                        |           |300      |859 |
|8 |    PX PARTITION ITERATOR      |           |300      |205 |
|9 |     TABLE SCAN                |t2(Reverse)|300      |205 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, DESC])
  1 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, DESC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), sort_keys([t2.c1, DESC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 323(end)  ************** 

***************   Case 324   ***************

SQL: select count(*) from t1 left outer join t2 using(c1) group by (t1.c1) having count(*) > 1 order by t1.c1 desc, t2.c1; 

===============================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |           |500      |1507|
|1 | EXCHANGE OUT DISTR            |:EX10001   |500      |1460|
|2 |  MERGE OUTER JOIN             |           |500      |1460|
|3 |   SORT                        |           |500      |966 |
|4 |    PX PARTITION ITERATOR      |           |500      |331 |
|5 |     TABLE SCAN                |t1(Reverse)|500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|           |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000   |300      |192 |
|8 |     PX PARTITION ITERATOR     |           |300      |192 |
|9 |      TABLE SCAN               |t2(Reverse)|300      |192 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil), sort_keys([t1.c1, DESC])
  1 - output([1], [t1.c1]), filter(nil), dop=1
  2 - output([1], [t1.c1]), filter(nil), startup_filter([?]), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), startup_filter([?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, DESC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), startup_filter([?]), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 324(end)  ************** 

***************   Case 325   ***************

SQL: select now() from t1 left outer join t2 using(c1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil), dop=1
  2 - output([?]), filter(nil), 
      force partition granule, asc.
  3 - output([?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 325(end)  ************** 

***************   Case 326   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where least(t1.c2, a1.c2) > 1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |1556|
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |1537|
|2 |  MERGE JOIN                   |        |100      |1537|
|3 |   SORT                        |        |500      |1074|
|4 |    PX PARTITION ITERATOR      |        |500      |342 |
|5 |     TABLE SCAN                |t1      |500      |342 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |227 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |198 |
|8 |     PX PARTITION ITERATOR     |        |300      |198 |
|9 |      TABLE SCAN               |a1      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([a1.c2]), filter(nil)
  1 - output([a1.c2]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds([least(t1.c2, a1.c2) > ?])
  3 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([a1.c1], [a1.c2]), filter(nil), sort_keys([a1.c1, ASC]), Local Order
  7 - (#keys=1, [a1.c1]), output([a1.c1], [a1.c2]), filter(nil), dop=1
  8 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true

*************** Case 326(end)  ************** 

***************   Case 327   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where length(t1.c2) > 1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |167      |1213|
|1 | EXCHANGE OUT DISTR            |:EX10001|167      |1181|
|2 |  MERGE OUTER JOIN             |        |167      |1181|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |167      |399 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|167      |384 |
|5 |     PX PARTITION ITERATOR     |        |167      |384 |
|6 |      TABLE SCAN               |t1      |167      |384 |
|7 |   SORT                        |        |300      |619 |
|8 |    PX PARTITION ITERATOR      |        |300      |198 |
|9 |     TABLE SCAN                |a1      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([a1.c2]), filter(nil)
  1 - output([a1.c2]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter([length(t1.c2) > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([a1.c2], [a1.c1]), filter(nil), sort_keys([a1.c1, ASC]), local merge sort
  8 - output([a1.c1], [a1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true

*************** Case 327(end)  ************** 

***************   Case 328   ***************

SQL: select a2.c2, t1.c2, a1.c2 from t1  left join t2 a1 on (a1.c1 = t1.c1), t2 a2 where least(t1.c2, a1.c2) =a2.c2; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH JOIN                       |        |450      |2621|
|1 | PX COORDINATOR                 |        |300      |227 |
|2 |  EXCHANGE OUT DISTR            |:EX10000|300      |198 |
|3 |   PX PARTITION ITERATOR        |        |300      |198 |
|4 |    TABLE SCAN                  |a2      |300      |198 |
|5 | PX COORDINATOR                 |        |300      |1645|
|6 |  EXCHANGE OUT DISTR            |:EX20001|300      |1589|
|7 |   MERGE JOIN                   |        |300      |1589|
|8 |    SORT                        |        |500      |1074|
|9 |     PX PARTITION ITERATOR      |        |500      |342 |
|10|      TABLE SCAN                |t1      |500      |342 |
|11|    EXCHANGE IN MERGE SORT DISTR|        |300      |227 |
|12|     EXCHANGE OUT DISTR (PKEY)  |:EX20000|300      |198 |
|13|      PX PARTITION ITERATOR     |        |300      |198 |
|14|       TABLE SCAN               |a1      |300      |198 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([a2.c2], [t1.c2], [a1.c2]), filter(nil), 
      equal_conds([least(t1.c2, a1.c2) = a2.c2]), other_conds(nil)
  1 - output([a2.c2]), filter(nil)
  2 - output([a2.c2]), filter(nil), dop=1
  3 - output([a2.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c2], [a1.c2], [least(t1.c2, a1.c2)]), filter(nil)
  6 - output([t1.c2], [a1.c2], [least(t1.c2, a1.c2)]), filter(nil), dop=1
  7 - output([t1.c2], [a1.c2], [least(t1.c2, a1.c2)]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds(nil)
  8 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([a1.c1], [a1.c2]), filter(nil), sort_keys([a1.c1, ASC]), Local Order
  12 - (#keys=1, [a1.c1]), output([a1.c1], [a1.c2]), filter(nil), dop=1
  13 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule, asc.
  14 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true

*************** Case 328(end)  ************** 

***************   Case 329   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 = 1 and t2.c3 = f1.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t2 f2 on (f2.c1 = 3 and f2.c3=t2.c3) left join t3 a2 on (a2.c1 = f2.c1), t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |NESTED-LOOP JOIN             |        |1        |831 |
|1 | PX COORDINATOR              |        |1        |53  |
|2 |  EXCHANGE OUT DISTR         |:EX10000|1        |52  |
|3 |   TABLE GET                 |a2      |1        |52  |
|4 | NESTED-LOOP JOIN CARTESIAN  |        |6        |777 |
|5 |  PX COORDINATOR             |        |200      |163 |
|6 |   EXCHANGE OUT DISTR        |:EX20000|200      |144 |
|7 |    PX PARTITION ITERATOR    |        |200      |144 |
|8 |     TABLE SCAN              |f_acc   |200      |144 |
|9 |  MATERIAL                   |        |1        |610 |
|10|   NESTED-LOOP JOIN CARTESIAN|        |1        |610 |
|11|    PX COORDINATOR           |        |1        |53  |
|12|     EXCHANGE OUT DISTR      |:EX30000|1        |52  |
|13|      TABLE GET              |a1      |1        |52  |
|14|    MERGE JOIN               |        |1        |557 |
|15|     NESTED-LOOP JOIN        |        |3        |505 |
|16|      PX COORDINATOR         |        |1        |53  |
|17|       EXCHANGE OUT DISTR    |:EX40000|1        |52  |
|18|        TABLE GET            |f1      |1        |52  |
|19|      PX COORDINATOR         |        |300      |269 |
|20|       EXCHANGE OUT DISTR    |:EX50000|300      |198 |
|21|        PX PARTITION ITERATOR|        |300      |198 |
|22|         TABLE SCAN          |t2      |300      |198 |
|23|     TABLE GET               |f2      |1        |52  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a2.c2]), filter(nil), 
      conds([least(a1.c2, a2.c2) = f_acc.c2]), nl_params_(nil), batch_join=false
  1 - output([a2.c2]), filter(nil)
  2 - output([a2.c2]), filter(nil), is_single, dop=1
  3 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a2.c1]), range[3 ; 3], 
      range_cond([a2.c1 = ?])
  4 - output([f_acc.c2], [a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  5 - output([f_acc.c2]), filter(nil)
  6 - output([f_acc.c2]), filter(nil), dop=1
  7 - output([f_acc.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true
  9 - output([a1.c2]), filter(nil)
  10 - output([a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  11 - output([a1.c2]), filter(nil)
  12 - output([a1.c2]), filter(nil), is_single, dop=1
  13 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])
  14 - output([1]), filter(nil), 
      equal_conds([f2.c3 = t2.c3]), other_conds(nil)
  15 - output([t2.c3]), filter(nil), 
      conds([t2.c3 = f1.c3]), nl_params_(nil), batch_join=false
  16 - output([f1.c3]), filter(nil)
  17 - output([f1.c3]), filter(nil), is_single, dop=1
  18 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  19 - output([t2.c3]), filter(nil)
  20 - output([t2.c3]), filter(nil), dop=1
  21 - output([t2.c3]), filter(nil), 
      force partition granule, asc.
  22 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  23 - output([f2.c3]), filter(nil), 
      access([f2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([f2.c1]), range[3 ; 3], 
      range_cond([f2.c1 = ?])

*************** Case 329(end)  ************** 

***************   Case 330   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 =1 and f1.c3 = t2.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t3 a2 on (a2.c1 = f1.c1) , t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |3        |767 |
|1 | NESTED-LOOP JOIN         |        |3        |505 |
|2 |  PX COORDINATOR          |        |1        |53  |
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |52  |
|4 |    TABLE GET             |f1      |1        |52  |
|5 |  PX COORDINATOR          |        |300      |269 |
|6 |   EXCHANGE OUT DISTR     |:EX20000|300      |198 |
|7 |    PX PARTITION ITERATOR |        |300      |198 |
|8 |     TABLE SCAN           |t2      |300      |198 |
|9 | MATERIAL                 |        |1        |261 |
|10|  NESTED-LOOP JOIN        |        |1        |260 |
|11|   PX COORDINATOR         |        |1        |53  |
|12|    EXCHANGE OUT DISTR    |:EX30000|1        |52  |
|13|     TABLE GET            |a1      |1        |52  |
|14|   PX COORDINATOR         |        |200      |163 |
|15|    EXCHANGE OUT DISTR    |:EX40000|200      |144 |
|16|     PX PARTITION ITERATOR|        |200      |144 |
|17|      TABLE SCAN          |f_acc   |200      |144 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil), 
      conds([f1.c3 = t2.c3]), nl_params_(nil), batch_join=false
  2 - output([f1.c3]), filter(nil)
  3 - output([f1.c3]), filter(nil), is_single, dop=1
  4 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  5 - output([t2.c3]), filter(nil)
  6 - output([t2.c3]), filter(nil), dop=1
  7 - output([t2.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([f_acc.c2], [a1.c2]), filter(nil)
  10 - output([f_acc.c2], [a1.c2]), filter(nil), 
      conds([least(a1.c2, a1.c2) = f_acc.c2]), nl_params_(nil), batch_join=false
  11 - output([a1.c2]), filter(nil)
  12 - output([a1.c2]), filter(nil), is_single, dop=1
  13 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])
  14 - output([f_acc.c2]), filter(nil)
  15 - output([f_acc.c2]), filter(nil), dop=1
  16 - output([f_acc.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true

*************** Case 330(end)  ************** 

***************   Case 331   ***************

SQL: select * from t9,t10,t11 where t9.c2=t10.c2 and t9.c3=t10.c3 and t9.c2=t11.c2 and t9.c3=t11.c3 order by t11.c3,t11.c2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |82       |1260|
|1 | EXCHANGE OUT DISTR            |:EX10001|82       |1225|
|2 |  SORT                         |        |82       |1225|
|3 |   HASH JOIN                   |        |82       |1013|
|4 |    HASH JOIN                  |        |91       |545 |
|5 |     EXCHANGE IN DISTR         |        |100      |107 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |92  |
|7 |       TABLE SCAN              |t9      |100      |92  |
|8 |     PX PARTITION ITERATOR     |        |200      |149 |
|9 |      TABLE SCAN               |t10     |200      |149 |
|10|    PX PARTITION ITERATOR      |        |200      |149 |
|11|     TABLE SCAN                |t11     |200      |149 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), sort_keys([t11.c3, ASC], [t11.c2, ASC])
  1 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), dop=1
  2 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), sort_keys([t11.c3, ASC], [t11.c2, ASC])
  3 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      equal_conds([t9.c2 = t11.c2], [t9.c3 = t11.c3]), other_conds(nil)
  4 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  5 - output([t9.c2], [t9.c3], [t9.c1]), filter(nil)
  6 - (#keys=1, [t9.c2]), output([t9.c2], [t9.c3], [t9.c1]), filter(nil), is_single, dop=1
  7 - output([t9.c2], [t9.c3], [t9.c1]), filter(nil), 
      access([t9.c2], [t9.c3], [t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  8 - output([t10.c2], [t10.c3], [t10.c1]), filter(nil), 
      affinitize, partition wise, force partition granule, asc.
  9 - output([t10.c2], [t10.c3], [t10.c1]), filter(nil), 
      access([t10.c2], [t10.c3], [t10.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  10 - output([t11.c2], [t11.c3], [t11.c1]), filter(nil), 
      affinitize, partition wise, force partition granule, asc.
  11 - output([t11.c2], [t11.c3], [t11.c1]), filter(nil), 
      access([t11.c2], [t11.c3], [t11.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 331(end)  ************** 

***************   Case 332   ***************

SQL: select t9.c2, t9.c3, t9.c2, t10.c3 from t9, t10 where t9.c2 = t10.c2 and t9.c3 = t10.c3 order by t9.c2, t9.c3 desc; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |91       |688 |
|1 | EXCHANGE OUT DISTR           |:EX10001|91       |671 |
|2 |  SORT                        |        |91       |671 |
|3 |   HASH JOIN                  |        |91       |522 |
|4 |    EXCHANGE IN DISTR         |        |100      |102 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |92  |
|6 |      TABLE SCAN              |t9      |100      |92  |
|7 |    PX PARTITION ITERATOR     |        |200      |149 |
|8 |     TABLE SCAN               |t10     |200      |149 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c2], [t9.c3], [t9.c2], [t10.c3]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  1 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), dop=1
  2 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  3 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  4 - output([t9.c2], [t9.c3]), filter(nil)
  5 - (#keys=1, [t9.c2]), output([t9.c2], [t9.c3]), filter(nil), is_single, dop=1
  6 - output([t9.c2], [t9.c3]), filter(nil), 
      access([t9.c2], [t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  7 - output([t10.c2], [t10.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t10.c2], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 332(end)  ************** 

***************   Case 333   ***************

SQL: select c1, (select count(c1) from t7 where c1=t4.c1) calc_total, (select count(c1) from t8 where c1=0 and c1=t4.c1) calc_new from t4 where c1 in (select distinct c1 from t1); 

============================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST |
------------------------------------------------------------
|0 |SUBPLAN FILTER                |        |100      |10069|
|1 | PX COORDINATOR               |        |100      |1212 |
|2 |  EXCHANGE OUT DISTR          |:EX10001|100      |1203 |
|3 |   MERGE JOIN                 |        |100      |1203 |
|4 |    EXCHANGE IN DISTR         |        |100      |95   |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90   |
|6 |      TABLE SCAN              |t4      |100      |90   |
|7 |    SORT                      |        |500      |966  |
|8 |     PX PARTITION ITERATOR    |        |500      |331  |
|9 |      TABLE SCAN              |t1      |500      |331  |
|10| SCALAR GROUP BY              |        |1        |37   |
|11|  TABLE GET                   |t7      |1        |36   |
|12| SCALAR GROUP BY              |        |1        |53   |
|13|  TABLE GET                   |t8      |1        |52   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [subquery(1)], [subquery(2)]), filter(nil), 
      exec_params_([t4.c1], [t4.c1 = ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil)
  2 - output([t4.c1]), filter(nil), dop=1
  3 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  4 - output([t4.c1]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  11 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  12 - output([T_FUN_COUNT(t8.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t8.c1)])
  13 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[0 ; 0], 
      range_cond([t8.c1 = ?])

*************** Case 333(end)  ************** 

***************   Case 334   ***************

SQL: select c1, (select count(c1) from t7 ) calc_total, (select count(c1) from t8 ) calc_new from t4  where c1 in (select distinct c1 from t1); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN      |        |100      |2344|
|1 | SUBPLAN SCAN                   |VIEW3   |1        |107 |
|2 |  SCALAR GROUP BY               |        |1        |107 |
|3 |   TABLE SCAN                   |t8      |100      |88  |
|4 | MATERIAL                       |        |100      |1439|
|5 |  NESTED-LOOP JOIN CARTESIAN    |        |100      |1384|
|6 |   SUBPLAN SCAN                 |VIEW2   |1        |107 |
|7 |    SCALAR GROUP BY             |        |1        |107 |
|8 |     TABLE SCAN                 |t7      |100      |88  |
|9 |   PX COORDINATOR               |        |100      |1212|
|10|    EXCHANGE OUT DISTR          |:EX10001|100      |1203|
|11|     MERGE JOIN                 |        |100      |1203|
|12|      EXCHANGE IN DISTR         |        |100      |95  |
|13|       EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |90  |
|14|        TABLE SCAN              |t4      |100      |90  |
|15|      SORT                      |        |500      |966 |
|16|       PX PARTITION ITERATOR    |        |500      |331 |
|17|        TABLE SCAN              |t1      |500      |331 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [VIEW2.count(c1)], [VIEW3.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([VIEW3.count(c1)]), filter(nil), 
      access([VIEW3.count(c1)])
  2 - output([T_FUN_COUNT(t8.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t8.c1)])
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t4.c1], [VIEW2.count(c1)]), filter(nil)
  5 - output([t4.c1], [VIEW2.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  6 - output([VIEW2.count(c1)]), filter(nil), 
      access([VIEW2.count(c1)])
  7 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  8 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  9 - output([t4.c1]), filter(nil)
  10 - output([t4.c1]), filter(nil), dop=1
  11 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  12 - output([t4.c1]), filter(nil)
  13 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  14 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  15 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  16 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  17 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 334(end)  ************** 

***************   Case 335   ***************

SQL: select distinct (select c1) from t4 limit 100; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |LIMIT          |    |100      |126 |
|1 | MERGE DISTINCT|    |100      |112 |
|2 |  TABLE SCAN   |t4  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  2 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 335(end)  ************** 

***************   Case 336   ***************

SQL: select * from t7,t8 where t7.c1=t8.c1 having false; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|1 | TABLE SCAN               |t7  |100      |90  |
|2 | MATERIAL                 |    |100      |127 |
|3 |  TABLE SCAN              |t8  |100      |90  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([0]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), startup_filter([0]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 336(end)  ************** 

***************   Case 337   ***************

SQL: select c1,sum(c2) from t7 where c1>1 group by c1 having c1+1>1 and sum(c2) >1 and 1=2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [cast(t7.c2, DECIMAL(11, 0))]), filter(nil), startup_filter([0]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 337(end)  ************** 

***************   Case 338   ***************

SQL: select * from t7 where c1 in (select c1 from t8 where t7.c1>1 limit 1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |3708|
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c1 = ANY(subquery(1))]), 
      exec_params_([t7.c1 > ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 338(end)  ************** 

***************   Case 339   ***************

SQL: select * from t1,t14 where t1.c1 = t14.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |490      |1904|
|1 | EXCHANGE OUT DISTR    |:EX10000|490      |1789|
|2 |  PX PARTITION ITERATOR|        |490      |1789|
|3 |   HASH JOIN           |        |490      |1789|
|4 |    TABLE SCAN         |t1      |500      |342 |
|5 |    TABLE SCAN         |t14     |500      |353 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 = t14.c3]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 339(end)  ************** 

***************   Case 340   ***************

SQL: select * from t5,t16 where t5.c2 = t16.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |842      |1530|
|1 | PX COORDINATOR         |        |300      |247 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|300      |205 |
|3 |   PX PARTITION ITERATOR|        |300      |205 |
|4 |    TABLE SCAN          |t5      |300      |205 |
|5 | PX COORDINATOR         |        |300      |247 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |205 |
|7 |   PX PARTITION ITERATOR|        |300      |205 |
|8 |    TABLE SCAN          |t16     |300      |205 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2]), other_conds(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil)
  6 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), dop=1
  7 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      force partition granule, asc.
  8 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      access([t16.c2], [t16.c3], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 340(end)  ************** 

***************   Case 341   ***************

SQL: select * from t5,t16 where t5.c2 = t16.c2 and t5.c3 = t16.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |262      |1225|
|1 | EXCHANGE OUT DISTR    |:EX10000|262      |1150|
|2 |  PX PARTITION ITERATOR|        |262      |1150|
|3 |   MERGE JOIN          |        |262      |1150|
|4 |    TABLE SCAN         |t5      |300      |205 |
|5 |    SORT               |        |300      |686 |
|6 |     TABLE SCAN        |t16     |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), dop=1
  2 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2], [t5.c3 = t16.c3]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil), sort_keys([t16.c2, ASC], [t16.c3, ASC])
  6 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      access([t16.c2], [t16.c3], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 341(end)  ************** 

***************   Case 342   ***************

SQL: select * from t5,t16 where t5.c2 = t16.c2 and t5.c3 = t16.c3 and t5.c1 = t16.c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |245      |1229|
|1 | EXCHANGE OUT DISTR    |:EX10000|245      |1159|
|2 |  PX PARTITION ITERATOR|        |245      |1159|
|3 |   MERGE JOIN          |        |245      |1159|
|4 |    TABLE SCAN         |t5      |300      |205 |
|5 |    SORT               |        |300      |686 |
|6 |     TABLE SCAN        |t16     |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), dop=1
  2 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2], [t5.c3 = t16.c3], [t5.c1 = t16.c1]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil), sort_keys([t16.c2, ASC], [t16.c3, ASC], [t16.c1, ASC])
  6 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      access([t16.c2], [t16.c3], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 342(end)  ************** 

***************   Case 343   ***************

SQL: select * from t17,t18 where t17.c2 + t17.c3 = t18.c2 + t18.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |450      |1341|
|1 | EXCHANGE OUT DISTR    |:EX10000|450      |1213|
|2 |  PX PARTITION ITERATOR|        |450      |1213|
|3 |   HASH JOIN           |        |450      |1213|
|4 |    TABLE SCAN         |t17     |300      |205 |
|5 |    TABLE SCAN         |t18     |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil)
  1 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil), dop=1
  2 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil), 
      equal_conds([t17.c2 + t17.c3 = t18.c2 + t18.c3]), other_conds(nil)
  4 - output([t17.c2], [t17.c3], [t17.c1], [t17.c2 + t17.c3]), filter(nil), 
      access([t17.c2], [t17.c3], [t17.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t18.c2], [t18.c3], [t18.c1], [t18.c2 + t18.c3]), filter(nil), 
      access([t18.c2], [t18.c3], [t18.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t18.c1], [t18.c2], [t18.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 343(end)  ************** 

***************   Case 344   ***************

SQL: select * from z1,z2 where z1.a = z2.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |276 |
|1 | TABLE SCAN|z1  |100      |95  |
|2 | TABLE SCAN|z2  |100      |95  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d], [z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      equal_conds([z1.a = z2.a]), other_conds(nil)
  1 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z1.a]), range(MIN ; MAX)always true
  2 - output([z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      access([z2.a], [z2.b], [z2.c], [z2.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z2.a]), range(MIN ; MAX)always true

*************** Case 344(end)  ************** 

***************   Case 345   ***************

SQL: select * from t2,t6 where t2.c1 = t6.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1459|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1346|
|2 |  MERGE JOIN                   |        |300      |1346|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |227 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |198 |
|8 |     PX PARTITION ITERATOR     |        |300      |198 |
|9 |      TABLE SCAN               |t6      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2]), filter(nil), dop=1
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 345(end)  ************** 

***************   Case 346   ***************

SQL: select * from t1,t2 where t1.c1 = t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1649|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1536|
|2 |  MERGE JOIN                   |        |300      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 346(end)  ************** 

***************   Case 347   ***************

SQL: select * from t5,t6 where t5.c2 = t6.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |290      |1189|
|1 | EXCHANGE OUT DISTR            |:EX10001|290      |1121|
|2 |  MERGE JOIN                   |        |290      |1121|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |300      |247 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |205 |
|5 |     PX PARTITION ITERATOR     |        |300      |205 |
|6 |      TABLE SCAN               |t5      |300      |205 |
|7 |   SORT                        |        |300      |619 |
|8 |    PX PARTITION ITERATOR      |        |300      |198 |
|9 |     TABLE SCAN                |t6      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t6.c1], [t6.c2]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3], [t6.c1], [t6.c2]), filter(nil), dop=1
  2 - output([t5.c1], [t5.c2], [t5.c3], [t6.c1], [t6.c2]), filter(nil), 
      equal_conds([t5.c2 = t6.c1]), other_conds(nil)
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  4 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  5 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 347(end)  ************** 

***************   Case 348   ***************

SQL: select * from t1,t14 where t1.c1 = t14.c3 and t1.c2 = t14.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |471      |1986|
|1 | EXCHANGE OUT DISTR    |:EX10000|471      |1875|
|2 |  PX PARTITION ITERATOR|        |471      |1875|
|3 |   HASH JOIN           |        |471      |1875|
|4 |    TABLE SCAN         |t1      |500      |342 |
|5 |    TABLE SCAN         |t14     |500      |353 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 = t14.c3], [t1.c2 = t14.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c3], [t14.c2], [t14.c1]), filter(nil), 
      access([t14.c3], [t14.c2], [t14.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 348(end)  ************** 

***************   Case 349   ***************

SQL: select * from t1,t14 where t1.c1 + 1 = t14.c3 + 1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |500      |1913|
|1 | PX COORDINATOR         |        |500      |389 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|3 |   PX PARTITION ITERATOR|        |500      |342 |
|4 |    TABLE SCAN          |t1      |500      |342 |
|5 | PX COORDINATOR         |        |500      |424 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|500      |353 |
|7 |   PX PARTITION ITERATOR|        |500      |353 |
|8 |    TABLE SCAN          |t14     |500      |353 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t14.c3 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil)
  6 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil), dop=1
  7 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil), 
      force partition granule, asc.
  8 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 349(end)  ************** 

***************   Case 350   ***************

SQL: select * from t1 left join t14 on t1.c1 = t14.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |1907|
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |1789|
|2 |  PX PARTITION ITERATOR|        |500      |1789|
|3 |   HASH OUTER JOIN     |        |500      |1789|
|4 |    TABLE SCAN         |t1      |500      |342 |
|5 |    TABLE SCAN         |t14     |500      |353 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 = t14.c3]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c3], [t14.c1], [t14.c2]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 350(end)  ************** 

***************   Case 351   ***************

SQL: select * from t5 left join t16 on t5.c2 = t16.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH OUTER JOIN         |        |842      |1530|
|1 | PX COORDINATOR         |        |300      |247 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|300      |205 |
|3 |   PX PARTITION ITERATOR|        |300      |205 |
|4 |    TABLE SCAN          |t5      |300      |205 |
|5 | PX COORDINATOR         |        |300      |247 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |205 |
|7 |   PX PARTITION ITERATOR|        |300      |205 |
|8 |    TABLE SCAN          |t16     |300      |205 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2]), other_conds(nil)
  1 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil)
  6 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), dop=1
  7 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      force partition granule, asc.
  8 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      access([t16.c2], [t16.c3], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 351(end)  ************** 

***************   Case 352   ***************

SQL: select * from t5 left join t16 on t5.c2 = t16.c2 and t5.c3 = t16.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |1236|
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |1150|
|2 |  PX PARTITION ITERATOR|        |300      |1150|
|3 |   MERGE OUTER JOIN    |        |300      |1150|
|4 |    TABLE SCAN         |t5      |300      |205 |
|5 |    SORT               |        |300      |686 |
|6 |     TABLE SCAN        |t16     |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), dop=1
  2 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2], [t5.c3 = t16.c3]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil), sort_keys([t16.c2, ASC], [t16.c3, ASC])
  6 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      access([t16.c2], [t16.c3], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 352(end)  ************** 

***************   Case 353   ***************

SQL: select * from t5 left join t16 on t5.c2 = t16.c2 and t5.c3 = t16.c3 and t5.c1 = t16.c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |1244|
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |1159|
|2 |  PX PARTITION ITERATOR|        |300      |1159|
|3 |   MERGE OUTER JOIN    |        |300      |1159|
|4 |    TABLE SCAN         |t5      |300      |205 |
|5 |    SORT               |        |300      |686 |
|6 |     TABLE SCAN        |t16     |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), dop=1
  2 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2], [t5.c3 = t16.c3], [t5.c1 = t16.c1]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil), sort_keys([t16.c2, ASC], [t16.c3, ASC], [t16.c1, ASC])
  6 - output([t16.c2], [t16.c3], [t16.c1]), filter(nil), 
      access([t16.c2], [t16.c3], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 353(end)  ************** 

***************   Case 354   ***************

SQL: select * from t17 left join t18 on t17.c2 + t17.c3 = t18.c2 + t18.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |450      |1341|
|1 | EXCHANGE OUT DISTR    |:EX10000|450      |1213|
|2 |  PX PARTITION ITERATOR|        |450      |1213|
|3 |   HASH OUTER JOIN     |        |450      |1213|
|4 |    TABLE SCAN         |t17     |300      |205 |
|5 |    TABLE SCAN         |t18     |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil)
  1 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil), dop=1
  2 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t17.c1], [t17.c2], [t17.c3], [t18.c1], [t18.c2], [t18.c3]), filter(nil), 
      equal_conds([t17.c2 + t17.c3 = t18.c2 + t18.c3]), other_conds(nil)
  4 - output([t17.c2], [t17.c3], [t17.c1], [t17.c2 + t17.c3]), filter(nil), 
      access([t17.c2], [t17.c3], [t17.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t18.c2], [t18.c3], [t18.c1], [t18.c2 + t18.c3]), filter(nil), 
      access([t18.c2], [t18.c3], [t18.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t18.c1], [t18.c2], [t18.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 354(end)  ************** 

***************   Case 355   ***************

SQL: select * from z1 left join z2 on z1.a = z2.a; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |100      |276 |
|1 | TABLE SCAN     |z1  |100      |95  |
|2 | TABLE SCAN     |z2  |100      |95  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d], [z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      equal_conds([z1.a = z2.a]), other_conds(nil)
  1 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z1.a]), range(MIN ; MAX)always true
  2 - output([z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      access([z2.a], [z2.b], [z2.c], [z2.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z2.a]), range(MIN ; MAX)always true

*************** Case 355(end)  ************** 

***************   Case 356   ***************

SQL: select * from t2 left join t6 on t2.c1 = t6.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1459|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1346|
|2 |  MERGE OUTER JOIN             |        |300      |1346|
|3 |   SORT                        |        |300      |859 |
|4 |    PX PARTITION ITERATOR      |        |300      |205 |
|5 |     TABLE SCAN                |t2      |300      |205 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |227 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |198 |
|8 |     PX PARTITION ITERATOR     |        |300      |198 |
|9 |      TABLE SCAN               |t6      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t6.c1], [t6.c2]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), Local Order
  7 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2]), filter(nil), dop=1
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 356(end)  ************** 

***************   Case 357   ***************

SQL: select * from t1 left join t2 on t1.c1 = t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |1725|
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |1536|
|2 |  MERGE OUTER JOIN             |        |500      |1536|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR     |        |500      |342 |
|6 |      TABLE SCAN               |t1      |500      |342 |
|7 |   SORT                        |        |300      |859 |
|8 |    PX PARTITION ITERATOR      |        |300      |205 |
|9 |     TABLE SCAN                |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 357(end)  ************** 

***************   Case 358   ***************

SQL: select * from t5 left join t6 on t5.c2 = t6.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1192|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1121|
|2 |  MERGE OUTER JOIN             |        |300      |1121|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |300      |247 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |205 |
|5 |     PX PARTITION ITERATOR     |        |300      |205 |
|6 |      TABLE SCAN               |t5      |300      |205 |
|7 |   SORT                        |        |300      |619 |
|8 |    PX PARTITION ITERATOR      |        |300      |198 |
|9 |     TABLE SCAN                |t6      |300      |198 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t6.c1], [t6.c2]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3], [t6.c1], [t6.c2]), filter(nil), dop=1
  2 - output([t5.c1], [t5.c2], [t5.c3], [t6.c1], [t6.c2]), filter(nil), 
      equal_conds([t5.c2 = t6.c1]), other_conds(nil)
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  4 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  5 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 358(end)  ************** 

***************   Case 359   ***************

SQL: select * from t1 left join t14 on t1.c1 = t14.c3 and t1.c2 = t14.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |1993|
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |1875|
|2 |  PX PARTITION ITERATOR|        |500      |1875|
|3 |   HASH OUTER JOIN     |        |500      |1875|
|4 |    TABLE SCAN         |t1      |500      |342 |
|5 |    TABLE SCAN         |t14     |500      |353 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 = t14.c3], [t1.c2 = t14.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c3], [t14.c2], [t14.c1]), filter(nil), 
      access([t14.c3], [t14.c2], [t14.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 359(end)  ************** 

***************   Case 360   ***************

SQL: select * from t1 left join t14 on t1.c1 + 1 = t14.c3 + 1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH OUTER JOIN         |        |500      |1913|
|1 | PX COORDINATOR         |        |500      |389 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|3 |   PX PARTITION ITERATOR|        |500      |342 |
|4 |    TABLE SCAN          |t1      |500      |342 |
|5 | PX COORDINATOR         |        |500      |424 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|500      |353 |
|7 |   PX PARTITION ITERATOR|        |500      |353 |
|8 |    TABLE SCAN          |t14     |500      |353 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t14.c3 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2], [t1.c1 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil)
  6 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil), dop=1
  7 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil), 
      force partition granule, asc.
  8 - output([t14.c3], [t14.c1], [t14.c2], [t14.c3 + ?]), filter(nil), 
      access([t14.c3], [t14.c1], [t14.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 360(end)  ************** 

***************   Case 361   ***************

SQL: select SQL_CALC_FOUND_ROWS c2,count(*) as c from t1 group by c2 order by c desc ; 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |             |100      |763 |
|1 | EXCHANGE OUT DISTR             |:EX10001     |100      |753 |
|2 |  SORT                          |             |100      |753 |
|3 |   MERGE GROUP BY               |             |100      |626 |
|4 |    EXCHANGE IN MERGE SORT DISTR|             |100      |489 |
|5 |     EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |479 |
|6 |      PX PARTITION ITERATOR     |             |100      |479 |
|7 |       MERGE GROUP BY           |             |100      |479 |
|8 |        TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), sort_keys([T_FUN_COUNT_SUM(T_FUN_COUNT(*)), DESC])
  1 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), sort_keys([T_FUN_COUNT_SUM(T_FUN_COUNT(*)), DESC])
  3 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  4 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  5 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), dop=1
  6 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(*)])
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 361(end)  ************** 

***************   Case 362   ***************

SQL: select count(1)+1 from t1 order by count(1)+1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |575 |
|1 | PX COORDINATOR          |        |1        |453 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |453 |
|3 |   MERGE GROUP BY        |        |1        |453 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?)) + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))], [T_FUN_COUNT_SUM(T_FUN_COUNT(1))])
  1 - output([T_FUN_COUNT(?)], [T_FUN_COUNT(1)]), filter(nil)
  2 - output([T_FUN_COUNT(?)], [T_FUN_COUNT(1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(?)], [T_FUN_COUNT(1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)], [T_FUN_COUNT(1)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 362(end)  ************** 

***************   Case 363   ***************

SQL: delete from t7 where exists(select 1 from t8); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |50       |242 |
|1 | SUBPLAN FILTER|    |50       |192 |
|2 |  TABLE SCAN   |t7  |100      |90  |
|3 |  TABLE SCAN   |t8  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t7: ({t7: (t7.c1, t7.c2)})}])
  1 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 363(end)  ************** 

***************   Case 364   ***************

SQL: select t3.c1 from t3, t1 where  t3.c2 = t1.c1 and t3.c1 = 1 and exists(select 'X' from t2 where t2.c2 = t1.c2); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN         |        |1        |383 |
|1 | PX COORDINATOR               |        |1        |89  |
|2 |  EXCHANGE OUT DISTR          |:EX10001|1        |89  |
|3 |   NESTED-LOOP JOIN           |        |1        |89  |
|4 |    EXCHANGE IN DISTR         |        |1        |53  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |52  |
|6 |      TABLE GET               |t3      |1        |52  |
|7 |    PX PARTITION ITERATOR     |        |1        |36  |
|8 |     TABLE GET                |t1      |1        |36  |
|9 | PX COORDINATOR               |        |300      |227 |
|10|  EXCHANGE OUT DISTR          |:EX20000|300      |198 |
|11|   PX PARTITION ITERATOR      |        |300      |198 |
|12|    TABLE SCAN                |t2      |300      |198 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1]), filter(nil), 
      conds([t2.c2 = t1.c2]), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t1.c2]), filter(nil)
  2 - output([t3.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t3.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t3.c2]), batch_join=false
  4 - output([t3.c1], [t3.c2], [PARTITION_ID]), filter(nil)
  5 - (#keys=1, [t3.c2]), output([t3.c1], [t3.c2], [PARTITION_ID]), filter(nil), is_single, dop=1
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t3.c1]), range[1 ; 1], 
      range_cond([t3.c1 = ?])
  7 - output([t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])
  9 - output([t2.c2]), filter(nil)
  10 - output([t2.c2]), filter(nil), dop=1
  11 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 364(end)  ************** 

***************   Case 365   ***************

SQL: select c1, c2 from t3 where c1 in (select a.c1 from t1 a, t2 b where b.c1=100 and a.c2=b.c2); 

======================================================================
|ID|OPERATOR                             |NAME        |EST. ROWS|COST|
----------------------------------------------------------------------
|0 |PX COORDINATOR                       |            |2        |548 |
|1 | EXCHANGE OUT DISTR                  |:EX10002    |2        |547 |
|2 |  MERGE JOIN                         |            |2        |547 |
|3 |   SORT                              |            |5        |103 |
|4 |    EXCHANGE IN DISTR                |            |5        |97  |
|5 |     EXCHANGE OUT DISTR (PKEY)       |:EX10001    |5        |96  |
|6 |      MATERIAL                       |            |5        |96  |
|7 |       NESTED-LOOP JOIN              |            |5        |92  |
|8 |        EXCHANGE IN DISTR            |            |1        |53  |
|9 |         EXCHANGE OUT DISTR (BC2HOST)|:EX10000    |1        |52  |
|10|          TABLE GET                  |b           |1        |52  |
|11|        PX PARTITION ITERATOR        |            |5        |37  |
|12|         TABLE SCAN                  |a(idx_t1_c2)|5        |37  |
|13|   SORT                              |            |200      |415 |
|14|    PX PARTITION ITERATOR            |            |200      |144 |
|15|     TABLE SCAN                      |t3          |200      |144 |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1], [t3.c2]), filter(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), dop=1
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t3.c1 = a.c1]), other_conds(nil)
  3 - output([a.c1]), filter(nil), sort_keys([a.c1, ASC])
  4 - output([a.c1]), filter(nil)
  5 - (#keys=1, [a.c1]), output([a.c1]), filter(nil), dop=1
  6 - output([a.c1]), filter(nil)
  7 - output([a.c1]), filter(nil), 
      conds(nil), nl_params_([b.c2]), batch_join=false
  8 - output([b.c2]), filter(nil)
  9 - output([b.c2]), filter(nil), is_single, dop=1
  10 - output([b.c2]), filter(nil), 
      access([b.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([b.c1]), range[100 ; 100], 
      range_cond([b.c1 = ?])
  11 - output([a.c1]), filter(nil), 
      access all, force partition granule, asc.
  12 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([a.c2], [a.c1]), range(MIN ; MAX), 
      range_cond([a.c2 = ?])
  13 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  14 - output([t3.c1], [t3.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 365(end)  ************** 

***************   Case 366   ***************

SQL: select t7.c1, t8.c1 from t7 inner join t8 on t7.c1 > t8.c2 where t7.c1 = t8.c2 or exists ( select 1); 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |1684     |5066|
|1 | NESTED-LOOP JOIN|    |1684     |4834|
|2 |  TABLE SCAN     |t7  |100      |88  |
|3 |  MATERIAL       |    |100      |127 |
|4 |   TABLE SCAN    |t8  |100      |90  |
|5 | LIMIT           |    |1        |1   |
|6 |  EXPRESSION     |    |1        |1   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t8.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t8.c1]), filter(nil), 
      conds([t7.c1 > t8.c2], [t7.c1 = t8.c2 OR ?]), nl_params_(nil), batch_join=false
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([?]), filter(nil), limit(1), offset(nil)
  6 - output([1]), filter(nil)
      values({1})

*************** Case 366(end)  ************** 

***************   Case 367   ***************

SQL: (select substr('a',1,1) ) union (select 1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 367(end)  ************** 

***************   Case 368   ***************

SQL: select * from t4, t7 where t4.c1 = t7.c1 and t4.c1 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |209 |
|1 | TABLE GET                |t7  |1        |52  |
|2 | TABLE SCAN               |t4  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 368(end)  ************** 

***************   Case 369   ***************

SQL: select * from t4, t7 where t4.c2 = t7.c2 and t4.c2 = 5; 

===============================================================
|ID|OPERATOR                  |NAME            |EST. ROWS|COST|
---------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|                |100      |271 |
|1 | TABLE SCAN               |t4(idx_t4_c2_c3)|100      |92  |
|2 | MATERIAL                 |                |1        |107 |
|3 |  TABLE SCAN              |t7              |1        |107 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c2], [t4.c1], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c1], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(5,MIN,MIN ; 5,MAX,MAX), 
      range_cond([t4.c2 = ?])
  2 - output([t7.c1], [t7.c2]), filter(nil)
  3 - output([t7.c2], [t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 369(end)  ************** 

***************   Case 370   ***************

SQL: select * from t4, t7, t8 where t4.c1 = t7.c1 and t7.c1 = t8.c1 and t4.c1 = 5; 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |100      |262 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |1        |105 |
|2 |  TABLE GET                |t7  |1        |52  |
|3 |  TABLE GET                |t8  |1        |52  |
|4 | TABLE SCAN                |t4  |100      |92  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[5 ; 5], 
      range_cond([t8.c1 = ?])
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 370(end)  ************** 

***************   Case 371   ***************

SQL: select * from t4, t7, t8 where t4.c1 = t7.c1 and t7.c2 = t8.c2 and t4.c1 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |332 |
|1 | TABLE SCAN               |t4  |100      |92  |
|2 | MATERIAL                 |    |1        |166 |
|3 |  NESTED-LOOP JOIN        |    |1        |165 |
|4 |   TABLE GET              |t7  |1        |52  |
|5 |   TABLE SCAN             |t8  |100      |90  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])
  2 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil)
  3 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds([t7.c2 = t8.c2]), nl_params_(nil), batch_join=true
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])
  5 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 371(end)  ************** 

***************   Case 372   ***************

SQL: select * from t4, t7, t8 where t4.c1 = t7.c1 and t7.c2 = t8.c2 and t4.c1 = 5 and t7.c2 = 9; 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1        |56  |
|1 | TABLE GET                 |t7  |1        |53  |
|2 | NESTED-LOOP JOIN CARTESIAN|    |100      |271 |
|3 |  TABLE SCAN               |t4  |100      |92  |
|4 |  MATERIAL                 |    |1        |107 |
|5 |   TABLE SCAN              |t8  |1        |107 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])
  4 - output([t8.c1], [t8.c2]), filter(nil)
  5 - output([t8.c2], [t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 372(end)  ************** 

***************   Case 373   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t4.c1 = 1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |209 |
|1 | TABLE GET                |t7  |1        |52  |
|2 | TABLE SCAN               |t4  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 373(end)  ************** 

***************   Case 374   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t4.c2 = 1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |286 |
|1 | TABLE SCAN|t4  |100      |109 |
|2 | TABLE SCAN|t7  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 = t7.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c2 = ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 374(end)  ************** 

***************   Case 375   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t7.c1 = 1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |209 |
|1 | TABLE GET                |t7  |1        |52  |
|2 | TABLE SCAN               |t4  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 375(end)  ************** 

***************   Case 376   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t7.c2 = 1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |144 |
|1 | TABLE SCAN     |t7  |1        |107 |
|2 | TABLE SCAN     |t4  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN ; MAX), 
      range_cond([t4.c1 = ?])

*************** Case 376(end)  ************** 

***************   Case 377   ***************

SQL: select * from t4 left join t7 on t4.c1 = t7.c1 where t4.c1 = 5; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |100      |159 |
|1 | TABLE SCAN     |t4  |100      |92  |
|2 | TABLE GET      |t7  |1        |52  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 = t7.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])

*************** Case 377(end)  ************** 

***************   Case 378   ***************

SQL: select * from t4 left join t7 on t4.c1 = t7.c1 where t4.c2 = 5; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |100      |286 |
|1 | TABLE SCAN     |t4  |100      |109 |
|2 | TABLE SCAN     |t7  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 = t7.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c2 = ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 378(end)  ************** 

***************   Case 379   ***************

SQL: select * from t4 left join t7 on t4.c1 = t7.c1 where t7.c1 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |209 |
|1 | TABLE GET                |t7  |1        |52  |
|2 | TABLE SCAN               |t4  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 379(end)  ************** 

***************   Case 380   ***************

SQL: select /*+ FROZEN_VERSION(1) */max(c1) as c from t7; 

===============================================
|ID|OPERATOR       |NAME       |EST. ROWS|COST|
-----------------------------------------------
|0 |SCALAR GROUP BY|           |1        |37  |
|1 | SUBPLAN SCAN  |VIEW1      |1        |37  |
|2 |  TABLE SCAN   |t7(Reverse)|1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.c1)])
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      hint(frozen_version:"1-0-0", read_consistency:1), 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 380(end)  ************** 

***************   Case 381   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7,t8 where t4.c1=t7.c1+t8.c1 limit 1); 

============================================
|ID|OPERATOR          |NAME|EST. ROWS|COST |
--------------------------------------------
|0 |SUBPLAN FILTER    |    |50       |21693|
|1 | TABLE SCAN       |t4  |100      |92   |
|2 | LIMIT            |    |1        |216  |
|3 |  NESTED-LOOP JOIN|    |1        |216  |
|4 |   TABLE SCAN     |t7  |2        |37   |
|5 |   MATERIAL       |    |100      |106  |
|6 |    TABLE SCAN    |t8  |100      |88   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t7.c1]), filter(nil), 
      conds([? = t7.c1 + t8.c1]), nl_params_(nil), batch_join=false
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil)
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 381(end)  ************** 

***************   Case 382   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7,t8 where t4.c1+t7.c1=t8.c1 limit 1); 

===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |SUBPLAN FILTER    |    |50       |7394|
|1 | TABLE SCAN       |t4  |100      |92  |
|2 | LIMIT            |    |1        |73  |
|3 |  NESTED-LOOP JOIN|    |1        |73  |
|4 |   TABLE SCAN     |t7  |1        |36  |
|5 |   TABLE GET      |t8  |1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_([? + t7.c1]), batch_join=true
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 382(end)  ************** 

***************   Case 383   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7,t8 where t4.c1+t7.c1=t4.c1+t8.c1 limit 1); 

========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |SUBPLAN FILTER|    |50       |23523|
|1 | TABLE SCAN   |t4  |100      |92   |
|2 | LIMIT        |    |1        |235  |
|3 |  HASH JOIN   |    |1        |234  |
|4 |   TABLE SCAN |t7  |100      |88   |
|5 |   TABLE SCAN |t8  |1        |36   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t7.c1]), filter(nil), 
      equal_conds([? + t7.c1 = ? + t8.c1]), other_conds(nil)
  4 - output([t7.c1], [? + t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([? + t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 383(end)  ************** 

***************   Case 384   ***************

SQL: select * from (select * from t1 where c1 > 0 group by c2) as v order by v.c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |             |100      |666 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |657 |
|2 |  MERGE GROUP BY               |             |100      |657 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |546 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |536 |
|5 |     PX PARTITION ITERATOR     |             |100      |536 |
|6 |      MERGE GROUP BY           |             |100      |536 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |426 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  7 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 384(end)  ************** 

***************   Case 385   ***************

SQL: select * from (select * from t1 where c1 > 0 limit 1) as v order by v.c2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SORT                      |        |1        |38  |
|1 | SUBPLAN SCAN             |v       |1        |37  |
|2 |  LIMIT                   |        |1        |37  |
|3 |   PX COORDINATOR         |        |1        |37  |
|4 |    EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|5 |     PX PARTITION ITERATOR|        |1        |36  |
|6 |      TABLE SCAN          |t1      |1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  1 - output([v.c1], [v.c2]), filter(nil), 
      access([v.c1], [v.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), limit(1), offset(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 385(end)  ************** 

***************   Case 386   ***************

SQL: select * from (select t2.c1 from t1,t2 where t1.c1=t2.c1 limit 1) v order by v.c1; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |SORT                             |        |1        |74  |
|1 | SUBPLAN SCAN                    |v       |1        |74  |
|2 |  LIMIT                          |        |1        |74  |
|3 |   PX COORDINATOR                |        |1        |73  |
|4 |    EXCHANGE OUT DISTR           |:EX10001|1        |73  |
|5 |     LIMIT                       |        |1        |73  |
|6 |      NESTED-LOOP JOIN           |        |1        |73  |
|7 |       EXCHANGE IN DISTR         |        |1        |36  |
|8 |        EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |36  |
|9 |         PX PARTITION ITERATOR   |        |1        |36  |
|10|          TABLE SCAN             |t2      |1        |36  |
|11|       PX PARTITION ITERATOR     |        |1        |36  |
|12|        TABLE GET                |t1      |1        |36  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([v.c1]), filter(nil), sort_keys([v.c1, ASC])
  1 - output([v.c1]), filter(nil), 
      access([v.c1])
  2 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t2.c1]), filter(nil)
  4 - output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  7 - output([t2.c1], [PARTITION_ID]), filter(nil)
  8 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([1]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 386(end)  ************** 

***************   Case 387   ***************

SQL: select * from (select t1.c1 from t1,t2 where t1.c1=t2.c1 limit 1) v order by v.c1; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |SORT                             |        |1        |74  |
|1 | SUBPLAN SCAN                    |v       |1        |74  |
|2 |  LIMIT                          |        |1        |74  |
|3 |   PX COORDINATOR                |        |1        |73  |
|4 |    EXCHANGE OUT DISTR           |:EX10001|1        |73  |
|5 |     LIMIT                       |        |1        |73  |
|6 |      NESTED-LOOP JOIN           |        |1        |73  |
|7 |       EXCHANGE IN DISTR         |        |1        |36  |
|8 |        EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |36  |
|9 |         PX PARTITION ITERATOR   |        |1        |36  |
|10|          TABLE SCAN             |t2      |1        |36  |
|11|       PX PARTITION ITERATOR     |        |1        |36  |
|12|        TABLE GET                |t1      |1        |36  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([v.c1]), filter(nil), sort_keys([v.c1, ASC])
  1 - output([v.c1]), filter(nil), 
      access([v.c1])
  2 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  7 - output([t2.c1], [PARTITION_ID]), filter(nil)
  8 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 387(end)  ************** 

***************   Case 388   ***************

SQL: select c1 from t1 having false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), startup_filter([0]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 388(end)  ************** 

***************   Case 389   ***************

SQL: select min(c1) from t1 having false; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |SCALAR GROUP BY              |        |0        |37  |
|1 | SUBPLAN SCAN                |VIEW1   |1        |37  |
|2 |  LIMIT                      |        |1        |37  |
|3 |   PX COORDINATOR MERGE SORT |        |1        |37  |
|4 |    EXCHANGE OUT DISTR       |:EX10000|1        |37  |
|5 |     SORT                    |        |1        |37  |
|6 |      PX PARTITION ITERATOR  |        |1        |36  |
|7 |       TABLE SCAN            |t1      |1        |36  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.c1)]), filter([0]), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.c1)])
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 389(end)  ************** 

***************   Case 390   ***************

SQL: select count(1) from t1 having false; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |0        |522 |
|1 | PX COORDINATOR          |        |0        |426 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|0        |426 |
|3 |   MERGE GROUP BY        |        |0        |426 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter([0]), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  1 - output([T_FUN_COUNT(?)]), filter(nil)
  2 - output([T_FUN_COUNT(?)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 390(end)  ************** 

***************   Case 391   ***************

SQL: select c1 from t1 group by c1 having false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), startup_filter([0]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 391(end)  ************** 

***************   Case 392   ***************

SQL: select c1 from t1 group by c1 having c1>0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 392(end)  ************** 

***************   Case 393   ***************

SQL: select c1 from t1 group by c1 having count(c2)>0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |167      |399 |
|1 | EXCHANGE OUT DISTR    |:EX10000|167      |384 |
|2 |  PX PARTITION ITERATOR|        |167      |384 |
|3 |   TABLE SCAN          |t1      |167      |384 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter([CASE WHEN (T_OP_IS_NOT, t1.c2, NULL, 0) THEN 1 ELSE 0 END > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 393(end)  ************** 

***************   Case 394   ***************

SQL: select count(c1) from t1 group by c1 having count(c2)>0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |167      |399 |
|1 | EXCHANGE OUT DISTR    |:EX10000|167      |384 |
|2 |  PX PARTITION ITERATOR|        |167      |384 |
|3 |   TABLE SCAN          |t1      |167      |384 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil)
  1 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), dop=1
  2 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      force partition granule, asc.
  3 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter([CASE WHEN (T_OP_IS_NOT, t1.c2, NULL, 0) THEN 1 ELSE 0 END > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 394(end)  ************** 

***************   Case 395   ***************

SQL: select c1 from t1 group by c1 having c1 in (select c1 from t1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 395(end)  ************** 

***************   Case 396   ***************

SQL: select count(c1) from t1 group by c1 having c1 in (select c1 from t1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil)
  1 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), dop=1
  2 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      force partition granule, asc.
  3 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 396(end)  ************** 

***************   Case 397   ***************

SQL: select c1 from t1 group by c1 having 1 in (select c1 from t1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |500      |730 |
|1 | PX COORDINATOR           |        |1        |52  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |52  |
|3 |   TABLE GET              |t1      |1        |52  |
|4 | PX COORDINATOR           |        |500      |354 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|500      |331 |
|6 |   PX PARTITION ITERATOR  |        |500      |331 |
|7 |    TABLE SCAN            |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), is_single, dop=1
  3 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 397(end)  ************** 

***************   Case 398   ***************

SQL: select count(c1) from t1 group by c1 having 1 in (select c1 from t1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |500      |730 |
|1 | PX COORDINATOR           |        |1        |52  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |52  |
|3 |   TABLE GET              |t1      |1        |52  |
|4 | PX COORDINATOR           |        |500      |354 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|500      |331 |
|6 |   PX PARTITION ITERATOR  |        |500      |331 |
|7 |    TABLE SCAN            |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), is_single, dop=1
  3 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 398(end)  ************** 

***************   Case 399   ***************

SQL: select c1 from t1 group by c1 having c1 in (select t2.c1 from t2 where t1.c1=t2.c2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |279 |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |278 |
|2 |  NESTED-LOOP JOIN           |        |2        |278 |
|3 |   EXCHANGE IN DISTR         |        |2        |223 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|2        |223 |
|5 |     PX PARTITION ITERATOR   |        |2        |223 |
|6 |      TABLE SCAN             |t2      |2        |223 |
|7 |   PX PARTITION ITERATOR     |        |1        |36  |
|8 |    TABLE GET                |t1      |1        |36  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2]), batch_join=false
  3 - output([t2.c2], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([t2.c2], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t2.c2]), filter([t2.c2 = t2.c1]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 399(end)  ************** 

***************   Case 400   ***************

SQL: select count(c1) from t1 group by c1 having c1 in (select t2.c1 from t2 where t1.c1=t2.c2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |279 |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |278 |
|2 |  NESTED-LOOP JOIN           |        |2        |278 |
|3 |   EXCHANGE IN DISTR         |        |2        |223 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|2        |223 |
|5 |     PX PARTITION ITERATOR   |        |2        |223 |
|6 |      TABLE SCAN             |t2      |2        |223 |
|7 |   PX PARTITION ITERATOR     |        |1        |36  |
|8 |    TABLE GET                |t1      |1        |36  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil)
  1 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), dop=1
  2 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      conds(nil), nl_params_([t2.c2]), batch_join=false
  3 - output([t2.c2], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([t2.c2], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t2.c2]), filter([t2.c2 = t2.c1]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 400(end)  ************** 

***************   Case 401   ***************

SQL: select c1 from t1 where c1 in (select c1 from t2 where c2 >= some(select c1 from t3 where t1.c2=t3.c1)); 

============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST  |
------------------------------------------------------------
|0 |SUBPLAN FILTER               |        |250      |197449|
|1 | PX COORDINATOR              |        |500      |389   |
|2 |  EXCHANGE OUT DISTR         |:EX10000|500      |342   |
|3 |   PX PARTITION ITERATOR     |        |500      |342   |
|4 |    TABLE SCAN               |t1      |500      |342   |
|5 | NESTED-LOOP JOIN            |        |100      |381   |
|6 |  SUBPLAN SCAN               |VIEW1   |1        |37    |
|7 |   SCALAR GROUP BY           |        |1        |37    |
|8 |    SUBPLAN SCAN             |VIEW2   |1        |37    |
|9 |     LIMIT                   |        |1        |37    |
|10|      PX COORDINATOR         |        |1        |36    |
|11|       EXCHANGE OUT DISTR    |:EX20000|1        |36    |
|12|        PX PARTITION ITERATOR|        |1        |36    |
|13|         TABLE GET           |t3      |1        |36    |
|14|  PX COORDINATOR             |        |300      |227   |
|15|   EXCHANGE OUT DISTR        |:EX30000|300      |198   |
|16|    PX PARTITION ITERATOR    |        |300      |198   |
|17|     TABLE SCAN              |t2      |300      |198   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([t1.c1 = ANY(subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), 
      conds([t2.c2 >= VIEW1.c1]), nl_params_(nil), batch_join=false
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([T_FUN_MIN(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  8 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  9 - output([t3.c1]), filter(nil), limit(1), offset(nil)
  10 - output([t3.c1]), filter(nil)
  11 - output([t3.c1]), filter(nil), dop=1
  12 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  13 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t3.c1])
  14 - output([t2.c1], [t2.c2]), filter(nil)
  15 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  16 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  17 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 401(end)  ************** 

***************   Case 402   ***************

SQL: select * from (select c1 from t4 group by "adg") as a; 

================================================
|ID|OPERATOR      |NAME         |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE GROUP BY|             |1        |68  |
|1 | TABLE SCAN   |t4(idx_t4_c2)|100      |54  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 402(end)  ************** 

***************   Case 403   ***************

SQL: select c1 from t1 having count(c2)>0; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |533 |
|1 | PX COORDINATOR          |        |1        |437 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |437 |
|3 |   MERGE GROUP BY        |        |1        |437 |
|4 |    PX PARTITION ITERATOR|        |500      |342 |
|5 |     TABLE SCAN          |t1      |500      |342 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c2)) > ?]), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c2))])
  1 - output([t1.c1], [T_FUN_COUNT(t1.c2)]), filter(nil)
  2 - output([t1.c1], [T_FUN_COUNT(t1.c2)]), filter(nil), dop=1
  3 - output([t1.c1], [T_FUN_COUNT(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c2)])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 403(end)  ************** 

***************   Case 404   ***************

SQL: select c1 from t1 having 3<(select 2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), startup_filter([?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 404(end)  ************** 

***************   Case 405   ***************

SQL: select c1 from t1 having c1>(select 1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(1 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 405(end)  ************** 

***************   Case 406   ***************

SQL: select c1 from t1 group by -1 having 3<(select 2); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |MERGE GROUP BY           |        |1        |469 |
|1 | PX COORDINATOR          |        |1        |400 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |400 |
|3 |   MERGE GROUP BY        |        |1        |400 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      group(nil), agg_func(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), startup_filter([?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 406(end)  ************** 

***************   Case 407   ***************

SQL: select * from t4 where c1 =1 order by c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |100      |92  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 407(end)  ************** 

***************   Case 408   ***************

SQL: select * from t4 where c1 =1 group by c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |100      |92  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 408(end)  ************** 

***************   Case 409   ***************

SQL: select * from t19 where c1 = 1 order by c2, c3, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |100      |97  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter(nil), 
      access([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 409(end)  ************** 

***************   Case 410   ***************

SQL: select * from t19 where c1 = 1 group by c2, c3, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |100      |97  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter(nil), 
      access([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 410(end)  ************** 

***************   Case 411   ***************

SQL: select * from t19 where c1 = 1 and c3 = 1 order by c2, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |1        |114 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter([t19.c3 = ?]), 
      access([t19.c1], [t19.c3], [t19.c2], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 411(end)  ************** 

***************   Case 412   ***************

SQL: select * from t19 where c1 = 1 and c3 = 1 group by c2, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |1        |114 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter([t19.c3 = ?]), 
      access([t19.c1], [t19.c3], [t19.c2], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 412(end)  ************** 

***************   Case 413   ***************

SQL: select c1 from t7 where c2 =1 order by c2, c1 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|1        |107 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 413(end)  ************** 

***************   Case 414   ***************

SQL: select c1 from t7 where c2 in (1) order by c2, c1 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|1        |107 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 414(end)  ************** 

***************   Case 415   ***************

SQL: select c1 from t7 group by (select c1 from t8), c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |100      |296 |
|1 | SUBPLAN FILTER|    |100      |192 |
|2 |  TABLE SCAN   |t7  |100      |90  |
|3 |  TABLE SCAN   |t8  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 415(end)  ************** 

***************   Case 416   ***************

SQL: select c1 from t7 group by (select c1 from t8) desc, c2 desc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |100      |341 |
|1 | SORT           |    |100      |319 |
|2 |  SUBPLAN FILTER|    |100      |192 |
|3 |   TABLE SCAN   |t7  |100      |90  |
|4 |   TABLE SCAN   |t8  |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, DESC])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 416(end)  ************** 

***************   Case 417   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc, c2 asc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |100      |341 |
|1 | SORT           |    |100      |319 |
|2 |  SUBPLAN FILTER|    |100      |192 |
|3 |   TABLE SCAN   |t7  |100      |90  |
|4 |   TABLE SCAN   |t8  |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, ASC])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 417(end)  ************** 

***************   Case 418   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc, c2 asc order by c1 desc; 

================================================
|ID|OPERATOR        |NAME       |EST. ROWS|COST|
------------------------------------------------
|0 |SORT            |           |100      |423 |
|1 | HASH GROUP BY  |           |100      |296 |
|2 |  SUBPLAN FILTER|           |100      |192 |
|3 |   TABLE SCAN   |t7(Reverse)|100      |90  |
|4 |   TABLE SCAN   |t8         |100      |88  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c1, DESC])
  1 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 418(end)  ************** 

***************   Case 419   ***************

SQL: select c1 from t7 group by c2 desc order by c2 asc; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |100      |239 |
|1 | SORT         |    |100      |217 |
|2 |  TABLE SCAN  |t7  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, ASC])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 419(end)  ************** 

***************   Case 420   ***************

SQL: select c1 from t7 group by (select c1 from t8) desc, c2 desc order by (select c1 from t8) asc, c2 asc; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SORT             |    |100      |524 |
|1 | SUBPLAN FILTER  |    |100      |397 |
|2 |  HASH GROUP BY  |    |100      |296 |
|3 |   SUBPLAN FILTER|    |100      |192 |
|4 |    TABLE SCAN   |t7  |100      |90  |
|5 |    TABLE SCAN   |t8  |100      |88  |
|6 |  TABLE SCAN     |t8  |100      |88  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 420(end)  ************** 

***************   Case 421   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc , c2 asc  order by (select c1 from t8) desc, c2 asc; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SORT             |    |100      |524 |
|1 | SUBPLAN FILTER  |    |100      |397 |
|2 |  HASH GROUP BY  |    |100      |296 |
|3 |   SUBPLAN FILTER|    |100      |192 |
|4 |    TABLE SCAN   |t7  |100      |90  |
|5 |    TABLE SCAN   |t8  |100      |88  |
|6 |  TABLE SCAN     |t8  |100      |88  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 421(end)  ************** 

***************   Case 422   ***************

SQL: select c1 from t7 group by (select c1 from t8)     , c2      order by (select c1 from t8) desc, c2 desc; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SORT             |    |100      |524 |
|1 | SUBPLAN FILTER  |    |100      |397 |
|2 |  HASH GROUP BY  |    |100      |296 |
|3 |   SUBPLAN FILTER|    |100      |192 |
|4 |    TABLE SCAN   |t7  |100      |90  |
|5 |    TABLE SCAN   |t8  |100      |88  |
|6 |  TABLE SCAN     |t8  |100      |88  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, DESC])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 422(end)  ************** 

***************   Case 423   ***************

SQL: select c1 from t7 group by (select c1 from t8) desc, c2 desc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |100      |341 |
|1 | SORT           |    |100      |319 |
|2 |  SUBPLAN FILTER|    |100      |192 |
|3 |   TABLE SCAN   |t7  |100      |90  |
|4 |   TABLE SCAN   |t8  |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, DESC])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 423(end)  ************** 

***************   Case 424   ***************

SQL: select c1 from t7 group by c2 desc order by c2 asc, c1 desc; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |100      |239 |
|1 | SORT         |    |100      |217 |
|2 |  TABLE SCAN  |t7  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, ASC])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 424(end)  ************** 

***************   Case 425   ***************

SQL: select c1 from t7 group by c2 order by c2 asc, c1 desc; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |100      |239 |
|1 | SORT         |    |100      |217 |
|2 |  TABLE SCAN  |t7  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, ASC])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 425(end)  ************** 

***************   Case 426   ***************

SQL: select c1 from t7 order by c2 asc, c1 desc; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |100      |218 |
|1 | TABLE SCAN|t7  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC], [t7.c1, DESC])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 426(end)  ************** 

***************   Case 427   ***************

SQL: select c1 from t7 group by (select c1 from t8) order by (select c1 from t8) asc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |291 |
|1 | MERGE GROUP BY |    |1        |203 |
|2 |  SUBPLAN FILTER|    |100      |189 |
|3 |   TABLE SCAN   |t7  |100      |88  |
|4 |   TABLE SCAN   |t8  |100      |88  |
|5 | TABLE SCAN     |t8  |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      group(nil), agg_func(nil)
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 427(end)  ************** 

***************   Case 428   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE GROUP BY |    |1        |203 |
|1 | SUBPLAN FILTER|    |100      |189 |
|2 |  TABLE SCAN   |t7  |100      |88  |
|3 |  TABLE SCAN   |t8  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 428(end)  ************** 

***************   Case 429   ***************

SQL: select c1 from t7 group by c2 order by c2, c1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |100      |239 |
|1 | SORT         |    |100      |217 |
|2 |  TABLE SCAN  |t7  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, ASC])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 429(end)  ************** 

***************   Case 430   ***************

SQL: select avg(c2), count(c2) from t2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |345 |
|1 | PX COORDINATOR          |        |1        |271 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |271 |
|3 |   MERGE GROUP BY        |        |1        |271 |
|4 |    PX PARTITION ITERATOR|        |300      |198 |
|5 |     TABLE SCAN          |t2      |300      |198 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t2.c2)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))], [T_FUN_SUM(T_FUN_SUM(t2.c2))])
  1 - output([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)]), filter(nil)
  2 - output([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c2)])
  4 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 430(end)  ************** 

***************   Case 431   ***************

SQL: select count(c2) from t7 group by c2; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |100      |200 |
|1 | TABLE SCAN  |t7  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t7.c2)]), filter(nil), 
      group([t7.c2]), agg_func([T_FUN_COUNT(t7.c2)])
  1 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 431(end)  ************** 

***************   Case 432   ***************

SQL: select sum(c2) from t7 group by c2; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |100      |200 |
|1 | TABLE SCAN  |t7  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t7.c2)]), filter(nil), 
      group([t7.c2]), agg_func([T_FUN_SUM(t7.c2)])
  1 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 432(end)  ************** 

***************   Case 433   ***************

SQL: select avg(distinct c1), count(c2) from t2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |376 |
|1 | PX COORDINATOR          |        |1        |287 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |287 |
|3 |   MERGE GROUP BY        |        |1        |287 |
|4 |    PX PARTITION ITERATOR|        |300      |198 |
|5 |     TABLE SCAN          |t2      |300      |198 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t2.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))], [T_FUN_SUM(T_FUN_SUM(t2.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  1 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)], [T_FUN_COUNT(t2.c2)]), filter(nil)
  2 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)], [T_FUN_COUNT(t2.c2)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)], [T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)])
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 433(end)  ************** 

***************   Case 434   ***************

SQL: select avg(distinct c1), count(c2) from t2 group by c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |227 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |198 |
|2 |  PX PARTITION ITERATOR|        |300      |198 |
|3 |   TABLE SCAN          |t2      |300      |198 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t2.c1, DECIMAL(11, 0)) / CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END], [CASE WHEN (T_OP_IS_NOT, t2.c2, NULL, 0) THEN 1 ELSE 0 END]), filter(nil)
  1 - output([cast(t2.c1, DECIMAL(11, 0)) / CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END], [CASE WHEN (T_OP_IS_NOT, t2.c2, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), dop=1
  2 - output([cast(t2.c1, DECIMAL(11, 0)) / CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END], [CASE WHEN (T_OP_IS_NOT, t2.c2, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      force partition granule, asc.
  3 - output([cast(t2.c1, DECIMAL(11, 0)) / CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END], [CASE WHEN (T_OP_IS_NOT, t2.c2, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 434(end)  ************** 

***************   Case 435   ***************

SQL: select count(distinct c1) from t2 group by c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |589 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |579 |
|2 |  HASH GROUP BY              |        |100      |579 |
|3 |   EXCHANGE IN DISTR         |        |100      |394 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |384 |
|5 |     HASH GROUP BY           |        |100      |384 |
|6 |      PX PARTITION ITERATOR  |        |300      |198 |
|7 |       TABLE SCAN            |t2      |300      |198 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  3 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(t2.c1)])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 435(end)  ************** 

***************   Case 436   ***************

SQL: select count(distinct c1, c2) from t2 group by c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |589 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |579 |
|2 |  HASH GROUP BY              |        |100      |579 |
|3 |   EXCHANGE IN DISTR         |        |100      |394 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |384 |
|5 |     HASH GROUP BY           |        |100      |384 |
|6 |      PX PARTITION ITERATOR  |        |300      |198 |
|7 |       TABLE SCAN            |t2      |300      |198 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2))]), filter(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2))]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2))])
  3 - output([T_FUN_COUNT(t2.c1, t2.c2)], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([T_FUN_COUNT(t2.c1, t2.c2)], [t2.c2]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(t2.c1, t2.c2)], [t2.c2]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(t2.c1, t2.c2)])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 436(end)  ************** 

***************   Case 437   ***************

SQL: select sum(distinct c1) from t7 group by c2; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |100      |200 |
|1 | TABLE SCAN  |t7  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group([t7.c2]), agg_func([T_FUN_SUM(t7.c1)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 437(end)  ************** 

***************   Case 438   ***************

SQL: select count(distinct c2) from t2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |313 |
|1 | PX COORDINATOR          |        |1        |256 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |255 |
|3 |   HASH GROUP BY         |        |1        |255 |
|4 |    PX PARTITION ITERATOR|        |300      |198 |
|5 |     TABLE SCAN          |t2      |300      |198 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(distinct t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(distinct t2.c2)])
  1 - output([t2.c2]), filter(nil)
  2 - output([t2.c2]), filter(nil), dop=1
  3 - output([t2.c2]), filter(nil), 
      group([t2.c2]), agg_func(nil)
  4 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 438(end)  ************** 

***************   Case 439   ***************

SQL: select sum(distinct c2) from t17; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |319 |
|1 | PX COORDINATOR          |        |1        |262 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |262 |
|3 |   HASH GROUP BY         |        |1        |262 |
|4 |    PX PARTITION ITERATOR|        |300      |205 |
|5 |     TABLE SCAN          |t17     |300      |205 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct t17.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(distinct t17.c2)])
  1 - output([t17.c2]), filter(nil)
  2 - output([t17.c2]), filter(nil), dop=1
  3 - output([t17.c2]), filter(nil), 
      group([t17.c2]), agg_func(nil)
  4 - output([t17.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t17.c2]), filter(nil), 
      access([t17.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 439(end)  ************** 

***************   Case 440   ***************

SQL: select avg(distinct c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |688 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |679 |
|2 |  MERGE GROUP BY               |             |100      |679 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |515 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |506 |
|5 |     PX PARTITION ITERATOR     |             |100      |506 |
|6 |      MERGE GROUP BY           |             |100      |506 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 440(end)  ************** 

***************   Case 441   ***************

SQL: select count(distinct c2) from t2 group by c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |542 |
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |532 |
|2 |  MERGE GROUP BY              |        |100      |532 |
|3 |   SORT                       |        |100      |505 |
|4 |    EXCHANGE IN DISTR         |        |100      |378 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|100      |368 |
|6 |      HASH GROUP BY           |        |100      |368 |
|7 |       PX PARTITION ITERATOR  |        |300      |198 |
|8 |        TABLE SCAN            |t2      |300      |198 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(distinct t2.c2)]), filter(nil)
  1 - output([T_FUN_COUNT(distinct t2.c2)]), filter(nil), dop=1
  2 - output([T_FUN_COUNT(distinct t2.c2)]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(distinct t2.c2)])
  3 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  4 - output([t2.c2]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  6 - output([t2.c2]), filter(nil), 
      group([t2.c2]), agg_func(nil)
  7 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 441(end)  ************** 

***************   Case 442   ***************

SQL: select count(distinct c1) from t2 group by c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |589 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |579 |
|2 |  HASH GROUP BY              |        |100      |579 |
|3 |   EXCHANGE IN DISTR         |        |100      |394 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |384 |
|5 |     HASH GROUP BY           |        |100      |384 |
|6 |      PX PARTITION ITERATOR  |        |300      |198 |
|7 |       TABLE SCAN            |t2      |300      |198 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  3 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(t2.c1)])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 442(end)  ************** 

***************   Case 443   ***************

SQL: select sum(distinct c2) from t15 group by c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |3187|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |3159|
|2 |  MERGE GROUP BY              |        |100      |3159|
|3 |   SORT                       |        |400      |3049|
|4 |    EXCHANGE IN DISTR         |        |400      |833 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|400      |719 |
|6 |      HASH GROUP BY           |        |400      |719 |
|7 |       PX PARTITION ITERATOR  |        |400      |279 |
|8 |        TABLE SCAN            |t15     |400      |279 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct t15.c2)]), filter(nil)
  1 - output([T_FUN_SUM(distinct t15.c2)]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t15.c2)]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c2)])
  3 - output([t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  4 - output([t15.c2], [t15.c3]), filter(nil)
  5 - (#keys=1, [t15.c3, VARCHAR, 32]), output([t15.c2], [t15.c3]), filter(nil), dop=1
  6 - output([t15.c2], [t15.c3]), filter(nil), 
      group([t15.c3], [t15.c2]), agg_func(nil)
  7 - output([t15.c2], [t15.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t15.c2], [t15.c3]), filter(nil), 
      access([t15.c2], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 443(end)  ************** 

***************   Case 444   ***************

SQL: select sum(distinct c1) from t15 group by c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |3086|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |3062|
|2 |  MERGE GROUP BY              |        |100      |3062|
|3 |   SORT                       |        |400      |2952|
|4 |    EXCHANGE IN DISTR         |        |400      |814 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|400      |719 |
|6 |      HASH GROUP BY           |        |400      |719 |
|7 |       PX PARTITION ITERATOR  |        |400      |279 |
|8 |        TABLE SCAN            |t15     |400      |279 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct t15.c1)]), filter(nil)
  1 - output([T_FUN_SUM(distinct t15.c1)]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t15.c1)]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c1)])
  3 - output([t15.c1], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  4 - output([t15.c1], [t15.c3]), filter(nil)
  5 - (#keys=1, [t15.c3, VARCHAR, 32]), output([t15.c1], [t15.c3]), filter(nil), dop=1
  6 - output([t15.c1], [t15.c3]), filter(nil), 
      group([t15.c3], [t15.c1]), agg_func(nil)
  7 - output([t15.c1], [t15.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t15.c1], [t15.c3]), filter(nil), 
      access([t15.c1], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 444(end)  ************** 

***************   Case 445   ***************

SQL: select avg(distinct c2) from t15 group by c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |3208|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |3180|
|2 |  MERGE GROUP BY              |        |100      |3180|
|3 |   SORT                       |        |400      |3049|
|4 |    EXCHANGE IN DISTR         |        |400      |833 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|400      |719 |
|6 |      HASH GROUP BY           |        |400      |719 |
|7 |       PX PARTITION ITERATOR  |        |400      |279 |
|8 |        TABLE SCAN            |t15     |400      |279 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct t15.c2) / T_FUN_COUNT(distinct t15.c2)]), filter(nil)
  1 - output([T_FUN_SUM(distinct t15.c2) / T_FUN_COUNT(distinct t15.c2)]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t15.c2) / T_FUN_COUNT(distinct t15.c2)]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c2)], [T_FUN_COUNT(distinct t15.c2)])
  3 - output([t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  4 - output([t15.c2], [t15.c3]), filter(nil)
  5 - (#keys=1, [t15.c3, VARCHAR, 32]), output([t15.c2], [t15.c3]), filter(nil), dop=1
  6 - output([t15.c2], [t15.c3]), filter(nil), 
      group([t15.c3], [t15.c2]), agg_func(nil)
  7 - output([t15.c2], [t15.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t15.c2], [t15.c3]), filter(nil), 
      access([t15.c2], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 445(end)  ************** 

***************   Case 446   ***************

SQL: select avg(distinct c1) from t15 group by c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |3107|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |3083|
|2 |  MERGE GROUP BY              |        |100      |3083|
|3 |   SORT                       |        |400      |2952|
|4 |    EXCHANGE IN DISTR         |        |400      |814 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|400      |719 |
|6 |      HASH GROUP BY           |        |400      |719 |
|7 |       PX PARTITION ITERATOR  |        |400      |279 |
|8 |        TABLE SCAN            |t15     |400      |279 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct t15.c1) / T_FUN_COUNT(distinct t15.c1)]), filter(nil)
  1 - output([T_FUN_SUM(distinct t15.c1) / T_FUN_COUNT(distinct t15.c1)]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t15.c1) / T_FUN_COUNT(distinct t15.c1)]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c1)], [T_FUN_COUNT(distinct t15.c1)])
  3 - output([t15.c1], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  4 - output([t15.c1], [t15.c3]), filter(nil)
  5 - (#keys=1, [t15.c3, VARCHAR, 32]), output([t15.c1], [t15.c3]), filter(nil), dop=1
  6 - output([t15.c1], [t15.c3]), filter(nil), 
      group([t15.c3], [t15.c1]), agg_func(nil)
  7 - output([t15.c1], [t15.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t15.c1], [t15.c3]), filter(nil), 
      access([t15.c1], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 446(end)  ************** 

***************   Case 447   ***************

SQL: select count(distinct c1, c2) from t15 group by c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |3219|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |3191|
|2 |  MERGE GROUP BY              |        |100      |3191|
|3 |   SORT                       |        |400      |3081|
|4 |    EXCHANGE IN DISTR         |        |400      |865 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|400      |751 |
|6 |      HASH GROUP BY           |        |400      |751 |
|7 |       PX PARTITION ITERATOR  |        |400      |287 |
|8 |        TABLE SCAN            |t15     |400      |287 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(distinct t15.c1, t15.c2)]), filter(nil)
  1 - output([T_FUN_COUNT(distinct t15.c1, t15.c2)]), filter(nil), dop=1
  2 - output([T_FUN_COUNT(distinct t15.c1, t15.c2)]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_COUNT(distinct t15.c1, t15.c2)])
  3 - output([t15.c1], [t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  4 - output([t15.c1], [t15.c2], [t15.c3]), filter(nil)
  5 - (#keys=1, [t15.c3, VARCHAR, 32]), output([t15.c1], [t15.c2], [t15.c3]), filter(nil), dop=1
  6 - output([t15.c1], [t15.c2], [t15.c3]), filter(nil), 
      group([t15.c3], [t15.c1], [t15.c2]), agg_func(nil)
  7 - output([t15.c1], [t15.c2], [t15.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t15.c1], [t15.c2], [t15.c3]), filter(nil), 
      access([t15.c1], [t15.c2], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 447(end)  ************** 

***************   Case 448   ***************

SQL: select count(distinct c1, c2) from t17 group by c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |1154|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |1140|
|2 |  MERGE GROUP BY              |        |100      |1140|
|3 |   SORT                       |        |300      |1057|
|4 |    EXCHANGE IN DISTR         |        |300      |578 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |535 |
|6 |      HASH GROUP BY           |        |300      |535 |
|7 |       PX PARTITION ITERATOR  |        |300      |205 |
|8 |        TABLE SCAN            |t17     |300      |205 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(distinct t17.c1, t17.c2)]), filter(nil)
  1 - output([T_FUN_COUNT(distinct t17.c1, t17.c2)]), filter(nil), dop=1
  2 - output([T_FUN_COUNT(distinct t17.c1, t17.c2)]), filter(nil), 
      group([t17.c2]), agg_func([T_FUN_COUNT(distinct t17.c1, t17.c2)])
  3 - output([t17.c1], [t17.c2]), filter(nil), sort_keys([t17.c2, ASC])
  4 - output([t17.c1], [t17.c2]), filter(nil)
  5 - (#keys=1, [t17.c2]), output([t17.c1], [t17.c2]), filter(nil), dop=1
  6 - output([t17.c1], [t17.c2]), filter(nil), 
      group([t17.c2], [t17.c1]), agg_func(nil)
  7 - output([t17.c2], [t17.c1]), filter(nil), 
      force partition granule, asc.
  8 - output([t17.c2], [t17.c1]), filter(nil), 
      access([t17.c2], [t17.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 448(end)  ************** 

***************   Case 449   ***************

SQL: select sum(distinct c1) from t17 group by c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |100      |1154|
|1 | EXCHANGE OUT DISTR           |:EX10001|100      |1140|
|2 |  MERGE GROUP BY              |        |100      |1140|
|3 |   SORT                       |        |300      |1057|
|4 |    EXCHANGE IN DISTR         |        |300      |578 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |535 |
|6 |      HASH GROUP BY           |        |300      |535 |
|7 |       PX PARTITION ITERATOR  |        |300      |205 |
|8 |        TABLE SCAN            |t17     |300      |205 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct t17.c1)]), filter(nil)
  1 - output([T_FUN_SUM(distinct t17.c1)]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t17.c1)]), filter(nil), 
      group([t17.c2]), agg_func([T_FUN_SUM(distinct t17.c1)])
  3 - output([t17.c1], [t17.c2]), filter(nil), sort_keys([t17.c2, ASC])
  4 - output([t17.c1], [t17.c2]), filter(nil)
  5 - (#keys=1, [t17.c2]), output([t17.c1], [t17.c2]), filter(nil), dop=1
  6 - output([t17.c1], [t17.c2]), filter(nil), 
      group([t17.c2], [t17.c1]), agg_func(nil)
  7 - output([t17.c2], [t17.c1]), filter(nil), 
      force partition granule, asc.
  8 - output([t17.c2], [t17.c1]), filter(nil), 
      access([t17.c2], [t17.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 449(end)  ************** 

***************   Case 450   ***************

SQL: select/*+index(t5 idx_t5_c3)*/ t3.c2 from t5, t3; 

=============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST |
-------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|             |60000    |43512|
|1 | PX COORDINATOR           |             |300      |191  |
|2 |  EXCHANGE OUT DISTR      |:EX10000     |300      |162  |
|3 |   PX PARTITION ITERATOR  |             |300      |162  |
|4 |    TABLE SCAN            |t5(idx_t5_c3)|300      |162  |
|5 | MATERIAL                 |             |200      |237  |
|6 |  PX COORDINATOR          |             |200      |163  |
|7 |   EXCHANGE OUT DISTR     |:EX20000     |200      |144  |
|8 |    PX PARTITION ITERATOR |             |200      |144  |
|9 |     TABLE SCAN           |t3           |200      |144  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), dop=1
  3 - output([1]), filter(nil), 
      force partition granule, asc.
  4 - output([1]), filter(nil), 
      access([t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t3.c2]), filter(nil)
  6 - output([t3.c2]), filter(nil)
  7 - output([t3.c2]), filter(nil), dop=1
  8 - output([t3.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 450(end)  ************** 

***************   Case 451   ***************

SQL: SELECT * FROM (SELECT c1, c2 FROM t1 GROUP BY c1) v1 JOIN (SELECT c1, c2 FROM t2 WHERE c2 IN (2,3)) v2 ON v1.c1=v2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |6        |438 |
|1 | EXCHANGE OUT DISTR          |:EX10001|6        |437 |
|2 |  NESTED-LOOP JOIN           |        |6        |437 |
|3 |   EXCHANGE IN DISTR         |        |6        |224 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|6        |223 |
|5 |     PX PARTITION ITERATOR   |        |6        |223 |
|6 |      TABLE SCAN             |t2      |6        |223 |
|7 |   PX PARTITION ITERATOR     |        |1        |36  |
|8 |    TABLE GET                |t1      |1        |36  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [t2.c2], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t2.c1], [t2.c2]), filter([t2.c2 IN (?, ?)]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 451(end)  ************** 

***************   Case 452   ***************

SQL: SELECT  GRANDPARENT1 . col_varchar_10 AS G1 FROM CC AS GRANDPARENT1 LEFT JOIN CC AS GRANDPARENT2 USING ( col_varchar_10 ) WHERE GRANDPARENT1 . `col_varchar_10` IN ( SELECT  PARENT1 . `col_varchar_20` AS P1 FROM CC AS PARENT1 WHERE ( ( PARENT1 . `col_varchar_10` > PARENT1 . `col_varchar_20` ) OR NOT ( GRANDPARENT1 . `col_int_key` = 4 OR NOT GRANDPARENT1 . `col_int_key` > 2 ) ) ORDER BY PARENT1 . col_varchar_10 ) AND ( GRANDPARENT1 . col_varchar_10 IS NULL OR GRANDPARENT1 . `col_int_key` >= 3 ); 

================================================
|ID|OPERATOR       |NAME        |EST. ROWS|COST|
------------------------------------------------
|0 |HASH OUTER JOIN|            |82       |899 |
|1 | HASH SEMI JOIN|            |82       |513 |
|2 |  TABLE SCAN   |GRANDPARENT1|87       |105 |
|3 |  TABLE SCAN   |PARENT1     |100      |97  |
|4 | TABLE SCAN    |GRANDPARENT2|100      |95  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([GRANDPARENT1.col_varchar_10]), filter(nil), 
      equal_conds([GRANDPARENT1.col_varchar_10 = GRANDPARENT2.col_varchar_10]), other_conds(nil)
  1 - output([GRANDPARENT1.col_varchar_10]), filter(nil), 
      equal_conds([GRANDPARENT1.col_varchar_10 = PARENT1.col_varchar_20]), other_conds([PARENT1.col_varchar_10 > PARENT1.col_varchar_20 OR GRANDPARENT1.col_int_key != ? AND GRANDPARENT1.col_int_key > ?])
  2 - output([GRANDPARENT1.col_varchar_10], [GRANDPARENT1.col_int_key]), filter([(T_OP_IS, GRANDPARENT1.col_varchar_10, NULL, 0) OR GRANDPARENT1.col_int_key >= ?]), 
      access([GRANDPARENT1.col_varchar_10], [GRANDPARENT1.col_int_key]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([GRANDPARENT1.__pk_increment], [GRANDPARENT1.__pk_cluster_id], [GRANDPARENT1.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  3 - output([PARENT1.col_varchar_10], [PARENT1.col_varchar_20]), filter(nil), 
      access([PARENT1.col_varchar_10], [PARENT1.col_varchar_20]), partitions(p0), 
      is_index_back=false, 
      range_key([PARENT1.__pk_increment], [PARENT1.__pk_cluster_id], [PARENT1.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  4 - output([GRANDPARENT2.col_varchar_10]), filter(nil), 
      access([GRANDPARENT2.col_varchar_10]), partitions(p0), 
      is_index_back=false, 
      range_key([GRANDPARENT2.__pk_increment], [GRANDPARENT2.__pk_cluster_id], [GRANDPARENT2.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 452(end)  ************** 

***************   Case 453   ***************

SQL: SELECT * FROM sbtest WHERE c1=1; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|sbtest|1        |52  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([sbtest.c1], [sbtest.c2]), filter(nil), 
      access([sbtest.c1], [sbtest.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([sbtest.c1]), range[1 ; 1], 
      range_cond([sbtest.c1 = ?])

*************** Case 453(end)  ************** 

***************   Case 454   ***************

SQL: select * from (select t1.c1 from t1 left join t2 as b on b.c1 = effective_tenant_id() where t1.c1 = effective_tenant_id()) as yyy; 

===========================================================
|ID|OPERATOR                          |NAME|EST. ROWS|COST|
-----------------------------------------------------------
|0 |EXCHANGE IN REMOTE                |    |1        |105 |
|1 | EXCHANGE OUT REMOTE              |    |1        |105 |
|2 |  NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |105 |
|3 |   TABLE GET                      |t1  |1        |52  |
|4 |   TABLE GET                      |b   |1        |52  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([1]), filter(nil), 
      access([b.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([b.c1]), range[1 ; 1], 
      range_cond([b.c1 = ?])

*************** Case 454(end)  ************** 

***************   Case 455   ***************

SQL: select * from (select t1.c1 from t1 left join t2 as b on b.c1 = 5 where t1.c1 = 5) as yyy; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|        |1        |105 |
|1 | TABLE GET                      |t1      |1        |52  |
|2 | PX COORDINATOR                 |        |1        |52  |
|3 |  EXCHANGE OUT DISTR            |:EX10000|1        |52  |
|4 |   TABLE GET                    |b       |1        |52  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), is_single, dop=1
  4 - output([1]), filter(nil), 
      access([b.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([b.c1]), range[5 ; 5], 
      range_cond([b.c1 = ?])

*************** Case 455(end)  ************** 

***************   Case 456   ***************

SQL: select * from t1, t2 order by t1.c1 limit 10; 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |LIMIT                       |        |10       |687 |
|1 | TOP-N SORT                 |        |10       |686 |
|2 |  NESTED-LOOP JOIN CARTESIAN|        |10       |664 |
|3 |   PX COORDINATOR           |        |1        |36  |
|4 |    EXCHANGE OUT DISTR      |:EX10000|1        |36  |
|5 |     PX PARTITION ITERATOR  |        |1        |36  |
|6 |      TABLE SCAN            |t1      |1        |36  |
|7 |   MATERIAL                 |        |300      |621 |
|8 |    PX COORDINATOR          |        |300      |290 |
|9 |     EXCHANGE OUT DISTR     |:EX20000|300      |205 |
|10|      PX PARTITION ITERATOR |        |300      |205 |
|11|       TABLE SCAN           |t2      |300      |205 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC]), topn(10)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 456(end)  ************** 

***************   Case 457   ***************

SQL: select * from t1, t7 order by t1.c1 limit 10; 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |LIMIT                       |        |10       |185 |
|1 | TOP-N SORT                 |        |10       |184 |
|2 |  NESTED-LOOP JOIN CARTESIAN|        |10       |170 |
|3 |   PX COORDINATOR           |        |1        |36  |
|4 |    EXCHANGE OUT DISTR      |:EX10000|1        |36  |
|5 |     PX PARTITION ITERATOR  |        |1        |36  |
|6 |      TABLE SCAN            |t1      |1        |36  |
|7 |   MATERIAL                 |        |100      |127 |
|8 |    TABLE SCAN              |t7      |100      |90  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t7.c1], [t7.c2]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1], [t1.c2], [t7.c1], [t7.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(10)
  2 - output([t1.c1], [t1.c2], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t7.c1], [t7.c2]), filter(nil)
  8 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 457(end)  ************** 

***************   Case 458   ***************

SQL: select * from (select * from t1 group by c1) as a join (select * from t1 group by c1) as b on a.c1 = b.c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 458(end)  ************** 

***************   Case 459   ***************

SQL: select * from (select c1 as a1 from t1 group by c1) as a join (select c1 as b1 from t1 group by c1) as b on a.a1 = b.b1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 459(end)  ************** 

***************   Case 460   ***************

SQL: select a2, b1 from (select c1 as a1, c1 as a2 from t1 group by c1) as a join (select c1 as b1 from t1 group by c1) as b on a.a2 = b.b1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|2 |  PX PARTITION ITERATOR|        |500      |331 |
|3 |   TABLE SCAN          |t1      |500      |331 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 460(end)  ************** 

***************   Case 461   ***************

SQL: select a2, b1 from (select c1 as a1, c2 as a2 from t1 group by c1) as a join (select c1 as b1 from t1 group by c1) as b on a.a2 = b.b1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |490      |1853|
|1 | EXCHANGE OUT DISTR            |:EX10001     |490      |1783|
|2 |  MERGE JOIN                   |             |490      |1783|
|3 |   EXCHANGE IN MERGE SORT DISTR|             |500      |389 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000     |500      |342 |
|5 |     PX PARTITION ITERATOR     |             |500      |342 |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|500      |342 |
|7 |   SORT                        |             |500      |966 |
|8 |    PX PARTITION ITERATOR      |             |500      |331 |
|9 |     TABLE SCAN                |t1           |500      |331 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t1.c1]), filter(nil)
  1 - output([t1.c2], [t1.c1]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  8 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 461(end)  ************** 

***************   Case 462   ***************

SQL: select * from (select c2 from t1 group by c2) as a join (select c1 as b1 from t1 group by c1) as b on a.c2 = b.b1; 

=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                     |             |99       |1708|
|1 | EXCHANGE OUT DISTR                |:EX10002     |99       |1699|
|2 |  MERGE JOIN                       |             |99       |1699|
|3 |   EXCHANGE IN MERGE SORT DISTR    |             |100      |592 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10001     |100      |587 |
|5 |     SUBPLAN SCAN                  |a            |100      |587 |
|6 |      MERGE GROUP BY               |             |100      |573 |
|7 |       EXCHANGE IN MERGE SORT DISTR|             |100      |462 |
|8 |        EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |453 |
|9 |         PX PARTITION ITERATOR     |             |100      |453 |
|10|          MERGE GROUP BY           |             |100      |453 |
|11|           TABLE SCAN              |t1(idx_t1_c2)|500      |342 |
|12|   SORT                            |             |500      |966 |
|13|    PX PARTITION ITERATOR          |             |500      |331 |
|14|     TABLE SCAN                    |t1           |500      |331 |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c2], [t1.c1]), filter(nil)
  1 - output([a.c2], [t1.c1]), filter(nil), dop=1
  2 - output([a.c2], [t1.c1]), filter(nil), 
      equal_conds([a.c2 = t1.c1]), other_conds(nil)
  3 - output([a.c2]), filter(nil), sort_keys([a.c2, ASC])
  4 - (#keys=1, [a.c2]), output([a.c2]), filter(nil), dop=1
  5 - output([a.c2]), filter(nil), 
      access([a.c2])
  6 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  7 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  8 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  11 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  12 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  13 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  14 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 462(end)  ************** 

***************   Case 463   ***************

SQL: SELECT * FROM sbtest1 WHERE (c1, c2)=(1, NULL); 

======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|sbtest1|100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([sbtest1.c1], [sbtest1.c2]), filter(nil), startup_filter([0]), 
      access([sbtest1.c1], [sbtest1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([sbtest1.c1]), range(MIN ; MAX)always true

*************** Case 463(end)  ************** 

***************   Case 464   ***************

SQL: select * from t1 where c1 = 65535; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[65535 ; 65535], 
      range_cond([t1.c1 = ?])

*************** Case 464(end)  ************** 

***************   Case 465   ***************

SQL: select t6.c1, t6.c2, t6_1.c1, t6_1.c2 from t6 left join t6_1 using (c1) order by t6.c2 desc; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |        |300      |1564|
|1 | EXCHANGE OUT DISTR             |:EX10001|300      |1507|
|2 |  SORT                          |        |300      |1507|
|3 |   MERGE OUTER JOIN             |        |300      |969 |
|4 |    SORT                        |        |300      |619 |
|5 |     PX PARTITION ITERATOR      |        |300      |198 |
|6 |      TABLE SCAN                |t6      |300      |198 |
|7 |    EXCHANGE IN MERGE SORT DISTR|        |200      |163 |
|8 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |144 |
|9 |      PX PARTITION ITERATOR     |        |200      |144 |
|10|       TABLE SCAN               |t6_1    |200      |144 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2], [t6_1.c1], [t6_1.c2]), filter(nil), sort_keys([t6.c2, DESC])
  1 - output([t6.c1], [t6.c2], [t6_1.c1], [t6_1.c2]), filter(nil), dop=1
  2 - output([t6.c1], [t6.c2], [t6_1.c1], [t6_1.c2]), filter(nil), sort_keys([t6.c2, DESC])
  3 - output([t6.c1], [t6.c2], [t6_1.c1], [t6_1.c2]), filter(nil), 
      equal_conds([t6.c1 = t6_1.c1]), other_conds(nil)
  4 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  5 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  6 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t6_1.c1], [t6_1.c2]), filter(nil), sort_keys([t6_1.c1, ASC]), Local Order
  8 - (#keys=1, [t6_1.c1]), output([t6_1.c1], [t6_1.c2]), filter(nil), dop=1
  9 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      access([t6_1.c1], [t6_1.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t6_1.c1]), range(MIN ; MAX)always true

*************** Case 465(end)  ************** 

***************   Case 466   ***************

SQL: select t6.c1, t6.c2, t6_1.c1, t6_1.c2 from t6 left join t6_1 using (c1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1026|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |969 |
|2 |  MERGE OUTER JOIN             |        |300      |969 |
|3 |   SORT                        |        |300      |619 |
|4 |    PX PARTITION ITERATOR      |        |300      |198 |
|5 |     TABLE SCAN                |t6      |300      |198 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |200      |163 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |144 |
|8 |     PX PARTITION ITERATOR     |        |200      |144 |
|9 |      TABLE SCAN               |t6_1    |200      |144 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2], [t6_1.c1], [t6_1.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2], [t6_1.c1], [t6_1.c2]), filter(nil), dop=1
  2 - output([t6.c1], [t6.c2], [t6_1.c1], [t6_1.c2]), filter(nil), 
      equal_conds([t6.c1 = t6_1.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2]), filter(nil), sort_keys([t6.c1, ASC]), local merge sort
  4 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  6 - output([t6_1.c1], [t6_1.c2]), filter(nil), sort_keys([t6_1.c1, ASC]), Local Order
  7 - (#keys=1, [t6_1.c1]), output([t6_1.c1], [t6_1.c2]), filter(nil), dop=1
  8 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      access([t6_1.c1], [t6_1.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t6_1.c1]), range(MIN ; MAX)always true

*************** Case 466(end)  ************** 

***************   Case 467   ***************

SQL: select * from t1 where (0 = 1) or c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 467(end)  ************** 

***************   Case 468   ***************

SQL: select * from t1 where (1 = 1) or c1 = 1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 468(end)  ************** 

***************   Case 469   ***************

SQL: select * from t1 where 0 or c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |52  |
|2 |  TABLE GET         |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 469(end)  ************** 

***************   Case 470   ***************

SQL: select * from t1 where 1 or c1 = 1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 470(end)  ************** 

***************   Case 471   ***************

SQL: select * from t1 join t2 on (1 =1 or t1.c1 = t2.c1); 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |108575|
|1 | PX COORDINATOR           |        |300      |290   |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |205   |
|3 |   PX PARTITION ITERATOR  |        |300      |205   |
|4 |    TABLE SCAN            |t2      |300      |205   |
|5 | MATERIAL                 |        |500      |573   |
|6 |  PX COORDINATOR          |        |500      |389   |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |342   |
|8 |    PX PARTITION ITERATOR |        |500      |342   |
|9 |     TABLE SCAN           |t1      |500      |342   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([1]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([1]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 471(end)  ************** 

***************   Case 472   ***************

SQL: select * from t1 left join t2 on (1 = 0 or t1.c1 = t2.c1) left join t3 on (1=2 and t2.c1 = t3.c1); 

==============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST |
--------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN          |        |500      |35573|
|1 | PX COORDINATOR                 |        |500      |1725 |
|2 |  EXCHANGE OUT DISTR            |:EX10001|500      |1536 |
|3 |   MERGE OUTER JOIN             |        |500      |1536 |
|4 |    EXCHANGE IN MERGE SORT DISTR|        |500      |389  |
|5 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |342  |
|6 |      PX PARTITION ITERATOR     |        |500      |342  |
|7 |       TABLE SCAN               |t1      |500      |342  |
|8 |    SORT                        |        |300      |859  |
|9 |     PX PARTITION ITERATOR      |        |300      |205  |
|10|      TABLE SCAN                |t2      |300      |205  |
|11| MATERIAL                       |        |200      |426  |
|12|  PX COORDINATOR                |        |200      |205  |
|13|   EXCHANGE OUT DISTR           |:EX20000|200      |149  |
|14|    PX PARTITION ITERATOR       |        |200      |149  |
|15|     TABLE SCAN                 |t3      |200      |149  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([0]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  5 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  15 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 472(end)  ************** 

***************   Case 473   ***************

SQL: select * from t1 left join t2 on (1 = 0 or t1.c1 = t2.c1) left join t3 on (1=2 or t2.c1 = t3.c1); 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |500      |3115|
|1 | EXCHANGE OUT DISTR               |:EX10002|500      |2784|
|2 |  MERGE OUTER JOIN                |        |500      |2784|
|3 |   SORT                           |        |500      |1074|
|4 |    PX PARTITION ITERATOR         |        |500      |342 |
|5 |     TABLE SCAN                   |t1      |500      |342 |
|6 |   EXCHANGE IN MERGE SORT DISTR   |        |300      |1422|
|7 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1251|
|8 |     MERGE OUTER JOIN             |        |300      |1251|
|9 |      SORT                        |        |300      |859 |
|10|       PX PARTITION ITERATOR      |        |300      |205 |
|11|        TABLE SCAN                |t2      |300      |205 |
|12|      EXCHANGE IN MERGE SORT DISTR|        |200      |205 |
|13|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |149 |
|14|        PX PARTITION ITERATOR     |        |200      |149 |
|15|         TABLE SCAN               |t3      |200      |149 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t2.c1, ASC])
  7 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  13 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  15 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 473(end)  ************** 

***************   Case 474   ***************

SQL: select c1, c2 from t1 group by c1 having (1 = 0 or c1 > 5); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(5 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 474(end)  ************** 

***************   Case 475   ***************

SQL: select * from t1 where c1 in (select c1 from t2 where (1 = 0 or c1 > 5)); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1610|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1568|
|2 |  MERGE JOIN                   |        |300      |1568|
|3 |   SORT                        |        |500      |1074|
|4 |    PX PARTITION ITERATOR      |        |500      |342 |
|5 |     TABLE SCAN                |t1      |500      |342 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(5 ; MAX), 
      range_cond([t1.c1 > ?])
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(5 ; MAX), 
      range_cond([t2.c1 > ?])

*************** Case 475(end)  ************** 

***************   Case 476   ***************

SQL: select * from t7,t8 where  concat(t7.c2, t8.c2) > 1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |3334     |5676|
|1 | TABLE SCAN     |t7  |100      |90  |
|2 | MATERIAL       |    |100      |127 |
|3 |  TABLE SCAN    |t8  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds([concat(t7.c2, t8.c2) > ?]), nl_params_(nil), batch_join=false
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 476(end)  ************** 

***************   Case 477   ***************

SQL: select exists(select 1) + 1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1)) + ?]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 477(end)  ************** 

***************   Case 478   ***************

SQL: select exists(select 1) + c1 from t7; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |102 |
|1 | TABLE SCAN   |t7  |100      |88  |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([? + t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil)
      values({?})

*************** Case 478(end)  ************** 

***************   Case 479   ***************

SQL: select ( select max(c1) from t7 ) = (select min(c1) from t8) from t9; 

===========================================================
|ID|OPERATOR                   |NAME       |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |           |100      |226 |
|1 | NESTED-LOOP JOIN CARTESIAN|           |1        |74  |
|2 |  SUBPLAN SCAN             |VIEW1      |1        |37  |
|3 |   SCALAR GROUP BY         |           |1        |37  |
|4 |    SUBPLAN SCAN           |VIEW3      |1        |37  |
|5 |     TABLE SCAN            |t7(Reverse)|1        |36  |
|6 |  SUBPLAN SCAN             |VIEW2      |1        |37  |
|7 |   SCALAR GROUP BY         |           |1        |37  |
|8 |    SUBPLAN SCAN           |VIEW4      |1        |37  |
|9 |     TABLE SCAN            |t8         |1        |36  |
|10| TABLE SCAN                |t9         |100      |88  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.max(c1) = VIEW2.min(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([VIEW1.max(c1)], [VIEW2.min(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.max(c1)]), filter(nil), 
      access([VIEW1.max(c1)])
  3 - output([T_FUN_MAX(VIEW3.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW3.c1)])
  4 - output([VIEW3.c1]), filter(nil), 
      access([VIEW3.c1])
  5 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  6 - output([VIEW2.min(c1)]), filter(nil), 
      access([VIEW2.min(c1)])
  7 - output([T_FUN_MIN(VIEW4.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW4.c1)])
  8 - output([VIEW4.c1]), filter(nil), 
      access([VIEW4.c1])
  9 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  10 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 479(end)  ************** 

***************   Case 480   ***************

SQL: select 1 in (select c1 from t7) from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |189 |
|1 | TABLE SCAN   |t8  |100      |88  |
|2 | TABLE SCAN   |t7  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? = ANY(subquery(1))]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 480(end)  ************** 

***************   Case 481   ***************

SQL: select c1 in (select c1 from t7) from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |2204|
|1 | TABLE SCAN   |t8  |100      |88  |
|2 | TABLE SCAN   |t7  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t8.c1 = ANY(subquery(1))]), filter(nil), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 481(end)  ************** 

***************   Case 482   ***************

SQL: select abs((select sum(c1) from t7)) > round((select sum(c1) from t7)) from t8; 

=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |     |100      |367 |
|1 | NESTED-LOOP JOIN CARTESIAN|     |1        |215 |
|2 |  SUBPLAN SCAN             |VIEW1|1        |107 |
|3 |   SCALAR GROUP BY         |     |1        |107 |
|4 |    TABLE SCAN             |t7   |100      |88  |
|5 |  SUBPLAN SCAN             |VIEW2|1        |107 |
|6 |   SCALAR GROUP BY         |     |1        |107 |
|7 |    TABLE SCAN             |t7   |100      |88  |
|8 | TABLE SCAN                |t8   |100      |88  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([abs(VIEW1.sum(c1)) > round(VIEW2.sum(c1))]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([VIEW1.sum(c1)], [VIEW2.sum(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.sum(c1)]), filter(nil), 
      access([VIEW1.sum(c1)])
  3 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([VIEW2.sum(c1)]), filter(nil), 
      access([VIEW2.sum(c1)])
  6 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  7 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  8 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 482(end)  ************** 

***************   Case 483   ***************

SQL: select abs((select sum(c1) from t7)) > round((select sum(c1) from t7)) from t8 left outer join t9 using(c1); 

=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |     |100      |367 |
|1 | NESTED-LOOP JOIN CARTESIAN|     |1        |215 |
|2 |  SUBPLAN SCAN             |VIEW1|1        |107 |
|3 |   SCALAR GROUP BY         |     |1        |107 |
|4 |    TABLE SCAN             |t7   |100      |88  |
|5 |  SUBPLAN SCAN             |VIEW2|1        |107 |
|6 |   SCALAR GROUP BY         |     |1        |107 |
|7 |    TABLE SCAN             |t7   |100      |88  |
|8 | TABLE SCAN                |t8   |100      |88  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([abs(VIEW1.sum(c1)) > round(VIEW2.sum(c1))]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([VIEW1.sum(c1)], [VIEW2.sum(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.sum(c1)]), filter(nil), 
      access([VIEW1.sum(c1)])
  3 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([VIEW2.sum(c1)]), filter(nil), 
      access([VIEW2.sum(c1)])
  6 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  7 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  8 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 483(end)  ************** 

***************   Case 484   ***************

SQL: select ((select 1) < c1) + ((select 5) > c1) from t7; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([? < t7.c1 + ? > t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 484(end)  ************** 

***************   Case 485   ***************

SQL: select * from t7 where ((select 1) < c1) + ((select 5) > c1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |50       |99  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([? < t7.c1 + ? > t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 485(end)  ************** 

***************   Case 486   ***************

SQL: select * from t7 having ((select 1) < c1) + ((select 5) > c1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |50       |99  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([? < t7.c1 + ? > t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 486(end)  ************** 

***************   Case 487   ***************

SQL: select * from t7 having ((select 1) < sum(c1)) + ((select 5) > sum(c1)); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |109 |
|1 | TABLE SCAN    |t7  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([? < T_FUN_SUM(t7.c1) + ? > T_FUN_SUM(t7.c1)]), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 487(end)  ************** 

***************   Case 488   ***************

SQL: select * from t7 where 1 in (select c1 from t9 having (select count(1) from t7) > 0) having (select max(c1) from t8) > 1; 

============================================================
|ID|OPERATOR                    |NAME       |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |           |1        |43  |
|1 | NESTED-LOOP JOIN CARTESIAN |           |1        |42  |
|2 |  NESTED-LOOP JOIN CARTESIAN|           |1        |42  |
|3 |   SUBPLAN SCAN             |VIEW3      |1        |37  |
|4 |    SCALAR GROUP BY         |           |1        |37  |
|5 |     SUBPLAN SCAN           |VIEW4      |1        |37  |
|6 |      TABLE SCAN            |t8(Reverse)|1        |36  |
|7 |   SUBPLAN SCAN             |VIEW2      |1        |107 |
|8 |    SCALAR GROUP BY         |           |1        |107 |
|9 |     TABLE SCAN             |t7         |100      |88  |
|10|  TABLE GET                 |t9         |1        |52  |
|11| TABLE SCAN                 |t7         |100      |90  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  2 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([T_FUN_MAX(VIEW4.c1)]), filter([T_FUN_MAX(VIEW4.c1) > ?]), 
      group(nil), agg_func([T_FUN_MAX(VIEW4.c1)])
  5 - output([VIEW4.c1]), filter(nil), 
      access([VIEW4.c1])
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  7 - output([1]), filter(nil), 
      access(nil)
  8 - output([T_FUN_COUNT(?)]), filter([T_FUN_COUNT(?) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  9 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  10 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range[1 ; 1], 
      range_cond([t9.c1 = ?])
  11 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 488(end)  ************** 

***************   Case 489   ***************

SQL: select * from t7 having count(*) > (select 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |109 |
|1 | TABLE SCAN    |t7  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([T_FUN_COUNT(*) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 489(end)  ************** 

***************   Case 490   ***************

SQL: select * from t7 having count(*) > (select c1 from t8 limit 1); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |145 |
|1 | SCALAR GROUP BY|    |1        |109 |
|2 |  TABLE SCAN    |t7  |100      |90  |
|3 | TABLE SCAN     |t8  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([T_FUN_COUNT(*) > ?]), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 490(end)  ************** 

***************   Case 491   ***************

SQL: select * from t7 having count(*) > (select c1 from t8 where t7.c1=t8.c1); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |145 |
|1 | SCALAR GROUP BY|    |1        |109 |
|2 |  TABLE SCAN    |t7  |100      |90  |
|3 | TABLE GET      |t8  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([T_FUN_COUNT(*) > subquery(1)]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t8.c1])

*************** Case 491(end)  ************** 

***************   Case 492   ***************

SQL: select *, (select 9) > count(*) FROM t7; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |109 |
|1 | TABLE SCAN    |t7  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [? > T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 492(end)  ************** 

***************   Case 493   ***************

SQL: select *, (select 9) > count(*) FROM t7  HAVING count(*) > (SELECT 5); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |109 |
|1 | TABLE SCAN    |t7  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [? > T_FUN_COUNT(*)]), filter([T_FUN_COUNT(*) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 493(end)  ************** 

***************   Case 494   ***************

SQL: select count(*) FROM t7  HAVING count(*) > (SELECT 5) ; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |107 |
|1 | TABLE SCAN    |t7  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter([T_FUN_COUNT(*) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 494(end)  ************** 

***************   Case 495   ***************

SQL: select count(*) FROM t7 GROUP BY c1  HAVING count(*) > (SELECT 5) ; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 495(end)  ************** 

***************   Case 496   ***************

SQL: select * from t7 order by exists(select 1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |104 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil)
      values({1})

*************** Case 496(end)  ************** 

***************   Case 497   ***************

SQL: select * from t7 order by (select count(*) from t8) > 1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |100      |211 |
|1 | TABLE SCAN     |t7  |100      |90  |
|2 | SCALAR GROUP BY|    |1        |107 |
|3 |  TABLE SCAN    |t8  |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) > 1]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 497(end)  ************** 

***************   Case 498   ***************

SQL: select * from t7 group by exists(select 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE GROUP BY |    |1        |118 |
|1 | SUBPLAN FILTER|    |100      |104 |
|2 |  TABLE SCAN   |t7  |100      |90  |
|3 |  EXPRESSION   |    |1        |1   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil)
      values({1})

*************** Case 498(end)  ************** 

***************   Case 499   ***************

SQL: select * from t7 group by (select count(*) from t8) > 1; 

=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH GROUP BY              |     |1        |295 |
|1 | NESTED-LOOP JOIN CARTESIAN|     |100      |262 |
|2 |  SUBPLAN SCAN             |VIEW1|1        |107 |
|3 |   SCALAR GROUP BY         |     |1        |107 |
|4 |    TABLE SCAN             |t8   |100      |88  |
|5 |  TABLE SCAN               |t7   |100      |90  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group([VIEW1.count(*) > 1]), agg_func(nil)
  1 - output([t7.c1], [t7.c2], [VIEW1.count(*) > 1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  2 - output([VIEW1.count(*)]), filter(nil), 
      access([VIEW1.count(*)])
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 499(end)  ************** 

***************   Case 500   ***************

SQL: select * from t7 where exists( select c1, c2 from t8 ); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 500(end)  ************** 

***************   Case 501   ***************

SQL: select * from t7 where exists( select sum(c2), c2 from t8 group by c2 order by c2 desc limit 10 ); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |141 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |10       |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 501(end)  ************** 

***************   Case 502   ***************

SQL: select 100 + exists( select c1, c2 from t8 ) from t7; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |192 |
|1 | TABLE SCAN   |t7  |100      |88  |
|2 | TABLE SCAN   |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + (T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 502(end)  ************** 

***************   Case 503   ***************

SQL: select * from t7 where exists( select c1, count(*) from t8 ); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 503(end)  ************** 

***************   Case 504   ***************

SQL: select * from t7 where exists( select distinct c1 from t8 ); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 504(end)  ************** 

***************   Case 505   ***************

SQL: select * from t7 where exists( select * from t8 limit 10); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |141 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |10       |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 505(end)  ************** 

***************   Case 506   ***************

SQL: select * from t7 where exists( select distinct c1 from t8 limit 10); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |141 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |10       |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 506(end)  ************** 

***************   Case 507   ***************

SQL: select * from t7 where exists( select c1 from t8 group by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 507(end)  ************** 

***************   Case 508   ***************

SQL: select * from t7 where exists( select c1 from t8 group by c2 limit 10); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |141 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |10       |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 508(end)  ************** 

***************   Case 509   ***************

SQL: select * from t7 where t7.c1 in ( select c1 from t8 group by c2 order by c2); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE JOIN      |     |100      |493 |
|1 | TABLE SCAN     |t7   |100      |90  |
|2 | SORT           |     |100      |316 |
|3 |  SUBPLAN SCAN  |VIEW1|100      |208 |
|4 |   HASH GROUP BY|     |100      |195 |
|5 |    TABLE SCAN  |t8   |100      |90  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 509(end)  ************** 

***************   Case 510   ***************

SQL: select * from t7 where t7.c1 >= ( select max(c1) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |246 |
|1 | TABLE SCAN   |t7  |34       |42  |
|2 | HASH GROUP BY|    |100      |200 |
|3 |  TABLE SCAN  |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 >= ?])
  2 - output([T_FUN_MAX(t8.c1)]), filter(nil), 
      group([t8.c2]), agg_func([T_FUN_MAX(t8.c1)])
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 510(end)  ************** 

***************   Case 511   ***************

SQL: select * from t7 where t7.c1 <=> ( select c1 from t8 group by c2 order by c2 limit 1); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |254 |
|1 | TABLE GET      |t7  |1        |36  |
|2 | LIMIT          |    |1        |218 |
|3 |  MERGE GROUP BY|    |1        |217 |
|4 |   SORT         |    |1        |217 |
|5 |    TABLE SCAN  |t8  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 <=> ?])
  2 - output([t8.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  5 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 511(end)  ************** 

***************   Case 512   ***************

SQL: select * from t7 where t7.c1 = ( select sum(c1) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |236 |
|1 | TABLE GET    |t7  |1        |36  |
|2 | HASH GROUP BY|    |100      |200 |
|3 |  TABLE SCAN  |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  2 - output([T_FUN_SUM(t8.c1)]), filter(nil), 
      group([t8.c2]), agg_func([T_FUN_SUM(t8.c1)])
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 512(end)  ************** 

***************   Case 513   ***************

SQL: select * from t7 where t7.c1 <= any( select c1 from t8 group by c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |3154|
|1 | TABLE SCAN          |t7   |100      |90  |
|2 | MATERIAL            |     |100      |227 |
|3 |  SUBPLAN SCAN       |VIEW1|100      |208 |
|4 |   HASH GROUP BY     |     |100      |195 |
|5 |    TABLE SCAN       |t8   |100      |90  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 <= VIEW1.c1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 513(end)  ************** 

***************   Case 514   ***************

SQL: select * from t7 where t7.c1 <= all( select c1 from t8 group by c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |3154|
|1 | TABLE SCAN          |t7   |100      |90  |
|2 | MATERIAL            |     |100      |227 |
|3 |  SUBPLAN SCAN       |VIEW1|100      |208 |
|4 |   HASH GROUP BY     |     |100      |195 |
|5 |    TABLE SCAN       |t8   |100      |90  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 > VIEW1.c1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 514(end)  ************** 

***************   Case 515   ***************

SQL: select * from t7 where t7.c1 in ( select c2 from t8 group by c2 order by c2); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE SEMI JOIN|    |100      |374 |
|1 | TABLE SCAN    |t7  |100      |90  |
|2 | SORT          |    |100      |198 |
|3 |  TABLE SCAN   |t8  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c2]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 515(end)  ************** 

***************   Case 516   ***************

SQL: select * from t7 where t7.c1 >= ( select c2 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |241 |
|1 | TABLE SCAN   |t7  |34       |42  |
|2 | HASH GROUP BY|    |100      |195 |
|3 |  TABLE SCAN  |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 >= ?])
  2 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 516(end)  ************** 

***************   Case 517   ***************

SQL: select * from t7 where t7.c1 <=> ( select c2 from t8 group by c2 order by c2 limit 1); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |234 |
|1 | TABLE GET      |t7  |1        |36  |
|2 | LIMIT          |    |1        |198 |
|3 |  MERGE GROUP BY|    |1        |198 |
|4 |   SORT         |    |1        |198 |
|5 |    TABLE SCAN  |t8  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 <=> ?])
  2 - output([t8.c2]), filter(nil), limit(1), offset(nil)
  3 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  4 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 517(end)  ************** 

***************   Case 518   ***************

SQL: select * from t7 where t7.c1 = ( select c2 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |231 |
|1 | TABLE GET    |t7  |1        |36  |
|2 | HASH GROUP BY|    |100      |195 |
|3 |  TABLE SCAN  |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  2 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 518(end)  ************** 

***************   Case 519   ***************

SQL: select * from t7 where t7.c1 <= any( select c2 from t8 group by c2 order by c2); 

==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|    |34       |3035|
|1 | TABLE SCAN          |t7  |100      |90  |
|2 | MATERIAL            |    |100      |109 |
|3 |  TABLE SCAN         |t8  |100      |90  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 <= t8.c2]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c2]), filter(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 519(end)  ************** 

***************   Case 520   ***************

SQL: select * from t7 where t7.c1 <= all( select c2 from t8 group by c2 order by c2); 

==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|    |67       |3035|
|1 | TABLE SCAN          |t7  |100      |90  |
|2 | MATERIAL            |    |100      |109 |
|3 |  TABLE SCAN         |t8  |100      |90  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 > t8.c2 OR (T_OP_IS, t8.c2, NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c2]), filter(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 520(end)  ************** 

***************   Case 521   ***************

SQL: select * from t7 where t7.c1 >= ( select c2 from t8 group by c2, c1 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |137 |
|1 | TABLE SCAN   |t7  |34       |42  |
|2 | TABLE SCAN   |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 >= ?])
  2 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 521(end)  ************** 

***************   Case 522   ***************

SQL: select * from t7 where t7.c1 = ( select c2 + 1 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |231 |
|1 | TABLE GET    |t7  |1        |36  |
|2 | HASH GROUP BY|    |100      |195 |
|3 |  TABLE SCAN  |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  2 - output([t8.c2 + ?]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 522(end)  ************** 

***************   Case 523   ***************

SQL: select * from t7 where t7.c1 <= any( select c2 + 1 from t8 group by c2 + 1, c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |3997|
|1 | TABLE SCAN          |t7   |100      |90  |
|2 | MATERIAL            |     |100      |233 |
|3 |  SUBPLAN SCAN       |VIEW1|100      |214 |
|4 |   HASH GROUP BY     |     |100      |200 |
|5 |    TABLE SCAN       |t8   |100      |90  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 <= VIEW1.c2 + 1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c2 + 1]), filter(nil)
  3 - output([VIEW1.c2 + 1]), filter(nil), 
      access([VIEW1.c2 + 1])
  4 - output([t8.c2 + ?]), filter(nil), 
      group([t8.c2 + 1], [t8.c2]), agg_func(nil)
  5 - output([t8.c2], [t8.c2 + 1]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 523(end)  ************** 

***************   Case 524   ***************

SQL: select * from t7 where t7.c1 in ( select c1 from t8 group by c2 desc order by c1 asc); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE JOIN      |     |100      |493 |
|1 | TABLE SCAN     |t7   |100      |90  |
|2 | SORT           |     |100      |316 |
|3 |  SUBPLAN SCAN  |VIEW1|100      |208 |
|4 |   HASH GROUP BY|     |100      |195 |
|5 |    TABLE SCAN  |t8   |100      |90  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 524(end)  ************** 

***************   Case 525   ***************

SQL: select * from t7 where t7.c1 = ( select 100 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |231 |
|1 | TABLE GET    |t7  |1        |36  |
|2 | HASH GROUP BY|    |100      |195 |
|3 |  TABLE SCAN  |t8  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  2 - output([?]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 525(end)  ************** 

***************   Case 526   ***************

SQL: select * from t7 where t7.c1 <= any( select 'abc' from t8 group by c2 order by c2); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |34       |100 |
|1 | SUBPLAN SCAN   |VIEW1|1        |37  |
|2 |  TABLE SCAN    |t8   |1        |36  |
|3 | TABLE SCAN     |t7   |34       |42  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.abc]), batch_join=true
  1 - output([VIEW1.abc]), filter(nil), 
      access([VIEW1.abc])
  2 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 <= ?])

*************** Case 526(end)  ************** 

***************   Case 527   ***************

SQL: select * from t7 where t7.c1 <= all( select (select 1+1) from t8 group by c2 order by c2); 

==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|    |0        |3067|
|1 | TABLE SCAN          |t7  |100      |90  |
|2 | MATERIAL            |    |100      |106 |
|3 |  TABLE SCAN         |t8  |100      |88  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 > ? OR ?]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 527(end)  ************** 

***************   Case 528   ***************

SQL: select * from t7 where t7.c1 in ( select c2 from t8 group by now()); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |1        |141 |
|1 | SUBPLAN SCAN   |VIEW1|1        |104 |
|2 |  MERGE GROUP BY|     |1        |104 |
|3 |   TABLE SCAN   |t8   |100      |90  |
|4 | TABLE GET      |t7   |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.c2]), batch_join=true
  1 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  2 - output([t8.c2]), filter(nil), 
      group(nil), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 528(end)  ************** 

***************   Case 529   ***************

SQL: select * from t7 where t7.c1 in ( select now() from t8 group by c2); 

=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |HASH JOIN    |     |1        |161 |
|1 | SUBPLAN SCAN|VIEW1|1        |37  |
|2 |  TABLE SCAN |t8   |1        |36  |
|3 | TABLE SCAN  |t7   |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.now()]), other_conds(nil)
  1 - output([VIEW1.now()]), filter(nil), 
      access([VIEW1.now()])
  2 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 529(end)  ************** 

***************   Case 530   ***************

SQL: select * from t7 where t7.c1 in ( select t7.c2 from t8 group by c2); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |223 |
|1 | TABLE SCAN               |t7   |1        |99  |
|2 | MATERIAL                 |     |1        |124 |
|3 |  SUBPLAN SCAN            |VIEW3|1        |124 |
|4 |   LIMIT                  |     |1        |124 |
|5 |    HASH GROUP BY         |     |1        |124 |
|6 |     TABLE SCAN           |t8   |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c2], [t7.c1]), filter([t7.c1 = t7.c2]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), limit(1), offset(nil)
  5 - output([1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  6 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 530(end)  ************** 

***************   Case 531   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) and exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |25       |176 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
|3 | TABLE SCAN   |t9  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?], [?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 531(end)  ************** 

***************   Case 532   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) and exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |25       |176 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
|3 | TABLE SCAN   |t9  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?], [?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 532(end)  ************** 

***************   Case 533   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) having exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |25       |176 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
|3 | TABLE SCAN   |t9  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?], [?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 533(end)  ************** 

***************   Case 534   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) group by exists(select c3 * 3 from t9); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |243 |
|1 | SUBPLAN FILTER |    |50       |237 |
|2 |  SUBPLAN FILTER|    |50       |140 |
|3 |   TABLE SCAN   |t7  |100      |90  |
|4 |   TABLE SCAN   |t8  |1        |36  |
|5 |  TABLE SCAN    |t9  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 534(end)  ************** 

***************   Case 535   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) order by exists(select c3 * 3 from t9); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |50       |237 |
|1 | SUBPLAN FILTER|    |50       |140 |
|2 |  TABLE SCAN   |t7  |100      |90  |
|3 |  TABLE SCAN   |t8  |1        |36  |
|4 | TABLE SCAN    |t9  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 535(end)  ************** 

***************   Case 536   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) and not exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |25       |176 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
|3 | TABLE SCAN   |t9  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?], [?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 536(end)  ************** 

***************   Case 537   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) having not exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |25       |176 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
|3 | TABLE SCAN   |t9  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?], [?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 537(end)  ************** 

***************   Case 538   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) group by not exists(select c3 * 3 from t9); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |243 |
|1 | SUBPLAN FILTER |    |50       |237 |
|2 |  SUBPLAN FILTER|    |50       |140 |
|3 |   TABLE SCAN   |t7  |100      |90  |
|4 |   TABLE SCAN   |t8  |1        |36  |
|5 |  TABLE SCAN    |t9  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 538(end)  ************** 

***************   Case 539   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) order by not exists(select c3 * 3 from t9); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |50       |237 |
|1 | SUBPLAN FILTER|    |50       |140 |
|2 |  TABLE SCAN   |t7  |100      |90  |
|3 |  TABLE SCAN   |t8  |1        |36  |
|4 | TABLE SCAN    |t9  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 539(end)  ************** 

***************   Case 540   ***************

SQL: select c3 + 3 from t9 where exists(select exists(select c1+1 from t7) from t8); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t9  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c3 + ?]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t9.c3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 540(end)  ************** 

***************   Case 541   ***************

SQL: select c3 + 3 from t9 where exists(select exists(select c1+1 from t7), c2 from t8); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t9  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c3 + ?]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t9.c3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 541(end)  ************** 

***************   Case 542   ***************

SQL: select c3 from t9 where ( select count(1) from (select c2 from t8 group by c2) t999 ) > 10; 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |5        |235 |
|1 | SUBPLAN SCAN             |VIEW1|1        |228 |
|2 |  SCALAR GROUP BY         |     |1        |228 |
|3 |   SUBPLAN SCAN           |t999 |100      |208 |
|4 |    HASH GROUP BY         |     |100      |195 |
|5 |     TABLE SCAN           |t8   |100      |90  |
|6 | TABLE SCAN               |t9   |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([1]), filter(nil), 
      access(nil)
  2 - output([T_FUN_COUNT(?)]), filter([T_FUN_COUNT(?) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t9.c3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 542(end)  ************** 

***************   Case 543   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 543(end)  ************** 

***************   Case 544   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 544(end)  ************** 

***************   Case 545   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 545(end)  ************** 

***************   Case 546   ***************

SQL: select * from t7 where not exists(select c1, round(c2) from t8 group by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 546(end)  ************** 

***************   Case 547   ***************

SQL: select * from t7 where not exists(select c1, round(c2) from t8 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 547(end)  ************** 

***************   Case 548   ***************

SQL: select * from t7 where not exists(select c1, round(c2) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 548(end)  ************** 

***************   Case 549   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2 having round(c2) > 0); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |141 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter([round(t8.c2) > ?]), 
      access([t8.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 549(end)  ************** 

***************   Case 550   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 order by c2 limit 0); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |104 |
|1 | TABLE SCAN   |t7  |100      |90  |
|2 | TABLE SCAN   |t8  |0        |0   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(0), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 550(end)  ************** 

***************   Case 551   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2 having round(c2) > 0 and c1 != 1 order by c2 limit 10); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |50       |222 |
|1 | TABLE SCAN    |t7  |100      |90  |
|2 | LIMIT         |    |10       |118 |
|3 |  HASH GROUP BY|    |10       |117 |
|4 |   TABLE SCAN  |t8  |34       |99  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [round(t8.c2)]), filter(nil), limit(10), offset(nil)
  3 - output([t8.c1], [t8.c2]), filter([t8.c1 != ?]), 
      group([t8.c2]), agg_func(nil)
  4 - output([t8.c1], [t8.c2]), filter([round(t8.c2) > ?]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 551(end)  ************** 

***************   Case 552   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 ); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |5000     |8814|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|2 |  TABLE SCAN               |t7  |100      |90  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t8  |100      |90  |
|5 | TABLE SCAN                |t9  |1        |36  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 552(end)  ************** 

***************   Case 553   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |5000     |8814|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|2 |  TABLE SCAN               |t7  |100      |90  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t8  |100      |90  |
|5 | TABLE SCAN                |t9  |1        |36  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 553(end)  ************** 

***************   Case 554   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 order by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |5000     |8814|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|2 |  TABLE SCAN               |t7  |100      |90  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t8  |100      |90  |
|5 | TABLE SCAN                |t9  |1        |36  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 554(end)  ************** 

***************   Case 555   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2 order by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |5000     |8814|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|2 |  TABLE SCAN               |t7  |100      |90  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t8  |100      |90  |
|5 | TABLE SCAN                |t9  |1        |36  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 555(end)  ************** 

***************   Case 556   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 order by c2 limit 10); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |5000     |8815|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|2 |  TABLE SCAN               |t7  |100      |90  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t8  |100      |90  |
|5 | TABLE SCAN                |t9  |10       |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 556(end)  ************** 

***************   Case 557   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2 order by c2 limit 10); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |5000     |8815|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|2 |  TABLE SCAN               |t7  |100      |90  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t8  |100      |90  |
|5 | TABLE SCAN                |t9  |10       |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 557(end)  ************** 

***************   Case 558   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2 having round(c2) > 0 order by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |5000     |8814|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7398|
|2 |  TABLE SCAN               |t7  |100      |90  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t8  |100      |90  |
|5 | TABLE SCAN                |t9  |1        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter([round(t9.c2) > ?]), 
      access([t9.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 558(end)  ************** 

***************   Case 559   ***************

SQL: (select * from t7 where exists(select c1, round(c2) from t8 group by c2 order by c2)) union (select * from t8); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |150      |287 |
|1 | SUBPLAN FILTER     |    |50       |140 |
|2 |  TABLE SCAN        |t7  |100      |90  |
|3 |  TABLE SCAN        |t8  |1        |36  |
|4 | TABLE SCAN         |t8  |100      |90  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t7.c1], [t7.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 559(end)  ************** 

***************   Case 560   ***************

SQL: select c1, c2 from t7 where exists (select 1 from t8 where t8.c1 = t7.c1); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t7  |100      |90  |
|2 | TABLE SCAN|t8  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t8.c1 = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 560(end)  ************** 

***************   Case 561   ***************

SQL: select c1, c2 from t7 where not exists (select 1 from t8 where t8.c1 = t7.c1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE ANTI JOIN|    |0        |265 |
|1 | TABLE SCAN    |t7  |100      |90  |
|2 | TABLE SCAN    |t8  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t8.c1 = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 561(end)  ************** 

***************   Case 562   ***************

SQL: SELECT 1 FROM t7 WHERE NOT EXISTS(SELECT 1 FROM t8 WHERE c2 = (SELECT c2 FROM t8 WHERE c1 >= 1) ORDER BY c2); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |50       |290 |
|1 | TABLE SCAN     |t7  |100      |88  |
|2 | LIMIT          |    |1        |189 |
|3 |  SUBPLAN FILTER|    |1        |188 |
|4 |   TABLE SCAN   |t8  |1        |99  |
|5 |   TABLE SCAN   |t8  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([1]), filter([t8.c2 = ?]), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[1 ; MAX), 
      range_cond([t8.c1 >= ?])

*************** Case 562(end)  ************** 

***************   Case 563   ***************

SQL: select distinct 1, 1+2, ABS(-1) from t7; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |1        |36  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?], [?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 563(end)  ************** 

***************   Case 564   ***************

SQL: select distinct 1, c2 from t7; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH DISTINCT|    |100      |195 |
|1 | TABLE SCAN  |t7  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t7.c2]), filter(nil), 
      distinct([t7.c2])
  1 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 564(end)  ************** 

***************   Case 565   ***************

SQL: select count(distinct 1) from t7; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |107 |
|1 | TABLE SCAN    |t7  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(distinct ?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(distinct ?)])
  1 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 565(end)  ************** 

***************   Case 566   ***************

SQL: select distinct (select c1 from t7 limit 1) from t8; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |LIMIT          |    |1        |73  |
|1 | SUBPLAN FILTER|    |1        |72  |
|2 |  TABLE SCAN   |t8  |1        |36  |
|3 |  TABLE SCAN   |t7  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), limit(1), offset(nil)
  1 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 566(end)  ************** 

***************   Case 567   ***************

SQL: select distinct 1, 1 + @var from t7; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |1        |36  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 567(end)  ************** 

***************   Case 568   ***************

SQL: Select distinct 1, 1 + (@var:=1) from t7; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |1        |36  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 568(end)  ************** 

***************   Case 569   ***************

SQL: select t1.c2 + t2.c1 from t1, t2 where t1.c1 = t2.c2 and t1.c1 and t1.c1 = 1 and t2.c1 = 1; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |53  |
|1 | EXCHANGE OUT REMOTE        |    |1        |53  |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |53  |
|3 |   TABLE GET                |t2  |1        |53  |
|4 |   TABLE GET                |t1  |1        |53  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + t2.c1]), filter(nil)
  1 - output([t1.c2 + t2.c1]), filter(nil)
  2 - output([t1.c2 + t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  3 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c2]), filter([t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 569(end)  ************** 

***************   Case 570   ***************

SQL: (select 'b') union select cast((select 'a') as char(20)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 570(end)  ************** 

***************   Case 571   ***************

SQL: select cast((select 'a' from dual order by 1 limit 100) as char(20)) union (select 'b') union select cast((select 'a' from dual order by 1 limit 100) as char(20)); 

==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |MERGE UNION DISTINCT |    |3        |3   |
|1 | MERGE UNION DISTINCT|    |2        |2   |
|2 |  SUBPLAN FILTER     |    |1        |1   |
|3 |   EXPRESSION        |    |1        |1   |
|4 |   LIMIT             |    |1        |1   |
|5 |    EXPRESSION       |    |1        |1   |
|6 |  EXPRESSION         |    |1        |1   |
|7 | SUBPLAN FILTER      |    |1        |1   |
|8 |  EXPRESSION         |    |1        |1   |
|9 |  LIMIT              |    |1        |1   |
|10|   EXPRESSION        |    |1        |1   |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), CHAR(20))]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), limit(100), offset(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([?]), filter(nil)
      values({?})
  7 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), CHAR(20))]), init_plan_idxs_(nil)
  8 - output([1]), filter(nil)
      values({1})
  9 - output([?]), filter(nil), limit(100), offset(nil)
  10 - output([1]), filter(nil)
      values({1})

*************** Case 571(end)  ************** 

***************   Case 572   ***************

SQL: (select (select b from t12) from t3) union (select c3 from t3); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |HASH UNION DISTINCT      |        |400      |875 |
|1 | SUBPLAN FILTER          |        |200      |267 |
|2 |  PX COORDINATOR         |        |200      |149 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|200      |140 |
|4 |    PX PARTITION ITERATOR|        |200      |140 |
|5 |     TABLE SCAN          |t3      |200      |140 |
|6 |  TABLE SCAN             |t12     |100      |90  |
|7 | PX COORDINATOR          |        |200      |191 |
|8 |  EXCHANGE OUT DISTR     |:EX20000|200      |144 |
|9 |   PX PARTITION ITERATOR |        |200      |144 |
|10|    TABLE SCAN           |t3      |200      |144 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), VARCHAR(32))]), init_plan_idxs_(nil)
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), dop=1
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  6 - output([t12.b]), filter(nil), 
      access([t12.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  7 - output([t3.c3]), filter(nil)
  8 - output([t3.c3]), filter(nil), dop=1
  9 - output([t3.c3]), filter(nil), 
      force partition granule, asc.
  10 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 572(end)  ************** 

***************   Case 573   ***************

SQL: select distinct c2 from t1 partition(p1); 

=======================================================
|ID|OPERATOR            |NAME         |EST. ROWS|COST |
-------------------------------------------------------
|0 |EXCHANGE IN REMOTE  |             |100      |84044|
|1 | EXCHANGE OUT REMOTE|             |100      |84035|
|2 |  MERGE DISTINCT    |             |100      |84035|
|3 |   TABLE SCAN       |t1(idx_t1_c2)|100000   |61860|
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil)
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 573(end)  ************** 

***************   Case 574   ***************

SQL: select cast((select 'a') as char(20)) as c1 union (select 'b') order by c1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 574(end)  ************** 

***************   Case 575   ***************

SQL: select (select 'a') as c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 575(end)  ************** 

***************   Case 576   ***************

SQL: select avg(c1) as a from t1 union select sum(c1) as b from t1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |MERGE UNION DISTINCT      |        |2        |1097|
|1 | SCALAR GROUP BY          |        |1        |575 |
|2 |  PX COORDINATOR          |        |1        |453 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |453 |
|4 |    MERGE GROUP BY        |        |1        |453 |
|5 |     PX PARTITION ITERATOR|        |500      |331 |
|6 |      TABLE SCAN          |t1      |500      |331 |
|7 | SCALAR GROUP BY          |        |1        |522 |
|8 |  PX COORDINATOR          |        |1        |426 |
|9 |   EXCHANGE OUT DISTR     |:EX20000|1        |426 |
|10|    MERGE GROUP BY        |        |1        |426 |
|11|     PX PARTITION ITERATOR|        |500      |331 |
|12|      TABLE SCAN          |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  2 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil)
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  4 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  8 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  9 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  10 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  11 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 576(end)  ************** 

***************   Case 577   ***************

SQL: select * from t1 group by 1>(select count(*) from t2); 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |HASH GROUP BY               |        |1        |1184|
|1 | NESTED-LOOP JOIN CARTESIAN |        |500      |1019|
|2 |  SUBPLAN SCAN              |VIEW1   |1        |306 |
|3 |   SCALAR GROUP BY          |        |1        |306 |
|4 |    PX COORDINATOR          |        |1        |249 |
|5 |     EXCHANGE OUT DISTR     |:EX10000|1        |249 |
|6 |      MERGE GROUP BY        |        |1        |249 |
|7 |       PX PARTITION ITERATOR|        |300      |192 |
|8 |        TABLE SCAN          |t2      |300      |192 |
|9 |  PX COORDINATOR            |        |500      |389 |
|10|   EXCHANGE OUT DISTR       |:EX20000|500      |342 |
|11|    PX PARTITION ITERATOR   |        |500      |342 |
|12|     TABLE SCAN             |t1      |500      |342 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      group([1 > VIEW1.count(*)]), agg_func(nil)
  1 - output([t1.c1], [t1.c2], [1 > VIEW1.count(*)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.count(*)]), filter(nil), 
      access([VIEW1.count(*)])
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  4 - output([T_FUN_COUNT(*)]), filter(nil)
  5 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  6 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  7 - output([1]), filter(nil), 
      force partition granule, asc.
  8 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 577(end)  ************** 

***************   Case 578   ***************

SQL: (select count(*) from t1) UNION (select count(*) from t1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |MERGE UNION DISTINCT      |        |2        |1044|
|1 | SCALAR GROUP BY          |        |1        |522 |
|2 |  PX COORDINATOR          |        |1        |426 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|4 |    MERGE GROUP BY        |        |1        |426 |
|5 |     PX PARTITION ITERATOR|        |500      |331 |
|6 |      TABLE SCAN          |t1      |500      |331 |
|7 | SCALAR GROUP BY          |        |1        |522 |
|8 |  PX COORDINATOR          |        |1        |426 |
|9 |   EXCHANGE OUT DISTR     |:EX20000|1        |426 |
|10|    MERGE GROUP BY        |        |1        |426 |
|11|     PX PARTITION ITERATOR|        |500      |331 |
|12|      TABLE SCAN          |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  2 - output([T_FUN_COUNT(*)]), filter(nil)
  3 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  4 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  5 - output([1]), filter(nil), 
      force partition granule, asc.
  6 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  8 - output([T_FUN_COUNT(*)]), filter(nil)
  9 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  10 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  11 - output([1]), filter(nil), 
      force partition granule, asc.
  12 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 578(end)  ************** 

***************   Case 579   ***************

SQL: select min(1) from t1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |37  |
|1 | SUBPLAN SCAN             |VIEW1   |1        |37  |
|2 |  LIMIT                   |        |1        |37  |
|3 |   PX COORDINATOR         |        |1        |36  |
|4 |    EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|5 |     PX PARTITION ITERATOR|        |1        |36  |
|6 |      TABLE SCAN          |t1      |1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.subquery_col_alias)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.subquery_col_alias)])
  1 - output([VIEW1.subquery_col_alias]), filter(nil), 
      access([VIEW1.subquery_col_alias])
  2 - output([?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), dop=1
  5 - output([1]), filter(nil), 
      force partition granule, asc.
  6 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 579(end)  ************** 

***************   Case 580   ***************

SQL: select max(1) from t1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |37  |
|1 | SUBPLAN SCAN             |VIEW1   |1        |37  |
|2 |  LIMIT                   |        |1        |37  |
|3 |   PX COORDINATOR         |        |1        |36  |
|4 |    EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|5 |     PX PARTITION ITERATOR|        |1        |36  |
|6 |      TABLE SCAN          |t1      |1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.subquery_col_alias)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.subquery_col_alias)])
  1 - output([VIEW1.subquery_col_alias]), filter(nil), 
      access([VIEW1.subquery_col_alias])
  2 - output([?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), dop=1
  5 - output([1]), filter(nil), 
      force partition granule, asc.
  6 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 580(end)  ************** 

***************   Case 581   ***************

SQL: select sum(1) from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |522 |
|1 | PX COORDINATOR          |        |1        |426 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|3 |   MERGE GROUP BY        |        |1        |426 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(?))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(?))])
  1 - output([T_FUN_SUM(?)]), filter(nil)
  2 - output([T_FUN_SUM(?)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(?)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 581(end)  ************** 

***************   Case 582   ***************

SQL: select avg(1) from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |575 |
|1 | PX COORDINATOR          |        |1        |453 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |453 |
|3 |   MERGE GROUP BY        |        |1        |453 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(?)) / T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(?))], [T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  1 - output([T_FUN_SUM(?)], [T_FUN_COUNT(?)]), filter(nil)
  2 - output([T_FUN_SUM(?)], [T_FUN_COUNT(?)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(?)], [T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(?)], [T_FUN_COUNT(?)])
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 582(end)  ************** 

***************   Case 583   ***************

SQL: select t1.c3, t2.c3 from (select c3, c2 from t3 order by c3) as t1, t2 where t1.c2 = t2.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |551      |1323|
|1 | PX COORDINATOR         |        |200      |205 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|200      |149 |
|3 |   PX PARTITION ITERATOR|        |200      |149 |
|4 |    TABLE SCAN          |t3      |200      |149 |
|5 | PX COORDINATOR         |        |300      |290 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |205 |
|7 |   PX PARTITION ITERATOR|        |300      |205 |
|8 |    TABLE SCAN          |t2      |300      |205 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c3], [t2.c3]), filter(nil), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  1 - output([t3.c3], [t3.c2]), filter(nil)
  2 - output([t3.c3], [t3.c2]), filter(nil), dop=1
  3 - output([t3.c3], [t3.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t3.c3], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c2], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 583(end)  ************** 

***************   Case 584   ***************

SQL: (select c2, c1 from t19 order by c2) union (select c2, c1 from t19 order by c2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |200      |265 |
|1 | TABLE SCAN         |t19 |100      |95  |
|2 | TABLE SCAN         |t19 |100      |95  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t19.c2], [t19.c1]), filter(nil), 
      access([t19.c2], [t19.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t19.c2], [t19.c1]), filter(nil), 
      access([t19.c2], [t19.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true

*************** Case 584(end)  ************** 

***************   Case 585   ***************

SQL: select a1, a2 from set_t1 group by a1 asc, a2 desc union select b1, b2 from set_t2 group by b1 asc, b2 desc; 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |MERGE UNION DISTINCT|      |200      |577 |
|1 | MERGE GROUP BY     |      |100      |251 |
|2 |  SORT              |      |100      |220 |
|3 |   TABLE SCAN       |set_t1|100      |92  |
|4 | MERGE GROUP BY     |      |100      |251 |
|5 |  SORT              |      |100      |220 |
|6 |   TABLE SCAN       |set_t2|100      |92  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      group([set_t1.a1], [set_t1.a2]), agg_func(nil)
  2 - output([set_t1.a1], [set_t1.a2]), filter(nil), sort_keys([set_t1.a1, ASC], [set_t1.a2, ASC])
  3 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      access([set_t1.a1], [set_t1.a2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  4 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      group([set_t2.b1], [set_t2.b2]), agg_func(nil)
  5 - output([set_t2.b1], [set_t2.b2]), filter(nil), sort_keys([set_t2.b1, ASC], [set_t2.b2, ASC])
  6 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      access([set_t2.b1], [set_t2.b2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 585(end)  ************** 

***************   Case 586   ***************

SQL: select a1, a2 from set_t1 group by a1 asc, a2 desc intersect select b1, b2 from set_t2 group by b1 asc, b2 desc; 

===================================================
|ID|OPERATOR                |NAME  |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE INTERSECT DISTINCT|      |100      |563 |
|1 | MERGE GROUP BY         |      |100      |251 |
|2 |  SORT                  |      |100      |220 |
|3 |   TABLE SCAN           |set_t1|100      |92  |
|4 | MERGE GROUP BY         |      |100      |251 |
|5 |  SORT                  |      |100      |220 |
|6 |   TABLE SCAN           |set_t2|100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil)
  1 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      group([set_t1.a1], [set_t1.a2]), agg_func(nil)
  2 - output([set_t1.a1], [set_t1.a2]), filter(nil), sort_keys([set_t1.a1, ASC], [set_t1.a2, ASC])
  3 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      access([set_t1.a1], [set_t1.a2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  4 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      group([set_t2.b1], [set_t2.b2]), agg_func(nil)
  5 - output([set_t2.b1], [set_t2.b2]), filter(nil), sort_keys([set_t2.b1, ASC], [set_t2.b2, ASC])
  6 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      access([set_t2.b1], [set_t2.b2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 586(end)  ************** 

***************   Case 587   ***************

SQL: select a1, a2 from set_t1 group by a1 asc, a2 desc except select b1, b2 from set_t2 group by b1 asc, b2 desc; 

================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE EXCEPT DISTINCT|      |100      |563 |
|1 | MERGE GROUP BY      |      |100      |251 |
|2 |  SORT               |      |100      |220 |
|3 |   TABLE SCAN        |set_t1|100      |92  |
|4 | MERGE GROUP BY      |      |100      |251 |
|5 |  SORT               |      |100      |220 |
|6 |   TABLE SCAN        |set_t2|100      |92  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil)
  1 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      group([set_t1.a1], [set_t1.a2]), agg_func(nil)
  2 - output([set_t1.a1], [set_t1.a2]), filter(nil), sort_keys([set_t1.a1, ASC], [set_t1.a2, ASC])
  3 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      access([set_t1.a1], [set_t1.a2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  4 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      group([set_t2.b1], [set_t2.b2]), agg_func(nil)
  5 - output([set_t2.b1], [set_t2.b2]), filter(nil), sort_keys([set_t2.b1, ASC], [set_t2.b2, ASC])
  6 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      access([set_t2.b1], [set_t2.b2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 587(end)  ************** 

***************   Case 588   ***************

SQL: (select * from t1 where c1 = 2) union all (select * from t1 where c1 = 2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |105 |
|1 | EXCHANGE OUT REMOTE|    |2        |105 |
|2 |  UNION ALL         |    |2        |105 |
|3 |   TABLE GET        |t1  |1        |52  |
|4 |   TABLE GET        |t1  |1        |52  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 588(end)  ************** 

***************   Case 589   ***************

SQL: (select 1) union (select 1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 589(end)  ************** 

***************   Case 590   ***************

SQL: (select (select 1)) union (select (select 1)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 590(end)  ************** 

***************   Case 591   ***************

SQL: (select (select c1 from t1) from  t2 order by ((select c1 from t1))) union (select 1); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |MERGE UNION DISTINCT     |        |301      |700 |
|1 | SUBPLAN FILTER          |        |300      |601 |
|2 |  PX COORDINATOR         |        |300      |206 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|300      |192 |
|4 |    PX PARTITION ITERATOR|        |300      |192 |
|5 |     TABLE SCAN          |t2      |300      |192 |
|6 |  PX COORDINATOR         |        |500      |354 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|500      |331 |
|8 |    PX PARTITION ITERATOR|        |500      |331 |
|9 |     TABLE SCAN          |t1      |500      |331 |
|10| EXPRESSION              |        |1        |1   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), BIGINT(20, 0))]), init_plan_idxs_(nil)
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), dop=1
  4 - output([1]), filter(nil), 
      force partition granule, asc.
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([?]), filter(nil)
      values({?})

*************** Case 591(end)  ************** 

***************   Case 592   ***************

SQL: (select (select c1 from t1) from  t2) union (select 1)  order by (select c1 from t1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER            |        |301      |1096|
|1 | MERGE UNION DISTINCT     |        |301      |700 |
|2 |  SUBPLAN FILTER          |        |300      |601 |
|3 |   PX COORDINATOR         |        |300      |206 |
|4 |    EXCHANGE OUT DISTR    |:EX10000|300      |192 |
|5 |     PX PARTITION ITERATOR|        |300      |192 |
|6 |      TABLE SCAN          |t2      |300      |192 |
|7 |   PX COORDINATOR         |        |500      |354 |
|8 |    EXCHANGE OUT DISTR    |:EX20000|500      |331 |
|9 |     PX PARTITION ITERATOR|        |500      |331 |
|10|      TABLE SCAN          |t1      |500      |331 |
|11|  EXPRESSION              |        |1        |1   |
|12| PX COORDINATOR           |        |500      |354 |
|13|  EXCHANGE OUT DISTR      |:EX30000|500      |331 |
|14|   PX PARTITION ITERATOR  |        |500      |331 |
|15|    TABLE SCAN            |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), BIGINT(20, 0))]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), dop=1
  5 - output([1]), filter(nil), 
      force partition granule, asc.
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil)
  8 - output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([?]), filter(nil)
      values({?})
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), dop=1
  14 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  15 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 592(end)  ************** 

***************   Case 593   ***************

SQL: (select c1 from t1) union (select c2 from t1) union (select c2 from t2); 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT        |             |1300     |3515|
|1 | MERGE UNION DISTINCT       |             |1000     |2440|
|2 |  PX COORDINATOR MERGE SORT |             |500      |990 |
|3 |   EXCHANGE OUT DISTR       |:EX10000     |500      |966 |
|4 |    SORT                    |             |500      |966 |
|5 |     PX PARTITION ITERATOR  |             |500      |331 |
|6 |      TABLE SCAN            |t1           |500      |331 |
|7 |  PX COORDINATOR MERGE SORT |             |500      |1122|
|8 |   EXCHANGE OUT DISTR       |:EX20000     |500      |1074|
|9 |    SORT                    |             |500      |1074|
|10|     PX PARTITION ITERATOR  |             |500      |342 |
|11|      TABLE SCAN            |t1(idx_t1_c2)|500      |342 |
|12| PX COORDINATOR MERGE SORT  |             |300      |647 |
|13|  EXCHANGE OUT DISTR        |:EX30000     |300      |619 |
|14|   SORT                     |             |300      |619 |
|15|    PX PARTITION ITERATOR   |             |300      |198 |
|16|     TABLE SCAN             |t2           |300      |198 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  5 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  8 - output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  10 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  11 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  12 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  13 - output([t2.c2]), filter(nil), dop=1
  14 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  15 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  16 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 593(end)  ************** 

***************   Case 594   ***************

SQL: (select c1 from t1) union (select 1); 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH UNION DISTINCT     |        |501      |878 |
|1 | PX COORDINATOR         |        |500      |354 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |331 |
|3 |   PX PARTITION ITERATOR|        |500      |331 |
|4 |    TABLE SCAN          |t1      |500      |331 |
|5 | EXPRESSION             |        |1        |1   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([cast(t1.c1, BIGINT(20, 0))]), filter(nil)
  2 - output([cast(t1.c1, BIGINT(20, 0))]), filter(nil), dop=1
  3 - output([cast(t1.c1, BIGINT(20, 0))]), filter(nil), 
      force partition granule, asc.
  4 - output([cast(t1.c1, BIGINT(20, 0))]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([?]), filter(nil)
      values({?})

*************** Case 594(end)  ************** 

***************   Case 595   ***************

SQL: (select a from t12) union (select 1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |101      |121 |
|1 | TABLE SCAN         |t12 |100      |88  |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t12.a]), filter(nil), 
      access([t12.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil)
      values({?})

*************** Case 595(end)  ************** 

***************   Case 596   ***************

SQL: (select pk1 from set_t1) union distinct (select pk2 from set_t2); 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |MERGE UNION DISTINCT|      |200      |241 |
|1 | TABLE SCAN         |set_t1|100      |88  |
|2 | TABLE SCAN         |set_t2|100      |88  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 596(end)  ************** 

***************   Case 597   ***************

SQL: (select pk1 from set_t1) union all (select pk2 from set_t2); 

======================================
|ID|OPERATOR   |NAME  |EST. ROWS|COST|
--------------------------------------
|0 |UNION ALL  |      |200      |241 |
|1 | TABLE SCAN|set_t1|100      |88  |
|2 | TABLE SCAN|set_t2|100      |88  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 597(end)  ************** 

***************   Case 598   ***************

SQL: (select pk1 from set_t1) except (select pk2 from set_t2); 

================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE EXCEPT DISTINCT|      |100      |228 |
|1 | TABLE SCAN          |set_t1|100      |88  |
|2 | TABLE SCAN          |set_t2|100      |88  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 598(end)  ************** 

***************   Case 599   ***************

SQL: (select pk1 from set_t1) intersect (select pk2 from set_t2); 

===================================================
|ID|OPERATOR                |NAME  |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE INTERSECT DISTINCT|      |100      |228 |
|1 | TABLE SCAN             |set_t1|100      |88  |
|2 | TABLE SCAN             |set_t2|100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 599(end)  ************** 

***************   Case 600   ***************

SQL: (select a2, a1 from set_t1) union distinct (select b2, b1 from set_t2); 

==============================================
|ID|OPERATOR           |NAME  |EST. ROWS|COST|
----------------------------------------------
|0 |HASH UNION DISTINCT|      |200      |405 |
|1 | TABLE SCAN        |set_t1|100      |92  |
|2 | TABLE SCAN        |set_t2|100      |92  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 600(end)  ************** 

***************   Case 601   ***************

SQL: (select a2, a1 from set_t1) union all (select b2, b1 from set_t2); 

======================================
|ID|OPERATOR   |NAME  |EST. ROWS|COST|
--------------------------------------
|0 |UNION ALL  |      |200      |261 |
|1 | TABLE SCAN|set_t1|100      |92  |
|2 | TABLE SCAN|set_t2|100      |92  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 601(end)  ************** 

***************   Case 602   ***************

SQL: (select a2, a1 from set_t1) except (select b2, b1 from set_t2); 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |HASH EXCEPT DISTINCT|      |100      |392 |
|1 | TABLE SCAN         |set_t1|100      |92  |
|2 | TABLE SCAN         |set_t2|100      |92  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 602(end)  ************** 

***************   Case 603   ***************

SQL: (select a2, a1 from set_t1) intersect (select b2, b1 from set_t2); 

==================================================
|ID|OPERATOR               |NAME  |EST. ROWS|COST|
--------------------------------------------------
|0 |HASH INTERSECT DISTINCT|      |100      |392 |
|1 | TABLE SCAN            |set_t1|100      |92  |
|2 | TABLE SCAN            |set_t2|100      |92  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 603(end)  ************** 

***************   Case 604   ***************

SQL: (select a2, a1 from set_t1) union distinct (select b2, b1 from set_t2) order by a2 desc; 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |SORT                |      |200      |676 |
|1 | HASH UNION DISTINCT|      |200      |405 |
|2 |  TABLE SCAN        |set_t1|100      |92  |
|3 |  TABLE SCAN        |set_t2|100      |92  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), sort_keys([UNION([1]), DESC])
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 604(end)  ************** 

***************   Case 605   ***************

SQL: (select a2, a1 from set_t1) union all (select b2, b1 from set_t2) order by a2 desc; 

=======================================
|ID|OPERATOR    |NAME  |EST. ROWS|COST|
---------------------------------------
|0 |SORT        |      |200      |532 |
|1 | UNION ALL  |      |200      |261 |
|2 |  TABLE SCAN|set_t1|100      |92  |
|3 |  TABLE SCAN|set_t2|100      |92  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), sort_keys([UNION([1]), DESC])
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 605(end)  ************** 

***************   Case 606   ***************

SQL: (select a2, a1 from set_t1) except (select b2, b1 from set_t2) order by a2 desc; 

================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST|
------------------------------------------------
|0 |SORT                 |      |100      |519 |
|1 | HASH EXCEPT DISTINCT|      |100      |392 |
|2 |  TABLE SCAN         |set_t1|100      |92  |
|3 |  TABLE SCAN         |set_t2|100      |92  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil), sort_keys([EXCEPT([1]), DESC])
  1 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 606(end)  ************** 

***************   Case 607   ***************

SQL: (select a2, a1 from set_t1) intersect (select b2, b1 from set_t2) order by a2 desc; 

===================================================
|ID|OPERATOR                |NAME  |EST. ROWS|COST|
---------------------------------------------------
|0 |SORT                    |      |100      |519 |
|1 | HASH INTERSECT DISTINCT|      |100      |392 |
|2 |  TABLE SCAN            |set_t1|100      |92  |
|3 |  TABLE SCAN            |set_t2|100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil), sort_keys([INTERSECT([1]), DESC])
  1 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 607(end)  ************** 

***************   Case 608   ***************

SQL: (select c1 from t15) union all (select c1 from t14) union select 7; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |HASH UNION DISTINCT      |        |901      |1925|
|1 | UNION ALL               |        |900      |984 |
|2 |  PX COORDINATOR         |        |400      |289 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|400      |270 |
|4 |    PX PARTITION ITERATOR|        |400      |270 |
|5 |     TABLE SCAN          |t15     |400      |270 |
|6 |  PX COORDINATOR         |        |500      |400 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|500      |353 |
|8 |    PX PARTITION ITERATOR|        |500      |353 |
|9 |     TABLE SCAN          |t14     |500      |353 |
|10| EXPRESSION              |        |1        |1   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([cast(UNION([1]), BIGINT(20, 0))]), filter(nil)
  2 - output([t15.c1]), filter(nil)
  3 - output([t15.c1]), filter(nil), dop=1
  4 - output([t15.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t15.c1]), filter(nil), 
      access([t15.c1]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  6 - output([t14.c1]), filter(nil)
  7 - output([t14.c1]), filter(nil), dop=1
  8 - output([t14.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t14.c1]), filter(nil), 
      access([t14.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  10 - output([?]), filter(nil)
      values({?})

*************** Case 608(end)  ************** 

***************   Case 609   ***************

SQL: select 1 from t1,t2 order by t1.c2+t2.c2; 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |SORT                       |        |150000   |489777|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |108438|
|2 |  PX COORDINATOR           |        |500      |389   |
|3 |   EXCHANGE OUT DISTR      |:EX10000|500      |342   |
|4 |    PX PARTITION ITERATOR  |        |500      |342   |
|5 |     TABLE SCAN            |t1      |500      |342   |
|6 |  MATERIAL                 |        |300      |337   |
|7 |   PX COORDINATOR          |        |300      |227   |
|8 |    EXCHANGE OUT DISTR     |:EX20000|300      |198   |
|9 |     PX PARTITION ITERATOR |        |300      |198   |
|10|      TABLE SCAN           |t2      |300      |198   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), sort_keys([t1.c2 + t2.c2, ASC])
  1 - output([t1.c2 + t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t1.c2]), filter(nil)
  3 - output([t1.c2]), filter(nil), dop=1
  4 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c2]), filter(nil)
  7 - output([t2.c2]), filter(nil)
  8 - output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 609(end)  ************** 

***************   Case 610   ***************

SQL: select 'a', c1 from t1 union select 'b', c1 from t7; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |600      |1316|
|1 | EXCHANGE OUT DISTR          |:EX10001|600      |1288|
|2 |  MERGE UNION DISTINCT       |        |600      |1288|
|3 |   SORT                      |        |500      |966 |
|4 |    PX PARTITION ITERATOR    |        |500      |331 |
|5 |     TABLE SCAN              |t1      |500      |331 |
|6 |   EXCHANGE IN DISTR         |        |100      |93  |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|8 |     TABLE SCAN              |t7      |100      |88  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil), dop=1
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([?], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([?], [t7.c1]), filter(nil)
  7 - (#keys=1, [t7.c1]), output([t7.c1], [?]), filter(nil), is_single, dop=1
  8 - output([t7.c1], [?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 610(end)  ************** 

***************   Case 611   ***************

SQL: SELECT b FROM t13 WHERE b=1 UNION SELECT b FROM t13 WHERE b=1; 

============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |HASH UNION DISTINCT|    |2        |215 |
|1 | TABLE SCAN        |t13 |1        |107 |
|2 | TABLE SCAN        |t13 |1        |107 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t13.b]), filter([t13.b = ?]), 
      access([t13.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t13.a]), range(MIN ; MAX)always true
  2 - output([t13.b]), filter([t13.b = ?]), 
      access([t13.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 611(end)  ************** 

***************   Case 612   ***************

SQL: select * from t7, t8 where (t7.c1, t7.c2) = (t8.c1, t8.c2); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |275 |
|1 | TABLE SCAN|t7  |100      |90  |
|2 | TABLE SCAN|t8  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1], [t7.c2 = t8.c2]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 612(end)  ************** 

***************   Case 613   ***************

SQL: select * from t7 inner join t8 on (t7.c1, t7.c2) = (t8.c1, t8.c2); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |275 |
|1 | TABLE SCAN|t7  |100      |90  |
|2 | TABLE SCAN|t8  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1], [t7.c2 = t8.c2]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 613(end)  ************** 

***************   Case 614   ***************

SQL: select * from t7, t8 where (t7.c1, t7.c2) > (t8.c1, t8.c2); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |3334     |4839|
|1 | TABLE SCAN     |t7  |100      |90  |
|2 | MATERIAL       |    |100      |127 |
|3 |  TABLE SCAN    |t8  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds([(t7.c1, t7.c2) > (t8.c1, t8.c2)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 614(end)  ************** 

***************   Case 615   ***************

SQL: select * from t7 inner join t8 on (t7.c1, t7.c2) <= (t8.c1, t8.c2); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |3334     |4839|
|1 | TABLE SCAN     |t7  |100      |90  |
|2 | MATERIAL       |    |100      |127 |
|3 |  TABLE SCAN    |t8  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds([(t7.c1, t7.c2) <= (t8.c1, t8.c2)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 615(end)  ************** 

***************   Case 616   ***************

SQL: select distinct c1+@var from t1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |900 |
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |876 |
|2 |  HASH DISTINCT              |        |500      |876 |
|3 |   EXCHANGE IN DISTR         |        |500      |354 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|500      |331 |
|5 |     PX PARTITION ITERATOR   |        |500      |331 |
|6 |      TABLE SCAN             |t1      |500      |331 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter(nil)
  1 - output([t1.c1 + ?]), filter(nil), dop=1
  2 - output([t1.c1 + ?]), filter(nil), 
      distinct([t1.c1 + ?])
  3 - output([t1.c1 + ?]), filter(nil)
  4 - (#keys=1, [t1.c1 + ?]), output([t1.c1 + ?]), filter(nil), dop=1
  5 - output([t1.c1 + ?]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 616(end)  ************** 

***************   Case 617   ***************

SQL: select distinct c1+(@a:=c2) from t1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |958 |
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |911 |
|2 |  HASH DISTINCT              |        |500      |911 |
|3 |   EXCHANGE IN DISTR         |        |500      |389 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|500      |342 |
|5 |     PX PARTITION ITERATOR   |        |500      |342 |
|6 |      TABLE SCAN             |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil)
  1 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      distinct([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)])
  3 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil)
  4 - (#keys=1, [t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), dop=1
  5 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 617(end)  ************** 

***************   Case 618   ***************

SQL: select distinct c1+(@a:=c1) from t1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |900 |
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |876 |
|2 |  HASH DISTINCT              |        |500      |876 |
|3 |   EXCHANGE IN DISTR         |        |500      |354 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|500      |331 |
|5 |     PX PARTITION ITERATOR   |        |500      |331 |
|6 |      TABLE SCAN             |t1      |500      |331 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil)
  1 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), 
      distinct([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)])
  3 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil)
  4 - (#keys=1, [t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), dop=1
  5 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 618(end)  ************** 

***************   Case 619   ***************

SQL: select distinct c2+(@a:=c2) from t1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |832 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |823 |
|2 |  HASH DISTINCT              |        |100      |823 |
|3 |   EXCHANGE IN DISTR         |        |100      |587 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |577 |
|5 |     HASH DISTINCT           |        |100      |577 |
|6 |      PX PARTITION ITERATOR  |        |500      |342 |
|7 |       TABLE SCAN            |t1      |500      |342 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil)
  1 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      distinct([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)])
  3 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil)
  4 - (#keys=1, [t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), dop=1
  5 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      distinct([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)])
  6 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 619(end)  ************** 

***************   Case 620   ***************

SQL: select /*+use_merge(tt1 tt2)*/* from tt1,tt2 where tt1.c1=tt2.c1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |527 |
|1 | TABLE SCAN|tt1 |100      |90  |
|2 | TABLE SCAN|tt2 |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), 
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
  1 - output([tt1.c1], [tt1.c2]), filter(nil), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true
  2 - output([tt2.c1], [tt2.c2]), filter(nil), 
      access([tt2.c1], [tt2.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true

*************** Case 620(end)  ************** 

***************   Case 621   ***************

SQL: select /*+use_merge(tt1 tt2)*/* from tt1,tt2 where tt1.c2=tt2.c2; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |527 |
|1 | TABLE SCAN|tt1 |100      |90  |
|2 | TABLE SCAN|tt2 |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), 
      equal_conds([tt1.c2 = tt2.c2]), other_conds(nil)
  1 - output([tt1.c2], [tt1.c1]), filter(nil), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true
  2 - output([tt2.c2], [tt2.c1]), filter(nil), 
      access([tt2.c2], [tt2.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true

*************** Case 621(end)  ************** 

***************   Case 622   ***************

SQL: select /*+use_merge(t1, t2)*/* from t1,t2 where t1.c1=t2.c3; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |290      |1634|
|1 | PX COORDINATOR         |        |500      |389 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|3 |   PX PARTITION ITERATOR|        |500      |342 |
|4 |    TABLE SCAN          |t1      |500      |342 |
|5 | PX COORDINATOR         |        |300      |290 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |205 |
|7 |   PX PARTITION ITERATOR|        |300      |205 |
|8 |    TABLE SCAN          |t2      |300      |205 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c3]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 622(end)  ************** 

***************   Case 623   ***************

SQL: select /*+use_merge(t1, t12)*/* from t1,t12 where t1.c1=t12.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |1369|
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |1338|
|2 |  MERGE JOIN                 |        |100      |1338|
|3 |   SORT                      |        |500      |1074|
|4 |    PX PARTITION ITERATOR    |        |500      |342 |
|5 |     TABLE SCAN              |t1      |500      |342 |
|6 |   EXCHANGE IN DISTR         |        |100      |114 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |92  |
|8 |     TABLE SCAN              |t12     |100      |92  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t12.a], [t12.b], [t12.c]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t12.a], [t12.b], [t12.c]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t12.a], [t12.b], [t12.c]), filter(nil), 
      equal_conds([t1.c1 = t12.a]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t12.a], [t12.b], [t12.c]), filter(nil)
  7 - (#keys=1, [t12.a]), output([t12.a], [t12.b], [t12.c]), filter(nil), is_single, dop=1
  8 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 623(end)  ************** 

***************   Case 624   ***************

SQL: select /*+use_merge(t1, t13)*/* from t1,t13 where t1.c1=t13.b; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |100      |902 |
|1 | TABLE SCAN             |t13     |100      |92  |
|2 | PX COORDINATOR         |        |500      |389 |
|3 |  EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|4 |   PX PARTITION ITERATOR|        |500      |342 |
|5 |    TABLE SCAN          |t1      |500      |342 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t13.b], [t13.c], [t13.a]), filter(nil), 
      equal_conds([t1.c1 = t13.b]), other_conds(nil)
  1 - output([t13.b], [t13.c], [t13.a]), filter(nil), 
      access([t13.b], [t13.c], [t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 624(end)  ************** 

***************   Case 625   ***************

SQL: select /*+use_merge(t1, t_u)*/* from t1,t_u where t1.c1=t_u.c1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |290      |2016|
|1 | PX COORDINATOR MERGE SORT |        |500      |1122|
|2 |  EXCHANGE OUT DISTR       |:EX10000|500      |1074|
|3 |   SORT                    |        |500      |1074|
|4 |    PX PARTITION ITERATOR  |        |500      |342 |
|5 |     TABLE SCAN            |t1      |500      |342 |
|6 | PX COORDINATOR MERGE SORT |        |300      |588 |
|7 |  EXCHANGE OUT DISTR       |:EX20000|300      |574 |
|8 |   SORT                    |        |300      |574 |
|9 |    PX PARTITION ITERATOR  |        |300      |211 |
|10|     TABLE SCAN            |t_u     |300      |211 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t_u.c1]), filter(nil), 
      equal_conds([t1.c1 = t_u.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  7 - output([t_u.c1]), filter(nil), dop=1
  8 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  9 - output([t_u.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t_u.c1]), filter(nil), 
      access([t_u.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t_u.__pk_increment], [t_u.__pk_cluster_id], [t_u.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 625(end)  ************** 

***************   Case 626   ***************

SQL: select /*+use_merge(t_u, t12)*/* from t_u,t12 where t12.a=t_u.c1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |290      |932 |
|1 | PX COORDINATOR MERGE SORT |        |300      |588 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|300      |574 |
|3 |   SORT                    |        |300      |574 |
|4 |    PX PARTITION ITERATOR  |        |300      |211 |
|5 |     TABLE SCAN            |t_u     |300      |211 |
|6 | TABLE SCAN                |t12     |100      |92  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_u.c1], [t12.a], [t12.b], [t12.c]), filter(nil), 
      equal_conds([t12.a = t_u.c1]), other_conds(nil)
  1 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  2 - output([t_u.c1]), filter(nil), dop=1
  3 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  4 - output([t_u.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t_u.c1]), filter(nil), 
      access([t_u.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t_u.__pk_increment], [t_u.__pk_cluster_id], [t_u.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  6 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 626(end)  ************** 

***************   Case 627   ***************

SQL: select /*+use_merge(t2, t3)*/* from t2,t3 where t2.c3=t3.c3; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |551      |3720|
|1 | PX COORDINATOR MERGE SORT |        |300      |1893|
|2 |  EXCHANGE OUT DISTR       |:EX10000|300      |1808|
|3 |   SORT                    |        |300      |1808|
|4 |    PX PARTITION ITERATOR  |        |300      |205 |
|5 |     TABLE SCAN            |t2      |300      |205 |
|6 | PX COORDINATOR MERGE SORT |        |200      |1220|
|7 |  EXCHANGE OUT DISTR       |:EX20000|200      |1163|
|8 |   SORT                    |        |200      |1163|
|9 |    PX PARTITION ITERATOR  |        |200      |149 |
|10|     TABLE SCAN            |t3      |200      |149 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c3, ASC])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c3, ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c3, ASC])
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c3, ASC])
  9 - output([t3.c1], [t3.c3], [t3.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t3.c1], [t3.c3], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c3], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 627(end)  ************** 

***************   Case 628   ***************

SQL: select * from yuming where c2 in ('-99999.99999','0.0'); 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|yuming|2        |99  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([yuming.c1], [yuming.c2]), filter([yuming.c2 IN (?, ?)]), 
      access([yuming.c2], [yuming.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([yuming.c1], [yuming.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 628(end)  ************** 

***************   Case 629   ***************

SQL: select * from query_range where (c1, c2, c3) in ((1, 2, 3), (4, 5, 6)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |58  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter(nil), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 629(end)  ************** 

***************   Case 630   ***************

SQL: select * from query_range where (c1, c2, c3) in ((1, 2, 3), (4, (select 5), 6)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |58  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter(nil), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 630(end)  ************** 

***************   Case 631   ***************

SQL: select * from query_range where (c1, c2, c3) in (((select 1), 2, 3), ((select 4), 5, 6)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |58  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter(nil), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 631(end)  ************** 

***************   Case 632   ***************

SQL: select * from query_range where (c1, c2, c3) in ((1, 2, 3), (4, 5, 6)) and c4>0; 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |58  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([query_range.c4 > ?]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 632(end)  ************** 

***************   Case 633   ***************

SQL: select * from query_range where c1=1 and (c2, c3) in ((1, 2), (3, 4)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|1        |58  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([(query_range.c2, query_range.c3) IN ((?, ?), (?, ?))]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,1,2 ; 1,1,2], [1,3,4 ; 1,3,4], 
      range_cond([query_range.c1 = ?])

*************** Case 633(end)  ************** 

***************   Case 634   ***************

SQL: select * from query_range where c1>1 and (c2, c3) in ((1, 2), (3, 4)); 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|query_range|1        |105 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([(query_range.c2, query_range.c3) IN ((?, ?), (?, ?))]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range(1,MAX,MAX ; MAX,3,4), 
      range_cond([query_range.c1 > ?])

*************** Case 634(end)  ************** 

***************   Case 635   ***************

SQL: select c2 from t4 where c2=1 and c3 is null group by c2; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE GROUP BY|                |1        |106 |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(1,NULL,MIN ; 1,NULL,MAX), 
      range_cond([t4.c2 = ?], [(T_OP_IS, t4.c3, NULL, 0)])

*************** Case 635(end)  ************** 

***************   Case 636   ***************

SQL: select count(1) as c from t7 having (select c from t7 t)>0; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |209 |
|1 | SCALAR GROUP BY|    |1        |107 |
|2 |  TABLE SCAN    |t7  |100      |88  |
|3 | TABLE SCAN     |t   |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(?)]), filter([subquery(1) > ?]), 
      exec_params_([T_FUN_COUNT(?)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  2 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 636(end)  ************** 

***************   Case 637   ***************

SQL: SELECT t1.c1 FROM t7 t1 GROUP BY t1.c1 HAVING t1.c1 < ALL(SELECT t2.c1 FROM t7 t2 GROUP BY t2.c1 HAVING EXISTS(SELECT t3.c1 FROM t7 t3 GROUP BY t3.c1 HAVING SUM(t1.c1+t2.c1) < t3.c1/4)); 

====================================================
|ID|OPERATOR                 |NAME |EST. ROWS|COST |
----------------------------------------------------
|0 |SUBPLAN FILTER           |     |50       |25382|
|1 | TABLE SCAN              |t1   |100      |88   |
|2 | SCALAR GROUP BY         |     |1        |253  |
|3 |  SUBPLAN SCAN           |VIEW2|1        |253  |
|4 |   LIMIT                 |     |1        |253  |
|5 |    NESTED-LOOP SEMI JOIN|     |1        |253  |
|6 |     TABLE SCAN          |t2   |4        |37   |
|7 |     MATERIAL            |     |100      |106  |
|8 |      TABLE SCAN         |t3   |100      |88   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([t1.c1 < ALL(subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([T_FUN_MIN(VIEW2.c1)]), filter([(T_OP_IS_NOT, T_FUN_MIN(VIEW2.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  3 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  4 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  5 - output([t2.c1]), filter(nil), 
      conds([cast(? + t2.c1, DECIMAL(12, 0)) < t3.c1 / ?]), nl_params_(nil), batch_join=false
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t3.c1]), filter(nil)
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 637(end)  ************** 

***************   Case 638   ***************

SQL: select count(1) from t_func group by c1,c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t_func  |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN ? THEN 1 ELSE 0 END]), filter(nil)
  1 - output([CASE WHEN ? THEN 1 ELSE 0 END]), filter(nil), dop=1
  2 - output([CASE WHEN ? THEN 1 ELSE 0 END]), filter(nil), 
      force partition granule, asc.
  3 - output([CASE WHEN ? THEN 1 ELSE 0 END]), filter(nil), 
      access([t_func.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_func.c1], [t_func.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 638(end)  ************** 

***************   Case 639   ***************

SQL: select count(1) from t_func group by c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |635 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |626 |
|2 |  MERGE GROUP BY               |        |100      |626 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |100      |489 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|100      |479 |
|5 |     PX PARTITION ITERATOR     |        |100      |479 |
|6 |      MERGE GROUP BY           |        |100      |479 |
|7 |       TABLE SCAN              |t_func  |500      |342 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(?))]), filter(nil), 
      group([t_func.c1]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  3 - output([T_FUN_COUNT(?)], [t_func.c1]), filter(nil), sort_keys([t_func.c1, ASC]), Local Order
  4 - (#keys=1, [t_func.c1]), output([T_FUN_COUNT(?)], [t_func.c1]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(?)], [t_func.c1]), filter(nil), 
      force partition granule, asc.
  6 - output([T_FUN_COUNT(?)], [t_func.c1]), filter(nil), 
      group([t_func.c1]), agg_func([T_FUN_COUNT(?)])
  7 - output([t_func.c1]), filter(nil), 
      access([t_func.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_func.c1], [t_func.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 639(end)  ************** 

***************   Case 640   ***************

SQL: select count(1) from t_func group by floor(c2+c1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |938 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |890 |
|2 |  PX PARTITION ITERATOR|        |500      |890 |
|3 |   HASH GROUP BY       |        |500      |890 |
|4 |    TABLE SCAN         |t_func  |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(?)]), filter(nil)
  1 - output([T_FUN_COUNT(?)]), filter(nil), dop=1
  2 - output([T_FUN_COUNT(?)]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([T_FUN_COUNT(?)]), filter(nil), 
      group([floor(t_func.c2 + t_func.c1)]), agg_func([T_FUN_COUNT(?)])
  4 - output([floor(t_func.c2 + t_func.c1)]), filter(nil), 
      access([t_func.c2], [t_func.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_func.c1], [t_func.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 640(end)  ************** 

***************   Case 641   ***************

SQL: select distinct c1 from t_f; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |854 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |845 |
|2 |  HASH DISTINCT              |        |100      |845 |
|3 |   EXCHANGE IN DISTR         |        |100      |609 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |600 |
|5 |     HASH DISTINCT           |        |100      |600 |
|6 |      PX PARTITION ITERATOR  |        |500      |364 |
|7 |       TABLE SCAN            |t_f     |500      |364 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_f.c1]), filter(nil)
  1 - output([t_f.c1]), filter(nil), dop=1
  2 - output([t_f.c1]), filter(nil), 
      distinct([t_f.c1])
  3 - output([t_f.c1]), filter(nil)
  4 - (#keys=1, [t_f.c1]), output([t_f.c1]), filter(nil), dop=1
  5 - output([t_f.c1]), filter(nil), 
      distinct([t_f.c1])
  6 - output([t_f.c1]), filter(nil), 
      force partition granule, asc.
  7 - output([t_f.c1]), filter(nil), 
      access([t_f.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_f.__pk_increment], [t_f.__pk_cluster_id], [t_f.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 641(end)  ************** 

***************   Case 642   ***************

SQL: select distinct c1,c2 from t_f; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |973 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |926 |
|2 |  PX PARTITION ITERATOR|        |500      |926 |
|3 |   HASH DISTINCT       |        |500      |926 |
|4 |    TABLE SCAN         |t_f     |500      |375 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_f.c1], [t_f.c2]), filter(nil)
  1 - output([t_f.c1], [t_f.c2]), filter(nil), dop=1
  2 - output([t_f.c1], [t_f.c2]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t_f.c1], [t_f.c2]), filter(nil), 
      distinct([t_f.c1], [t_f.c2])
  4 - output([t_f.c2], [t_f.c1]), filter(nil), 
      access([t_f.c2], [t_f.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_f.__pk_increment], [t_f.__pk_cluster_id], [t_f.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 642(end)  ************** 

***************   Case 643   ***************

SQL: select distinct c1,c2,c3 from t_f; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |1037|
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |966 |
|2 |  PX PARTITION ITERATOR|        |500      |966 |
|3 |   HASH DISTINCT       |        |500      |966 |
|4 |    TABLE SCAN         |t_f     |500      |386 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_f.c1], [t_f.c2], [t_f.c3]), filter(nil)
  1 - output([t_f.c1], [t_f.c2], [t_f.c3]), filter(nil), dop=1
  2 - output([t_f.c1], [t_f.c2], [t_f.c3]), filter(nil), 
      partition wise, force partition granule, asc.
  3 - output([t_f.c1], [t_f.c2], [t_f.c3]), filter(nil), 
      distinct([t_f.c1], [t_f.c2], [t_f.c3])
  4 - output([t_f.c2], [t_f.c1], [t_f.c3]), filter(nil), 
      access([t_f.c2], [t_f.c1], [t_f.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_f.__pk_increment], [t_f.__pk_cluster_id], [t_f.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 643(end)  ************** 

***************   Case 644   ***************

SQL: select c1 from t7 group by c1 having (select count(t7.c1) from t7 t)>0; 

========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |SUBPLAN FILTER|    |34       |10232|
|1 | TABLE SCAN   |t7  |100      |88   |
|2 | TABLE SCAN   |t   |100      |88   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([subquery(1) > ?]), 
      exec_params_([CASE WHEN (T_OP_IS_NOT, t7.c1, NULL, 0) THEN 1 ELSE 0 END]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 644(end)  ************** 

***************   Case 645   ***************

SQL: select c1 from t7 having (select t7.c1 from t7 t)>0; 

========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |SUBPLAN FILTER|    |34       |10232|
|1 | TABLE SCAN   |t7  |100      |88   |
|2 | TABLE SCAN   |t   |100      |88   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([subquery(1) > ?]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 645(end)  ************** 

***************   Case 646   ***************

SQL: select c1 from t7 group by c2 having (select t7.c1 from t7 t)>0; 

========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |SUBPLAN FILTER|    |34       |10339|
|1 | HASH GROUP BY|    |100      |195  |
|2 |  TABLE SCAN  |t7  |100      |90   |
|3 | TABLE SCAN   |t   |100      |88   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([subquery(1) > ?]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 646(end)  ************** 

***************   Case 647   ***************

SQL: select /*+leading(b, a) use_nl(a, b) read_consistency(weak) query_timeout(120000000)*/ count(*) as COUNT, nvl(sum(b.receive_fee),0) as AMOUNT from trade_process_000 b, trade_base_000 a where a.trade_no = b.trade_no and b.gmt_receive_pay >= '2023-09-26 10:21:55' and b.gmt_receive_pay < '2023-09-26 15:55:15' and (a.product IN ('S','M','L') or a.product not IN ('M','L','XL'))and (a.trade_type IN ('S','FP','RM','MT') or a.trade_type not IN ('FP','RM','MT','COD')); 

=======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST |
-------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |32347|
|1 | PX COORDINATOR          |        |1        |32347|
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |32346|
|3 |   MERGE GROUP BY        |        |1        |32346|
|4 |    PX PARTITION ITERATOR|        |1        |32346|
|5 |     NESTED-LOOP JOIN    |        |1        |32346|
|6 |      TABLE SCAN         |b       |1        |32346|
|7 |      TABLE GET          |a       |1        |53   |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [nvl(T_FUN_SUM(T_FUN_SUM(b.RECEIVE_FEE)), ?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(b.RECEIVE_FEE))])
  1 - output([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)]), filter(nil)
  2 - output([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)])
  4 - output([b.RECEIVE_FEE]), filter(nil), 
      partition wise, force partition granule, asc.
  5 - output([b.RECEIVE_FEE]), filter(nil), 
      conds(nil), nl_params_([b.TRADE_NO]), batch_join=true
  6 - output([b.TRADE_NO], [b.RECEIVE_FEE]), filter([b.GMT_RECEIVE_PAY < ?], [b.GMT_RECEIVE_PAY >= ?]), 
      access([b.TRADE_NO], [b.GMT_RECEIVE_PAY], [b.RECEIVE_FEE]), partitions(p[0-399]), 
      is_index_back=false, filter_before_indexback[false,false], 
      hint(read_consistency:2), 
      range_key([b.TRADE_NO]), range(MIN ; MAX)always true
  7 - output([1]), filter([a.TRADE_TYPE IN (?, ?, ?, ?) OR (T_OP_NOT_IN, a.TRADE_TYPE, (?, ?, ?, ?))], [a.PRODUCT IN (?, ?, ?) OR (T_OP_NOT_IN, a.PRODUCT, (?, ?, ?))]), 
      access([a.PRODUCT], [a.TRADE_TYPE]), partitions(p[0-399]), 
      is_index_back=false, filter_before_indexback[false,false], 
      hint(read_consistency:2), 
      range_key([a.TRADE_NO]), range(MIN ; MAX), 
      range_cond([a.TRADE_NO = ?])

*************** Case 647(end)  ************** 

***************   Case 648   ***************

SQL: select * from t0, t0 t where t0.c1=t.c2 and t0.c1=t.c1 order by t0.c1, t.c1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |SORT        |    |1        |232 |
|1 | HASH JOIN  |    |1        |231 |
|2 |  TABLE SCAN|t   |1        |103 |
|3 |  TABLE SCAN|t0  |100      |95  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), sort_keys([t0.c1, ASC])
  1 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), 
      equal_conds([t0.c1 = t.c2]), other_conds(nil)
  2 - output([t.c2], [t.c1], [t.pk], [t.a3]), filter([t.c2 = t.c1]), 
      access([t.c2], [t.c1], [t.pk], [t.a3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t.pk]), range(MIN ; MAX)always true
  3 - output([t0.c1], [t0.pk], [t0.c2], [t0.a3]), filter(nil), 
      access([t0.c1], [t0.pk], [t0.c2], [t0.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 648(end)  ************** 

***************   Case 649   ***************

SQL: select * from t0, t0 t where t0.c1=t.c1 and t0.c1=t.c2 order by t0.c1, t.c1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |SORT        |    |1        |232 |
|1 | HASH JOIN  |    |1        |231 |
|2 |  TABLE SCAN|t   |1        |103 |
|3 |  TABLE SCAN|t0  |100      |95  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), sort_keys([t0.c1, ASC])
  1 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), 
      equal_conds([t0.c1 = t.c1]), other_conds(nil)
  2 - output([t.c1], [t.c2], [t.pk], [t.a3]), filter([t.c1 = t.c2]), 
      access([t.c1], [t.c2], [t.pk], [t.a3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t.pk]), range(MIN ; MAX)always true
  3 - output([t0.c1], [t0.pk], [t0.c2], [t0.a3]), filter(nil), 
      access([t0.c1], [t0.pk], [t0.c2], [t0.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 649(end)  ************** 

***************   Case 650   ***************

SQL: select * from t0, t0 t where t0.c1=t.c1 and t0.c1=t.c1 order by t0.c1, t.c1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |607 |
|1 | SORT       |    |100      |261 |
|2 |  TABLE SCAN|t0  |100      |95  |
|3 | SORT       |    |100      |261 |
|4 |  TABLE SCAN|t   |100      |95  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), 
      equal_conds([t0.c1 = t.c1]), other_conds(nil)
  1 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3]), filter(nil), sort_keys([t0.c1, ASC])
  2 - output([t0.c1], [t0.pk], [t0.c2], [t0.a3]), filter(nil), 
      access([t0.c1], [t0.pk], [t0.c2], [t0.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true
  3 - output([t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), sort_keys([t.c1, ASC])
  4 - output([t.c1], [t.pk], [t.c2], [t.a3]), filter(nil), 
      access([t.c1], [t.pk], [t.c2], [t.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.pk]), range(MIN ; MAX)always true

*************** Case 650(end)  ************** 

***************   Case 651   ***************

SQL: select * from t17 where c1=1 and c2 is null and c3=1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |247 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |205 |
|2 |  PX PARTITION ITERATOR|        |300      |205 |
|3 |   TABLE SCAN          |t17     |300      |205 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t17.c1], [t17.c2], [t17.c3]), filter(nil)
  1 - output([t17.c2], [t17.c3], [t17.c1]), filter(nil), dop=1
  2 - output([t17.c2], [t17.c3], [t17.c1]), filter(nil), 
      force partition granule, asc.
  3 - output([t17.c2], [t17.c3], [t17.c1]), filter(nil), startup_filter([0]), 
      access([t17.c2], [t17.c3], [t17.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 651(end)  ************** 

***************   Case 652   ***************

SQL: select c3 from t_normal_idx order by c3; 

=================================================
|ID|OPERATOR   |NAME             |EST. ROWS|COST|
-------------------------------------------------
|0 |SORT       |                 |100      |162 |
|1 | TABLE SCAN|t_normal_idx(idx)|100      |54  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), sort_keys([t_normal_idx.c3, ASC])
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 652(end)  ************** 

***************   Case 653   ***************

SQL: select c3 from t_normal_idx where c2=1 order by c3; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |57  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 653(end)  ************** 

***************   Case 654   ***************

SQL: select c3 from t_normal_idx where c2 is null order by c3; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |57  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,MIN,MIN,MIN,MIN,MIN ; NULL,MAX,MAX,MAX,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 654(end)  ************** 

***************   Case 655   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null order by c4,c5; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |61  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 655(end)  ************** 

***************   Case 656   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 order by c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |63  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 656(end)  ************** 

***************   Case 657   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3 is null and c4 is null and c5 is null order by c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |63  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,NULL,NULL,NULL,MIN,MIN ; NULL,NULL,NULL,NULL,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c3, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)], [(T_OP_IS, t_normal_idx.c5, NULL, 0)])

*************** Case 657(end)  ************** 

***************   Case 658   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 order by c4; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |59  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,MIN,MIN,MIN,MIN ; NULL,1,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 658(end)  ************** 

***************   Case 659   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 and c4 is null order by c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |63  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,NULL,MIN,MIN,MIN ; NULL,1,NULL,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)])

*************** Case 659(end)  ************** 

***************   Case 660   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 order by c3,c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |63  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 660(end)  ************** 

***************   Case 661   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 order by c2,c3,c4,c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |63  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 661(end)  ************** 

***************   Case 662   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 and c6 is null order by c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|0        |80  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter([(T_OP_IS, t_normal_idx.c6, NULL, 0)]), 
      access([t_normal_idx.c3], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 662(end)  ************** 

***************   Case 663   ***************

SQL: select c3 from t_normal_idx where c2=1 and c4 is null and c5=1 order by c3,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|0        |97  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter([(T_OP_IS, t_normal_idx.c4, NULL, 0)], [t_normal_idx.c5 = ?]), 
      access([t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 663(end)  ************** 

***************   Case 664   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c5=1 order by c4,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|1        |80  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter([t_normal_idx.c5 = ?]), 
      access([t_normal_idx.c3], [t_normal_idx.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 664(end)  ************** 

***************   Case 665   ***************

SQL: select c3 from t_normal_idx where c2 is not null order by c3; 

=================================================
|ID|OPERATOR   |NAME             |EST. ROWS|COST|
-------------------------------------------------
|0 |SORT       |                 |100      |200 |
|1 | TABLE SCAN|t_normal_idx(idx)|100      |73  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), sort_keys([t_normal_idx.c3, ASC])
  1 - output([t_normal_idx.c3]), filter([(T_OP_IS_NOT, t_normal_idx.c2, NULL, 0)]), 
      access([t_normal_idx.c2], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 665(end)  ************** 

***************   Case 666   ***************

SQL: select c3 from t_normal_idx group by c3; 

===================================================
|ID|OPERATOR     |NAME             |EST. ROWS|COST|
---------------------------------------------------
|0 |HASH GROUP BY|                 |100      |159 |
|1 | TABLE SCAN  |t_normal_idx(idx)|100      |54  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 666(end)  ************** 

***************   Case 667   ***************

SQL: select c3 from t_normal_idx where c2=1 group by c3; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |79  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |57  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 667(end)  ************** 

***************   Case 668   ***************

SQL: select c3 from t_normal_idx where c2 is null group by c3; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |79  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |57  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,MIN,MIN,MIN,MIN,MIN ; NULL,MAX,MAX,MAX,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 668(end)  ************** 

***************   Case 669   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null group by c4,c5; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |92  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |61  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c4], [t_normal_idx.c5]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 669(end)  ************** 

***************   Case 670   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 group by c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |94  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |63  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 670(end)  ************** 

***************   Case 671   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3 is null and c4 is null and c5 is null group by c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |85  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |63  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,NULL,NULL,NULL,MIN,MIN ; NULL,NULL,NULL,NULL,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c3, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)], [(T_OP_IS, t_normal_idx.c5, NULL, 0)])

*************** Case 671(end)  ************** 

***************   Case 672   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 group by c4; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |81  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |59  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c4]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,MIN,MIN,MIN,MIN ; NULL,1,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 672(end)  ************** 

***************   Case 673   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 and c4 is null group by c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |94  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |63  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,NULL,MIN,MIN,MIN ; NULL,1,NULL,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)])

*************** Case 673(end)  ************** 

***************   Case 674   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 group by c3,c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |94  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |63  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 674(end)  ************** 

***************   Case 675   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 group by c2,c3,c4,c5,c6     ; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |100      |94  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |63  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 675(end)  ************** 

***************   Case 676   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 and c6 is null group by      c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |0        |80  |
|1 | TABLE SCAN   |t_normal_idx(idx)|0        |80  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5]), filter([(T_OP_IS, t_normal_idx.c6, NULL, 0)]), 
      access([t_normal_idx.c3], [t_normal_idx.c6], [t_normal_idx.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 676(end)  ************** 

***************   Case 677   ***************

SQL: select c3 from t_normal_idx where c2=1 and c4 is null and c5=1 group by c3,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |0        |97  |
|1 | TABLE SCAN   |t_normal_idx(idx)|0        |97  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c6]), filter([(T_OP_IS, t_normal_idx.c4, NULL, 0)], [t_normal_idx.c5 = ?]), 
      access([t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c3], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 677(end)  ************** 

***************   Case 678   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c5=1 group by c4,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |1        |80  |
|1 | TABLE SCAN   |t_normal_idx(idx)|1        |80  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c4], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c6]), filter([t_normal_idx.c5 = ?]), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c4], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 678(end)  ************** 

***************   Case 679   ***************

SQL: select c3 from t_normal_idx where c2 is not null group by c3; 

===================================================
|ID|OPERATOR     |NAME             |EST. ROWS|COST|
---------------------------------------------------
|0 |HASH GROUP BY|                 |100      |178 |
|1 | TABLE SCAN  |t_normal_idx(idx)|100      |73  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter([(T_OP_IS_NOT, t_normal_idx.c2, NULL, 0)]), 
      access([t_normal_idx.c2], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 679(end)  ************** 

***************   Case 680   ***************

SQL: select c1 from t7 where c1=(select t7.c1 as c from t7 t having c1>(select c from t7)); 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |1        |19672|
|1 | TABLE SCAN    |t7  |100      |88   |
|2 | SUBPLAN FILTER|    |50       |189  |
|3 |  TABLE SCAN   |t   |100      |88   |
|4 |  TABLE SCAN   |t7  |100      |88   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c1 = subquery(1)]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter([?]), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true
  4 - output([?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 680(end)  ************** 

***************   Case 681   ***************

SQL: select c1+1 as c from t7 group by (select c from t7 t); 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |HASH GROUP BY  |    |1        |10266|
|1 | SUBPLAN FILTER|    |100      |10232|
|2 |  TABLE SCAN   |t7  |100      |88   |
|3 |  TABLE SCAN   |t   |100      |88   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1 + ?]), filter(nil), 
      group([subquery(1)]), agg_func(nil)
  1 - output([t7.c1 + ?], [subquery(1)]), filter(nil), 
      exec_params_([t7.c1 + ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 681(end)  ************** 

***************   Case 682   ***************

SQL: select count(c1) + 1 from t7 having (select count(t7.c1) from t7 t)>0; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |209 |
|1 | SCALAR GROUP BY|    |1        |107 |
|2 |  TABLE SCAN    |t7  |100      |88  |
|3 | TABLE SCAN     |t   |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t7.c1) + ?]), filter([subquery(1) > ?]), 
      exec_params_([T_FUN_COUNT(t7.c1)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 682(end)  ************** 

***************   Case 683   ***************

SQL: select count(c1) + 1 as c from t7 having (select c from t7 t)>0; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |209 |
|1 | SCALAR GROUP BY|    |1        |107 |
|2 |  TABLE SCAN    |t7  |100      |88  |
|3 | TABLE SCAN     |t   |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t7.c1) + ?]), filter([subquery(1) > ?]), 
      exec_params_([T_FUN_COUNT(t7.c1) + ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 683(end)  ************** 

***************   Case 684   ***************

SQL: select (select c1 from t7 t) as c from t7 group by (select c from t7 tt); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |HASH GROUP BY   |    |1        |2339|
|1 | SUBPLAN FILTER |    |100      |2306|
|2 |  SUBPLAN FILTER|    |100      |189 |
|3 |   TABLE SCAN   |t7  |100      |88  |
|4 |   TABLE SCAN   |t   |100      |88  |
|5 |  TABLE SCAN    |tt  |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      group([subquery(1)]), agg_func(nil)
  1 - output([?], [subquery(1)]), filter(nil), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true
  5 - output([?]), filter(nil), 
      access([tt.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true

*************** Case 684(end)  ************** 

***************   Case 685   ***************

SQL: select 1 as c, c1 from t7 having c1>(select c from t7 t); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |134 |
|1 | TABLE SCAN   |t7  |34       |42  |
|2 | TABLE SCAN   |t   |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  2 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 685(end)  ************** 

***************   Case 686   ***************

SQL: SELECT c7 FROM query_range1 t8_1 WHERE ( ( t8_1.c7 in ((450) , (2001)) ) ) OR ( ( t8_1.c7 < 220 ) ); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t8_1|100      |110 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t8_1.c7]), filter([t8_1.c7 IN (?, ?) OR t8_1.c7 < ?]), 
      access([t8_1.c7]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8_1.c9], [t8_1.c11], [t8_1.c8], [t8_1.c1], [t8_1.c12], [t8_1.c7], [t8_1.c5]), range(MIN,MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 686(end)  ************** 

***************   Case 687   ***************

SQL: select (1>(select count(*) from t2 where c1=1)) from t1 where c1=1; 

======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE          |     |1        |105 |
|1 | EXCHANGE OUT REMOTE        |     |1        |105 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |1        |105 |
|3 |   TABLE GET                |t1   |1        |52  |
|4 |   SUBPLAN SCAN             |VIEW1|1        |53  |
|5 |    SCALAR GROUP BY         |     |1        |53  |
|6 |     TABLE GET              |t2   |1        |52  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([? > VIEW1.count(*)]), filter(nil)
  1 - output([? > VIEW1.count(*)]), filter(nil)
  2 - output([? > VIEW1.count(*)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([VIEW1.count(*)]), filter(nil), 
      access([VIEW1.count(*)])
  5 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  6 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])

*************** Case 687(end)  ************** 

***************   Case 688   ***************

SQL: select c1 from t1 group by c1, 'a' asc; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |990 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |966 |
|2 |  SORT                    |        |500      |966 |
|3 |   PX PARTITION ITERATOR  |        |500      |331 |
|4 |    TABLE SCAN            |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 688(end)  ************** 

***************   Case 689   ***************

SQL: select c1 from t1 order by c1, 'a' asc; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |990 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |966 |
|2 |  SORT                    |        |500      |966 |
|3 |   PX PARTITION ITERATOR  |        |500      |331 |
|4 |    TABLE SCAN            |t1      |500      |331 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 689(end)  ************** 

***************   Case 690   ***************

SQL: select c1, exists(select c1 from t7) from t7 group by 2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE GROUP BY |    |1        |203 |
|1 | SUBPLAN FILTER|    |100      |189 |
|2 |  TABLE SCAN   |t7  |100      |88  |
|3 |  TABLE SCAN   |t7  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [?]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 690(end)  ************** 

***************   Case 691   ***************

SQL: select * from t1 where c1 is false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |426 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |426 |
|2 |  PX PARTITION ITERATOR|        |1        |426 |
|3 |   TABLE SCAN          |t1      |1        |426 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c1, 0, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 691(end)  ************** 

***************   Case 692   ***************

SQL: select * from t1 where (c1 + 1) is false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |250      |449 |
|1 | EXCHANGE OUT DISTR    |:EX10000|250      |426 |
|2 |  PX PARTITION ITERATOR|        |250      |426 |
|3 |   TABLE SCAN          |t1      |250      |426 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c1 + ?, 0, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 692(end)  ************** 

***************   Case 693   ***************

SQL: select * from t1 where c1 is null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 693(end)  ************** 

***************   Case 694   ***************

SQL: select * from t1 where c2 is null; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |500      |342 |
|2 |  PX PARTITION ITERATOR|             |500      |342 |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|500      |342 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(NULL,MIN ; NULL,MAX), 
      range_cond([(T_OP_IS, t1.c2, NULL, 0)])

*************** Case 694(end)  ************** 

***************   Case 695   ***************

SQL: select * from t1 where c2 is not null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |490      |472 |
|1 | EXCHANGE OUT DISTR    |:EX10000|490      |426 |
|2 |  PX PARTITION ITERATOR|        |490      |426 |
|3 |   TABLE SCAN          |t1      |490      |426 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 695(end)  ************** 

***************   Case 696   ***************

SQL: select * from t1 where c1 is not null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 696(end)  ************** 

***************   Case 697   ***************

SQL: select * from t1 where (c1 + 1) is null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |250      |449 |
|1 | EXCHANGE OUT DISTR    |:EX10000|250      |426 |
|2 |  PX PARTITION ITERATOR|        |250      |426 |
|3 |   TABLE SCAN          |t1      |250      |426 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c1 + ?, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 697(end)  ************** 

***************   Case 698   ***************

SQL: select /*+ index(y_t1 i1)*/* from y_t1 where c2=10 order by c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|y_t1|1        |109 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([y_t1.c2 = ?]), 
      access([y_t1.c2], [y_t1.c1], [y_t1.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t1.c1]), range(MIN ; MAX)always true

*************** Case 698(end)  ************** 

***************   Case 699   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2=10 order by c1; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |1        |122 |
|1 | TABLE SCAN|y_t1(y_t1_i1)|1        |121 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), sort_keys([y_t1.c1, ASC])
  1 - output([y_t1.c2], [y_t1.c1], [y_t1.c3]), filter([y_t1.c2 = ?]), 
      access([y_t1.c2], [y_t1.c1], [y_t1.c3]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c2], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 699(end)  ************** 

***************   Case 700   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2='10' order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i1)|100      |612 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), 
      access([y_t1.c2], [y_t1.c1], [y_t1.c3]), partitions(p0), 
      is_index_back=true, 
      range_key([y_t1.c2], [y_t1.c1]), range(10,MIN ; 10,MAX), 
      range_cond([y_t1.c2 = ?])

*************** Case 700(end)  ************** 

***************   Case 701   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2=c1 order by c1; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |1        |119 |
|1 | TABLE SCAN|y_t1(y_t1_i1)|1        |118 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), sort_keys([y_t1.c1, ASC])
  1 - output([y_t1.c2], [y_t1.c1], [y_t1.c3]), filter([y_t1.c2 = y_t1.c1]), 
      access([y_t1.c2], [y_t1.c1], [y_t1.c3]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c2], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 701(end)  ************** 

***************   Case 702   ***************

SQL: select * from y_t1 where c2=c1 order by c1, c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|y_t1|1        |109 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([y_t1.c2 = y_t1.c1]), 
      access([y_t1.c2], [y_t1.c1], [y_t1.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t1.c1]), range(MIN ; MAX)always true

*************** Case 702(end)  ************** 

***************   Case 703   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2=c1 order by c1, c2; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |1        |119 |
|1 | TABLE SCAN|y_t1(y_t1_i1)|1        |118 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), sort_keys([y_t1.c1, ASC])
  1 - output([y_t1.c2], [y_t1.c1], [y_t1.c3]), filter([y_t1.c2 = y_t1.c1]), 
      access([y_t1.c2], [y_t1.c1], [y_t1.c3]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c2], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 703(end)  ************** 

***************   Case 704   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3=c1 order by c1, c3; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|1        |118 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([y_t1.c3 = y_t1.c1]), 
      access([y_t1.c3], [y_t1.c1], [y_t1.c2]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c3], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 704(end)  ************** 

***************   Case 705   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3=10 order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|100      |612 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), 
      access([y_t1.c3], [y_t1.c1], [y_t1.c2]), partitions(p0), 
      is_index_back=true, 
      range_key([y_t1.c3], [y_t1.c1]), range(10,MIN ; 10,MAX), 
      range_cond([y_t1.c3 = ?])

*************** Case 705(end)  ************** 

***************   Case 706   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3='10' order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|100      |612 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), 
      access([y_t1.c3], [y_t1.c1], [y_t1.c2]), partitions(p0), 
      is_index_back=true, 
      range_key([y_t1.c3], [y_t1.c1]), range(10,MIN ; 10,MAX), 
      range_cond([y_t1.c3 = ?])

*************** Case 706(end)  ************** 

***************   Case 707   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3=c1 order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|1        |118 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([y_t1.c3 = y_t1.c1]), 
      access([y_t1.c3], [y_t1.c1], [y_t1.c2]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c3], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 707(end)  ************** 

***************   Case 708   ***************

SQL: select a from y_t3 where a = 'A' collate utf8mb4_general_ci order by a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |1        |142 |
|1 | TABLE SCAN|y_t3|1        |141 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t3.a]), filter(nil), sort_keys([y_t3.a, ASC])
  1 - output([y_t3.a]), filter([y_t3.a = ?]), 
      access([y_t3.a]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t3.__pk_increment], [y_t3.__pk_cluster_id], [y_t3.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 708(end)  ************** 

***************   Case 709   ***************

SQL: select * from hint.t1 group by b having (select b from hint.t2 limit 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |50       |192 |
|1 | SUBPLAN FILTER|    |50       |140 |
|2 |  TABLE SCAN   |t1  |100      |90  |
|3 |  TABLE SCAN   |t2  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      group([t1.b]), agg_func(nil)
  1 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  3 - output([t2.b]), filter(nil), 
      access([t2.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.a]), range(MIN ; MAX)always true

*************** Case 709(end)  ************** 

***************   Case 710   ***************

SQL: select * from hint.t1 group by b having (select b from hint.t2 limit 1) = 1; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |50       |192 |
|1 | SUBPLAN FILTER|    |50       |140 |
|2 |  TABLE SCAN   |t1  |100      |90  |
|3 |  TABLE SCAN   |t2  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      group([t1.b]), agg_func(nil)
  1 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([subquery(1) = ?]), init_plan_idxs_(nil)
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  3 - output([t2.b]), filter(nil), 
      access([t2.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.a]), range(MIN ; MAX)always true

*************** Case 710(end)  ************** 

***************   Case 711   ***************

SQL: select * from hint.t1 group by b having (select b from hint.t2 limit 1) = 1 or sum(b) = 1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |5        |250 |
|1 | HASH GROUP BY|    |100      |200 |
|2 |  TABLE SCAN  |t1  |100      |90  |
|3 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([? OR T_FUN_SUM(t1.b) = ?]), 
      exec_params_(nil), onetime_exprs_([subquery(1) = ?]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b], [T_FUN_SUM(t1.b)]), filter(nil), 
      group([t1.b]), agg_func([T_FUN_SUM(t1.b)])
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  3 - output([t2.b]), filter(nil), 
      access([t2.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.a]), range(MIN ; MAX)always true

*************** Case 711(end)  ************** 

***************   Case 712   ***************

SQL: select c1 from t0 where pk is null; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t0  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.c1]), filter(nil), startup_filter([0]), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 712(end)  ************** 

***************   Case 713   ***************

SQL: select c1 from t0 where pk <=> null; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t0  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.c1]), filter(nil), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range[NULL ; NULL], 
      range_cond([t0.pk <=> ?])

*************** Case 713(end)  ************** 

***************   Case 714   ***************

SQL: select c1 from t4 where c1 <=> null and c2 <=> null; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[NULL,NULL ; NULL,NULL], 
      range_cond([t4.c1 <=> ?], [t4.c2 <=> ?])

*************** Case 714(end)  ************** 

***************   Case 715   ***************

SQL: select c1 from t4 where c1 <=> 1 and c2 <=> 1; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[1,1 ; 1,1], 
      range_cond([t4.c1 <=> ?], [t4.c2 <=> ?])

*************** Case 715(end)  ************** 

***************   Case 716   ***************

SQL: select c1 from t4 where c1 is null and c2 <=> null; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |54  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), startup_filter([0]), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 716(end)  ************** 

***************   Case 717   ***************

SQL: select c1 from (select c1, c2 from t1 limit 1) ta group by ta.c1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |LIMIT                   |        |1        |37  |
|1 | PX COORDINATOR         |        |1        |36  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|1        |36  |
|3 |   PX PARTITION ITERATOR|        |1        |36  |
|4 |    TABLE SCAN          |t1      |1        |36  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 717(end)  ************** 

***************   Case 718   ***************

SQL: select * from (select count(c1) from t1) ta; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |522 |
|1 | PX COORDINATOR          |        |1        |426 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |426 |
|3 |   MERGE GROUP BY        |        |1        |426 |
|4 |    PX PARTITION ITERATOR|        |500      |331 |
|5 |     TABLE SCAN          |t1      |500      |331 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 718(end)  ************** 

***************   Case 719   ***************

SQL: select c1 from (select c1, c2 from (select * from t4 limit 10)ta limit 5) ta1 group by ta1.c1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |5        |39  |
|1 | SUBPLAN SCAN |ta1 |5        |38  |
|2 |  TABLE SCAN  |t4  |5        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([ta1.c1]), filter(nil), 
      group([ta1.c1]), agg_func(nil)
  1 - output([ta1.c1]), filter(nil), 
      access([ta1.c1])
  2 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(?), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 719(end)  ************** 

***************   Case 720   ***************

SQL: select tb.a from (select a, b from (select * from t12 limit 10)ta limit 5) ta1 join (select a, b from t13 limit 10) tb on ta1.a = tb.a; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |MERGE JOIN   |    |5        |81  |
|1 | SUBPLAN SCAN|ta1 |5        |38  |
|2 |  TABLE SCAN |t12 |5        |37  |
|3 | SUBPLAN SCAN|tb  |10       |39  |
|4 |  TABLE SCAN |t13 |10       |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([tb.a]), filter(nil), 
      equal_conds([ta1.a = tb.a]), other_conds(nil)
  1 - output([ta1.a]), filter(nil), 
      access([ta1.a])
  2 - output([t12.a]), filter(nil), 
      access([t12.a]), partitions(p0), 
      limit(?), offset(nil), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  3 - output([tb.a]), filter(nil), 
      access([tb.a])
  4 - output([t13.a]), filter(nil), 
      access([t13.a]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 720(end)  ************** 

***************   Case 721   ***************

SQL: select t13.a from (select * from t12) ta, t13; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7270|
|1 | TABLE SCAN               |t13 |100      |88  |
|2 | MATERIAL                 |    |100      |106 |
|3 |  TABLE SCAN              |t12 |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t13.a]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t13.a]), filter(nil), 
      access([t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access([t12.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 721(end)  ************** 

***************   Case 722   ***************

SQL: select ta.a from (select * from t12) ta where ta.a > (select t13.a from t13 where t13.b < ta.b limit 1) ; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |3888|
|1 | TABLE SCAN   |t12 |100      |90  |
|2 | TABLE SCAN   |t13 |1        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.a]), filter([t12.a > subquery(1)]), 
      exec_params_([t12.b]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t12.a], [t12.b]), filter(nil), 
      access([t12.a], [t12.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  2 - output([t13.a]), filter([t13.b < ?]), 
      access([t13.b], [t13.a]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 722(end)  ************** 

***************   Case 723   ***************

SQL: select (select min(c1) from agg_t2) from agg_t1; 

===========================================
|ID|OPERATOR        |NAME  |EST. ROWS|COST|
-------------------------------------------
|0 |SUBPLAN FILTER  |      |1        |209 |
|1 | SCALAR GROUP BY|      |1        |107 |
|2 |  TABLE SCAN    |agg_t1|100      |88  |
|3 | TABLE SCAN     |agg_t2|100      |88  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([subquery(1)]), filter(nil), 
      exec_params_([T_FUN_MIN(agg_t1.c1)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_MIN(agg_t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(agg_t1.c1)])
  2 - output([agg_t1.c1]), filter(nil), 
      access([agg_t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([agg_t1.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([agg_t2.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([agg_t2.c2]), range(MIN ; MAX)always true

*************** Case 723(end)  ************** 

***************   Case 724   ***************

SQL: select * from (select c1 from t1 order by c1) ta limit 1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |1        |37  |
|1 | PX COORDINATOR MERGE SORT |        |1        |37  |
|2 |  EXCHANGE OUT DISTR       |:EX10000|1        |37  |
|3 |   SORT                    |        |1        |37  |
|4 |    PX PARTITION ITERATOR  |        |1        |36  |
|5 |     TABLE SCAN            |t1      |1        |36  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 724(end)  ************** 

***************   Case 725   ***************

SQL: select * from t4,t7 order by t4.c3; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|             |10000    |7400|
|1 | TABLE SCAN               |t4(idx_t4_c3)|100      |92  |
|2 | MATERIAL                 |             |100      |127 |
|3 |  TABLE SCAN              |t7           |100      |90  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([t7.c1], [t7.c2]), filter(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 725(end)  ************** 

***************   Case 726   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg1, tg1 tg2 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 and tg2.c2=2 and tg2.c3=2; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |131 |
|1 | TABLE SCAN     |tg1 |1        |130 |
|2 | TABLE GET      |tg2 |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      conds(nil), nl_params_([tg1.c1]), batch_join=true
  1 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter([tg1.c2 = ?], [tg1.c3 = ?]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN ; MAX), 
      range_cond([tg2.c2 = ?], [tg2.c3 = ?], [? = tg2.c1])

*************** Case 726(end)  ************** 

***************   Case 727   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg1, tg1 tg2 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 and tg2.c2=2 and tg2.c3=2 and tg1.c2 = tg2.c2; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |147 |
|1 | TABLE SCAN     |tg1 |1        |147 |
|2 | TABLE GET      |tg2 |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      conds(nil), nl_params_([tg1.c1]), batch_join=true
  1 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter([tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MAX,MAX,MAX ; MIN,MIN,MIN)always false
  2 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN ; MAX), 
      range_cond([tg2.c2 = ?], [tg2.c3 = ?], [tg2.c2 = ?], [? = tg2.c1])

*************** Case 727(end)  ************** 

***************   Case 728   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg1, tg1 tg2 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3 = 1 and tg2.c2=1 and tg2.c3=1 or tg2.c1=2 and tg2.c2=2 and tg2.c3 = 4 and tg1.c1 = 1 and tg1.c2 = 2 and tg1.c3 = 4; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |210 |
|1 | TABLE SCAN     |tg1 |1        |105 |
|2 | MATERIAL       |    |1        |105 |
|3 |  TABLE SCAN    |tg2 |1        |105 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      conds([(T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?, tg2.c2 = ?, tg2.c3 = ?) OR (T_OP_AND, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?, tg1.c1 = ?, tg1.c2 = ?, tg1.c3 = ?)]), nl_params_(nil), batch_join=false
  1 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?]), filter([tg1.c2 = ? AND tg1.c3 = ? OR (T_OP_AND, tg1.c1 = ?, tg1.c2 = ?, tg1.c3 = ?)]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg2.c2 = ?], [tg2.c3 = ?], [tg2.c1 = ?], [tg2.c2 = ?], [tg2.c3 = ?]), filter(nil)
  3 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg2.c2 = ?], [tg2.c3 = ?], [tg2.c1 = ?], [tg2.c2 = ?], [tg2.c3 = ?]), filter([tg2.c2 = ? AND tg2.c3 = ? OR (T_OP_AND, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?)]), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 728(end)  ************** 

***************   Case 729   ***************

SQL: select /*+use_nl(tg2 tg1)*/* from tg2,tg1 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 or tg1.c2=2 and tg1.c3=2 and tg1.c1 = 2 and tg2.c1 = 3 and tg2.c2 =  3 and tg2.c3 = 3; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |202 |
|1 | TABLE SCAN     |tg2 |100      |97  |
|2 | MATERIAL       |    |1        |105 |
|3 |  TABLE SCAN    |tg1 |1        |105 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter(nil), 
      conds([(T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?) OR (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?)]), nl_params_(nil), batch_join=false
  1 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter(nil)
  3 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter([tg1.c2 = ? AND tg1.c3 = ? OR (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?)]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 729(end)  ************** 

***************   Case 730   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg2,tg1 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 or tg1.c2=2 and tg1.c3=2 and tg1.c1 = 2 and tg2.c1 = 3 and tg2.c2 =  3 and tg2.c3 = 3 or tg1.c2=3 and tg1.c3=3 and tg1.c1 = 3 and tg2.c1 = 4 and tg2.c2 =  4 and tg2.c3 = 4; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |202 |
|1 | TABLE SCAN     |tg2 |100      |97  |
|2 | MATERIAL       |    |1        |105 |
|3 |  TABLE SCAN    |tg1 |1        |105 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter(nil), 
      conds([(T_OP_OR, (T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?))]), nl_params_(nil), batch_join=false
  1 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter(nil)
  3 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter([(T_OP_OR, tg1.c2 = ? AND tg1.c3 = ?, (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?))]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 730(end)  ************** 

***************   Case 731   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg2,tg1 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 or tg1.c2=2 and tg1.c3=2 and tg1.c1 = 2 and tg2.c1 = 3 and tg2.c2 =  3 and tg2.c3 = 3 or tg1.c2=3 and tg1.c3=3 and tg1.c1 = 3 and tg2.c1 = 4 and tg2.c2 =  4 and tg2.c3 = 4; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |202 |
|1 | TABLE SCAN     |tg2 |100      |97  |
|2 | MATERIAL       |    |1        |105 |
|3 |  TABLE SCAN    |tg1 |1        |105 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter(nil), 
      conds([(T_OP_OR, (T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?))]), nl_params_(nil), batch_join=false
  1 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter(nil)
  3 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter([(T_OP_OR, tg1.c2 = ? AND tg1.c3 = ?, (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?))]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 731(end)  ************** 

***************   Case 732   ***************

SQL: select /*+ use_nl(t1, t2) */ t2.c2, t2.c3 from (select * from y_t4 t where t.c1=100 order by t.c2 DESC, t.c3 DESC limit 1) t1 join y_t4 t2 on t1.c2=t2.c2 and t1.c3=t2.c3 order by t2.c2 DESC, t2.c3 DESC; 

================================================
|ID|OPERATOR         |NAME      |EST. ROWS|COST|
------------------------------------------------
|0 |SORT             |          |1        |168 |
|1 | NESTED-LOOP JOIN|          |1        |166 |
|2 |  TABLE SCAN     |t2        |100      |92  |
|3 |  MATERIAL       |          |1        |37  |
|4 |   SUBPLAN SCAN  |t1        |1        |37  |
|5 |    TABLE SCAN   |t(Reverse)|1        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, DESC], [t2.c3, DESC])
  1 - output([t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c2 = t2.c2], [t1.c3 = t2.c3]), nl_params_(nil), batch_join=false
  2 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  3 - output([t1.c2], [t1.c3]), filter(nil)
  4 - output([t1.c2], [t1.c3]), filter(nil), 
      access([t1.c2], [t1.c3])
  5 - output([t.c2], [t.c3]), filter(nil), 
      access([t.c2], [t.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t.c1], [t.c2], [t.c3]), range(100,MIN,MIN ; 100,MAX,MAX), 
      range_cond([t.c1 = ?])

*************** Case 732(end)  ************** 

***************   Case 733   ***************

SQL: select count(1) from (select * from t1 order by c2 limit 10) t; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |SCALAR GROUP BY              |             |1        |54  |
|1 | SUBPLAN SCAN                |t            |10       |52  |
|2 |  LIMIT                      |             |10       |50  |
|3 |   PX COORDINATOR MERGE SORT |             |10       |49  |
|4 |    EXCHANGE OUT DISTR       |:EX10000     |10       |48  |
|5 |     SORT                    |             |10       |48  |
|6 |      PX PARTITION ITERATOR  |             |10       |38  |
|7 |       TABLE SCAN            |t1(idx_t1_c2)|10       |38  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  1 - output([1]), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(10), offset(nil)
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  4 - output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  6 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 733(end)  ************** 

***************   Case 734   ***************

SQL: select count(1) from (select c1, c2, (select c3 from t2) as ca from t1 order by ca limit 10) t; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |SCALAR GROUP BY            |        |1        |313 |
|1 | SUBPLAN SCAN              |t       |10       |311 |
|2 |  LIMIT                    |        |10       |310 |
|3 |   SUBPLAN FILTER          |        |10       |308 |
|4 |    PX COORDINATOR         |        |10       |38  |
|5 |     EXCHANGE OUT DISTR    |:EX10000|10       |38  |
|6 |      PX PARTITION ITERATOR|        |10       |38  |
|7 |       TABLE SCAN          |t1      |10       |38  |
|8 |    PX COORDINATOR         |        |300      |269 |
|9 |     EXCHANGE OUT DISTR    |:EX20000|300      |198 |
|10|      PX PARTITION ITERATOR|        |300      |198 |
|11|       TABLE SCAN          |t2      |300      |198 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  1 - output([1]), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(10), offset(nil)
  3 - output([1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), dop=1
  6 - output([1]), filter(nil), 
      force partition granule, asc.
  7 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c3]), filter(nil)
  9 - output([t2.c3]), filter(nil), dop=1
  10 - output([t2.c3]), filter(nil), 
      force partition granule, asc.
  11 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 734(end)  ************** 

***************   Case 735   ***************

SQL: select distinct c3, c2 from t4; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE DISTINCT|                |100      |123 |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2], [t4.c3])
  1 - output([t4.c3], [t4.c2]), filter(nil), 
      access([t4.c3], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 735(end)  ************** 

***************   Case 736   ***************

SQL: select count(c2) from t4 group by c3, c2; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE GROUP BY|                |100      |128 |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t4.c2)]), filter(nil), 
      group([t4.c2], [t4.c3]), agg_func([T_FUN_COUNT(t4.c2)])
  1 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 736(end)  ************** 

***************   Case 737   ***************

SQL: select count(c2) from t4 group by c3, c1, c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |54  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, t4.c2, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 737(end)  ************** 

***************   Case 738   ***************

SQL: select count(c2) from y_t4 group by c2, c1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |100      |128 |
|1 | TABLE SCAN   |y_t4|100      |92  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(y_t4.c2)]), filter(nil), 
      group([y_t4.c1], [y_t4.c2]), agg_func([T_FUN_COUNT(y_t4.c2)])
  1 - output([y_t4.c2], [y_t4.c1]), filter(nil), 
      access([y_t4.c2], [y_t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([y_t4.c1], [y_t4.c2], [y_t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 738(end)  ************** 

***************   Case 739   ***************

SQL: select count(c4) from tg1 group by c4, c3, c5, c2, c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tg1 |100      |95  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, tg1.c4, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      access([tg1.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 739(end)  ************** 

***************   Case 740   ***************

SQL: select distinct c3, c2, c4, c5, c1 from tg1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tg1 |100      |97  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c3], [tg1.c2], [tg1.c4], [tg1.c5], [tg1.c1]), filter(nil), 
      access([tg1.c3], [tg1.c2], [tg1.c4], [tg1.c5], [tg1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 740(end)  ************** 

***************   Case 741   ***************

SQL: select distinct b from y_t5 where (a2 >= 'b') and (b = 'a'); 

=============================================
|ID|OPERATOR  |NAME          |EST. ROWS|COST|
---------------------------------------------
|0 |TABLE SCAN|y_t5(idx_t1_1)|1        |155 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t5.b]), filter([y_t5.a2 >= ?], [y_t5.b = ?]), 
      access([y_t5.a2], [y_t5.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([y_t5.a1], [y_t5.a2], [y_t5.b], [y_t5.c], [y_t5.__pk_increment], [y_t5.__pk_cluster_id], [y_t5.__pk_partition_id]), range(MIN,MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 741(end)  ************** 

***************   Case 742   ***************

SQL: select distinct c2 from y_t6 where c1=c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t6(y_t6_i1)|1        |63  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t6.c2]), filter([y_t6.c1 = y_t6.c2]), 
      access([y_t6.c1], [y_t6.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t6.c2], [y_t6.c3], [y_t6.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 742(end)  ************** 

***************   Case 743   ***************

SQL: select * from tt1 where c2 like "a%"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |100      |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, 'a%', '\\')]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 743(end)  ************** 

***************   Case 744   ***************

SQL: select * from tt1 where c2 like "%a"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |34       |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, '%a', '\\')]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 744(end)  ************** 

***************   Case 745   ***************

SQL: select * from tt1 where c2 like "ab%"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |5        |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, 'ab%', '\\')]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 745(end)  ************** 

***************   Case 746   ***************

SQL: select * from tt1 where c2 between "aa" and "ab"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |5        |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 746(end)  ************** 

***************   Case 747   ***************

SQL: select * from tt1 where c2 between "aa" and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |33       |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 747(end)  ************** 

***************   Case 748   ***************

SQL: select * from tt1 where c2 not between "aa" and "ab"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |100      |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 748(end)  ************** 

***************   Case 749   ***************

SQL: select * from tt1 where c2 not between "aa" and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |71       |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, tt1.c2, ?, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 749(end)  ************** 

***************   Case 750   ***************

SQL: select * from tt1 where "ag" between c2 and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |26       |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, ?, tt1.c2, ?)]), 
      access([tt1.c2], [tt1.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 750(end)  ************** 

***************   Case 751   ***************

SQL: select * from tt1 where "ag" between "aa" and "c2"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter(nil), startup_filter([1]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 751(end)  ************** 

***************   Case 752   ***************

SQL: select * from tt1 where 'ag' not between c1 and 'ai'; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |34       |137 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, ?, tt1.c1, ?)]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 752(end)  ************** 

***************   Case 753   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |124 |
|1 | LIMIT          |                  |1        |87  |
|2 |  TOP-N SORT    |                  |1        |87  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |54  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c2], [t_normal_idx.c3], [t_normal_idx_alias.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), limit(1), offset(nil)
  2 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      access([t_normal_idx_alias.c2], [t_normal_idx_alias.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 753(end)  ************** 

***************   Case 754   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx where c4>1 order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |150 |
|1 | LIMIT          |                  |1        |114 |
|2 |  TOP-N SORT    |                  |1        |113 |
|3 |   TABLE SCAN   |t_normal_idx(idx) |96       |73  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), limit(1), offset(nil)
  2 - output([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  3 - output([t_normal_idx.c4], [t_normal_idx.c1], [t_normal_idx.c3]), filter([t_normal_idx.c4 > ?]), 
      access([t_normal_idx.c4], [t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      access([t_normal_idx_alias.c2], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 754(end)  ************** 

***************   Case 755   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx order by c2 limit 1; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|1        |89  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=true, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 755(end)  ************** 

***************   Case 756   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx where c10>1 order by c3 limit 1; 

==================================================
|ID|OPERATOR    |NAME             |EST. ROWS|COST|
--------------------------------------------------
|0 |LIMIT       |                 |1        |795 |
|1 | TOP-N SORT |                 |1        |795 |
|2 |  TABLE SCAN|t_normal_idx(idx)|96       |693 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), limit(1), offset(nil)
  1 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  2 - output([t_normal_idx.c10], [t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), filter([t_normal_idx.c10 > ?]), 
      access([t_normal_idx.c10], [t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), partitions(p0), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 756(end)  ************** 

***************   Case 757   ***************

SQL: select /*+index(t_normal_idx idx)*/c2,c9,c10 from t_normal_idx order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |124 |
|1 | LIMIT          |                  |1        |87  |
|2 |  TOP-N SORT    |                  |1        |87  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |54  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(nil)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  3 - output([t_normal_idx.c3], [t_normal_idx.c1]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      access([t_normal_idx_alias.c2], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 757(end)  ************** 

***************   Case 758   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |124 |
|1 | LIMIT          |                  |1        |87  |
|2 |  TOP-N SORT    |                  |1        |87  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |54  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(nil)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 758(end)  ************** 

***************   Case 759   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c1 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |112 |
|1 | LIMIT          |                  |1        |75  |
|2 |  TOP-N SORT    |                  |1        |75  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |52  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(nil)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c1, ASC]), topn(1)
  3 - output([t_normal_idx.c1]), filter(nil), 
      access([t_normal_idx.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 759(end)  ************** 

***************   Case 760   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |156 |
|1 | LIMIT          |                  |1        |119 |
|2 |  TOP-N SORT    |                  |11       |118 |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |54  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 760(end)  ************** 

***************   Case 761   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |156 |
|1 | LIMIT          |                  |1        |119 |
|2 |  TOP-N SORT    |                  |11       |118 |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |54  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, DESC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 761(end)  ************** 

***************   Case 762   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc ,c4 desc limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |169 |
|1 | LIMIT          |                  |1        |132 |
|2 |  TOP-N SORT    |                  |11       |130 |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |57  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, DESC], [t_normal_idx.c4, DESC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 762(end)  ************** 

***************   Case 763   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc, c4 limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |169 |
|1 | LIMIT          |                  |1        |132 |
|2 |  TOP-N SORT    |                  |11       |130 |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |57  |
|4 | TABLE GET      |t_normal_idx_alias|1        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=true
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, DESC], [t_normal_idx.c4, ASC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 763(end)  ************** 

***************   Case 764   ***************

SQL: select /*+no_use_late_materialization index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc limit 1 offset 10; 

==================================================
|ID|OPERATOR    |NAME             |EST. ROWS|COST|
--------------------------------------------------
|0 |LIMIT       |                 |1        |687 |
|1 | TOP-N SORT |                 |11       |686 |
|2 |  TABLE SCAN|t_normal_idx(idx)|100      |612 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c9]), filter(nil), limit(1), offset(?)
  1 - output([t_normal_idx.c1], [t_normal_idx.c9]), filter(nil), sort_keys([t_normal_idx.c3, DESC]), topn(1 + ?)
  2 - output([t_normal_idx.c1], [t_normal_idx.c9], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c9], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=true, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 764(end)  ************** 

***************   Case 765   ***************

SQL: select /*+use_late_materialization index(t_normal_idx idx)*/* from t_normal_idx where c10>1 order by c3 limit 1; 

==================================================
|ID|OPERATOR    |NAME             |EST. ROWS|COST|
--------------------------------------------------
|0 |LIMIT       |                 |1        |795 |
|1 | TOP-N SORT |                 |1        |795 |
|2 |  TABLE SCAN|t_normal_idx(idx)|96       |693 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), limit(1), offset(nil)
  1 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  2 - output([t_normal_idx.c10], [t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), filter([t_normal_idx.c10 > ?]), 
      access([t_normal_idx.c10], [t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), partitions(p0), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 765(end)  ************** 

***************   Case 766   ***************

SQL: select * from t7, t8 where t7.c1 = t8.c1 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |73  |
|1 | NESTED-LOOP JOIN|    |1        |73  |
|2 |  TABLE SCAN     |t7  |1        |36  |
|3 |  TABLE GET      |t8  |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 766(end)  ************** 

***************   Case 767   ***************

SQL: select * from t7, t8 where t7.c1 = t8.c2 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |73  |
|1 | NESTED-LOOP JOIN|    |1        |73  |
|2 |  TABLE SCAN     |t8  |1        |36  |
|3 |  TABLE GET      |t7  |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_([t8.c2]), batch_join=true
  2 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 767(end)  ************** 

***************   Case 768   ***************

SQL: select * from t7, t8 where t7.c2 = t8.c2 limit 1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |1        |255 |
|1 | HASH JOIN  |    |1        |255 |
|2 |  TABLE SCAN|t7  |100      |90  |
|3 |  TABLE SCAN|t8  |1        |36  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c2 = t8.c2]), other_conds(nil)
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 768(end)  ************** 

***************   Case 769   ***************

SQL: select * from t7 where c1=c2 and c2='1'; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t7  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])

*************** Case 769(end)  ************** 

***************   Case 770   ***************

SQL: select * from y_t7 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|y_t7|1        |124 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t7.c1], [y_t7.c2], [y_t7.c3]), filter([y_t7.c1 = y_t7.c2], [y_t7.c1 = ?]), 
      access([y_t7.c1], [y_t7.c2], [y_t7.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([y_t7.__pk_increment], [y_t7.__pk_cluster_id], [y_t7.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 770(end)  ************** 

***************   Case 771   ***************

SQL: select * from t1 order by c1,(select c1 from t2); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SORT                     |        |500      |1396|
|1 | SUBPLAN FILTER          |        |500      |663 |
|2 |  PX COORDINATOR         |        |500      |389 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|4 |    PX PARTITION ITERATOR|        |500      |342 |
|5 |     TABLE SCAN          |t1      |500      |342 |
|6 |  PX COORDINATOR         |        |300      |206 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300      |192 |
|8 |    PX PARTITION ITERATOR|        |300      |192 |
|9 |     TABLE SCAN          |t2      |300      |192 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 771(end)  ************** 

***************   Case 772   ***************

SQL: select * from (select * from t1 order by c1)v; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |1122|
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |1074|
|2 |  SORT                    |        |500      |1074|
|3 |   PX PARTITION ITERATOR  |        |500      |342 |
|4 |    TABLE SCAN            |t1      |500      |342 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 772(end)  ************** 

***************   Case 773   ***************

SQL: select * from (select * from t1 order by c1)v,t2; 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |108575|
|1 | PX COORDINATOR           |        |300      |290   |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |205   |
|3 |   PX PARTITION ITERATOR  |        |300      |205   |
|4 |    TABLE SCAN            |t2      |300      |205   |
|5 | MATERIAL                 |        |500      |573   |
|6 |  PX COORDINATOR          |        |500      |389   |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |342   |
|8 |    PX PARTITION ITERATOR |        |500      |342   |
|9 |     TABLE SCAN           |t1      |500      |342   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 773(end)  ************** 

***************   Case 774   ***************

SQL: select * from (select * from t1 order by c1)v,(select * from t2 order by c1)vv; 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |108575|
|1 | PX COORDINATOR           |        |300      |290   |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |205   |
|3 |   PX PARTITION ITERATOR  |        |300      |205   |
|4 |    TABLE SCAN            |t2      |300      |205   |
|5 | MATERIAL                 |        |500      |573   |
|6 |  PX COORDINATOR          |        |500      |389   |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |342   |
|8 |    PX PARTITION ITERATOR |        |500      |342   |
|9 |     TABLE SCAN           |t1      |500      |342   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 774(end)  ************** 

***************   Case 775   ***************

SQL: select * from t1 order by c1,(select c1 from t2 order by c1,(select c1 from t3 order by c1)); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SORT                      |        |500      |1586|
|1 | SUBPLAN FILTER           |        |500      |853 |
|2 |  PX COORDINATOR          |        |500      |389 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|500      |342 |
|4 |    PX PARTITION ITERATOR |        |500      |342 |
|5 |     TABLE SCAN           |t1      |500      |342 |
|6 |  SUBPLAN FILTER          |        |300      |396 |
|7 |   PX COORDINATOR         |        |300      |206 |
|8 |    EXCHANGE OUT DISTR    |:EX20000|300      |192 |
|9 |     PX PARTITION ITERATOR|        |300      |192 |
|10|      TABLE SCAN          |t2      |300      |192 |
|11|   PX COORDINATOR         |        |200      |149 |
|12|    EXCHANGE OUT DISTR    |:EX30000|200      |140 |
|13|     PX PARTITION ITERATOR|        |200      |140 |
|14|      TABLE SCAN          |t3      |200      |140 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t3.c1]), filter(nil)
  12 - output([t3.c1]), filter(nil), dop=1
  13 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  14 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 775(end)  ************** 

***************   Case 776   ***************

SQL: (select c1 from t1) intersect (select c1 from t2); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1380|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1366|
|2 |  MERGE INTERSECT DISTINCT     |        |300      |1366|
|3 |   SORT                        |        |500      |966 |
|4 |    PX PARTITION ITERATOR      |        |500      |331 |
|5 |     TABLE SCAN                |t1      |500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil)
  1 - output([INTERSECT([1])]), filter(nil), dop=1
  2 - output([INTERSECT([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 776(end)  ************** 

***************   Case 777   ***************

SQL: (select c1 from t1 order by c1) intersect (select c1 from t2 order by c1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1380|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1366|
|2 |  MERGE INTERSECT DISTINCT     |        |300      |1366|
|3 |   SORT                        |        |500      |966 |
|4 |    PX PARTITION ITERATOR      |        |500      |331 |
|5 |     TABLE SCAN                |t1      |500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil)
  1 - output([INTERSECT([1])]), filter(nil), dop=1
  2 - output([INTERSECT([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 777(end)  ************** 

***************   Case 778   ***************

SQL: (select c1 from t1 order by c2,(select c1 from t3 order by c1)) intersect (select c1 from t2 order by c2,(select c1 from t3 order by c1)); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1380|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1366|
|2 |  MERGE INTERSECT DISTINCT     |        |300      |1366|
|3 |   SORT                        |        |500      |966 |
|4 |    PX PARTITION ITERATOR      |        |500      |331 |
|5 |     TABLE SCAN                |t1      |500      |331 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |300      |206 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|300      |192 |
|8 |     PX PARTITION ITERATOR     |        |300      |192 |
|9 |      TABLE SCAN               |t2      |300      |192 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil)
  1 - output([INTERSECT([1])]), filter(nil), dop=1
  2 - output([INTERSECT([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 778(end)  ************** 

***************   Case 779   ***************

SQL: select * from t1 order by c1,(select c1 from t2 where t1.c1=t2.c1 order by c1,(select c1 from t3 where t1.c1=t3.c1)); 

========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST |
--------------------------------------------------------
|0 |SORT                      |        |500      |36907|
|1 | SUBPLAN FILTER           |        |500      |36549|
|2 |  PX COORDINATOR          |        |500      |389  |
|3 |   EXCHANGE OUT DISTR     |:EX10000|500      |342  |
|4 |    PX PARTITION ITERATOR |        |500      |342  |
|5 |     TABLE SCAN           |t1      |500      |342  |
|6 |  SUBPLAN FILTER          |        |1        |73   |
|7 |   PX COORDINATOR         |        |1        |36   |
|8 |    EXCHANGE OUT DISTR    |:EX20000|1        |36   |
|9 |     PX PARTITION ITERATOR|        |1        |36   |
|10|      TABLE GET           |t2      |1        |36   |
|11|   PX COORDINATOR         |        |1        |36   |
|12|    EXCHANGE OUT DISTR    |:EX30000|1        |36   |
|13|     PX PARTITION ITERATOR|        |1        |36   |
|14|      TABLE GET           |t3      |1        |36   |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [subquery(1), ASC])
  1 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t2.c1])
  11 - output([t3.c1]), filter(nil)
  12 - output([t3.c1]), filter(nil), dop=1
  13 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  14 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t3.c1])

*************** Case 779(end)  ************** 

***************   Case 780   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1 in (select c3 from t1 where c1=5 AND c2>=t22.c1); 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |HASH JOIN                        |        |97       |1059|
|1 | PX COORDINATOR                  |        |100      |240 |
|2 |  EXCHANGE OUT DISTR             |:EX10001|100      |207 |
|3 |   NESTED-LOOP JOIN              |        |100      |207 |
|4 |    EXCHANGE IN DISTR            |        |1        |53  |
|5 |     EXCHANGE OUT DISTR (BC2HOST)|:EX10000|1        |52  |
|6 |      TABLE GET                  |t1      |1        |52  |
|7 |    PX PARTITION ITERATOR        |        |100      |90  |
|8 |     TABLE SCAN                  |t22     |100      |90  |
|9 | PX COORDINATOR                  |        |500      |354 |
|10|  EXCHANGE OUT DISTR             |:EX20000|500      |331 |
|11|   PX PARTITION ITERATOR         |        |500      |331 |
|12|    TABLE SCAN                   |t12     |500      |331 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      equal_conds([t12.c1 = t22.c3]), other_conds(nil)
  1 - output([t22.c3]), filter(nil)
  2 - output([t22.c3]), filter(nil), dop=1
  3 - output([t22.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c2]), batch_join=false
  4 - output([t1.c2]), filter(nil)
  5 - output([t1.c2]), filter(nil), is_single, dop=1
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])
  7 - output([t22.c3]), filter(nil), 
      access all, force partition granule, asc.
  8 - output([t22.c3]), filter(nil), 
      access([t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX), 
      range_cond([? >= t22.c1])
  9 - output([t12.c1]), filter(nil)
  10 - output([t12.c1]), filter(nil), dop=1
  11 - output([t12.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true

*************** Case 780(end)  ************** 

***************   Case 781   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1 not in (select c3 from t1 where c1=5 AND c2>=t22.c1); 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN      |        |101612   |186420|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |106861|
|2 |  PX COORDINATOR           |        |300      |269   |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |198   |
|4 |    PX PARTITION ITERATOR  |        |300      |198   |
|5 |     TABLE SCAN            |t22     |300      |198   |
|6 |  MATERIAL                 |        |500      |446   |
|7 |   PX COORDINATOR          |        |500      |354   |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |331   |
|9 |     PX PARTITION ITERATOR |        |500      |331   |
|10|      TABLE SCAN           |t12     |500      |331   |
|11| MATERIAL                  |        |1        |53    |
|12|  SUBPLAN SCAN             |VIEW1   |1        |53    |
|13|   TABLE GET               |t1      |1        |52    |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      conds([VIEW1.t1.c2 >= t22.c1], [t12.c1 = t22.c3 OR (T_OP_IS, t22.c3, NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t12.c1], [t22.c1], [t22.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t22.c1], [t22.c3]), filter(nil)
  3 - output([t22.c1], [t22.c3]), filter(nil), dop=1
  4 - output([t22.c1], [t22.c3]), filter(nil), 
      force partition granule, asc.
  5 - output([t22.c1], [t22.c3]), filter(nil), 
      access([t22.c1], [t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  6 - output([t12.c1]), filter(nil)
  7 - output([t12.c1]), filter(nil)
  8 - output([t12.c1]), filter(nil), dop=1
  9 - output([t12.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  11 - output([VIEW1.t1.c2]), filter(nil)
  12 - output([VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c2])
  13 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])

*************** Case 781(end)  ************** 

***************   Case 782   ***************

SQL: select t12.c1 from t7 t12,t8 t22 where t12.c1 in (select c3 from t4 where c1=5 AND c2>=t22.c1); 

======================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST |
------------------------------------------------------
|0 |MERGE SEMI JOIN            |     |3334     |12269|
|1 | NESTED-LOOP JOIN CARTESIAN|     |10000    |7270 |
|2 |  TABLE SCAN               |t12  |100      |88   |
|3 |  MATERIAL                 |     |100      |106  |
|4 |   TABLE SCAN              |t22  |100      |88   |
|5 | SORT                      |     |100      |233  |
|6 |  SUBPLAN SCAN             |VIEW1|100      |106  |
|7 |   TABLE SCAN              |t4   |100      |92   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      equal_conds([t12.c1 = VIEW1.t4.c3]), other_conds([VIEW1.t4.c2 >= t22.c1])
  1 - output([t12.c1], [t22.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  3 - output([t22.c1]), filter(nil)
  4 - output([t22.c1]), filter(nil), 
      access([t22.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  5 - output([VIEW1.t4.c2], [VIEW1.t4.c3]), filter(nil), sort_keys([VIEW1.t4.c3, ASC])
  6 - output([VIEW1.t4.c2], [VIEW1.t4.c3]), filter(nil), 
      access([VIEW1.t4.c2], [VIEW1.t4.c3])
  7 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 782(end)  ************** 

***************   Case 783   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1+t22.c1 in (select c3 from t1 where c1=5); 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |750      |113293|
|1 | TABLE GET                 |t1      |1        |52    |
|2 | MATERIAL                  |        |750      |56784 |
|3 |  NESTED-LOOP JOIN         |        |750      |55957 |
|4 |   PX COORDINATOR          |        |300      |269   |
|5 |    EXCHANGE OUT DISTR     |:EX10000|300      |198   |
|6 |     PX PARTITION ITERATOR |        |300      |198   |
|7 |      TABLE SCAN           |t22     |300      |198   |
|8 |   MATERIAL                |        |500      |446   |
|9 |    PX COORDINATOR         |        |500      |354   |
|10|     EXCHANGE OUT DISTR    |:EX20000|500      |331   |
|11|      PX PARTITION ITERATOR|        |500      |331   |
|12|       TABLE SCAN          |t12     |500      |331   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])
  2 - output([t12.c1]), filter(nil)
  3 - output([t12.c1]), filter(nil), 
      conds([t12.c1 + t22.c1 = t22.c3]), nl_params_(nil), batch_join=false
  4 - output([t22.c1], [t22.c3]), filter(nil)
  5 - output([t22.c1], [t22.c3]), filter(nil), dop=1
  6 - output([t22.c1], [t22.c3]), filter(nil), 
      force partition granule, asc.
  7 - output([t22.c1], [t22.c3]), filter(nil), 
      access([t22.c1], [t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  8 - output([t12.c1]), filter(nil)
  9 - output([t12.c1]), filter(nil)
  10 - output([t12.c1]), filter(nil), dop=1
  11 - output([t12.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true

*************** Case 783(end)  ************** 

***************   Case 784   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1+t22.c1 not in (select c3 from t1 where c1=5); 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN      |        |72138    |188874|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |106861|
|2 |  PX COORDINATOR           |        |300      |269   |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |198   |
|4 |    PX PARTITION ITERATOR  |        |300      |198   |
|5 |     TABLE SCAN            |t22     |300      |198   |
|6 |  MATERIAL                 |        |500      |446   |
|7 |   PX COORDINATOR          |        |500      |354   |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |331   |
|9 |     PX PARTITION ITERATOR |        |500      |331   |
|10|      TABLE SCAN           |t12     |500      |331   |
|11| MATERIAL                  |        |1        |53    |
|12|  SUBPLAN SCAN             |VIEW1   |1        |53    |
|13|   TABLE GET               |t1      |1        |52    |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      conds([(T_OP_OR, t12.c1 + t22.c1 = t22.c3, (T_OP_IS, t12.c1 + t22.c1, NULL, 0), (T_OP_IS, t22.c3, NULL, 0))]), nl_params_(nil), batch_join=false
  1 - output([t12.c1], [t22.c1], [t22.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t22.c1], [t22.c3]), filter(nil)
  3 - output([t22.c1], [t22.c3]), filter(nil), dop=1
  4 - output([t22.c1], [t22.c3]), filter(nil), 
      force partition granule, asc.
  5 - output([t22.c1], [t22.c3]), filter(nil), 
      access([t22.c1], [t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  6 - output([t12.c1]), filter(nil)
  7 - output([t12.c1]), filter(nil)
  8 - output([t12.c1]), filter(nil), dop=1
  9 - output([t12.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  11 - output([1]), filter(nil)
  12 - output([1]), filter(nil), 
      access(nil)
  13 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])

*************** Case 784(end)  ************** 

***************   Case 785   ***************

SQL: select count(t12.c1) from t1 t12,t2 t22 where t12.c1>SOME(select c3 from t1 where c1=5 AND c1=10 AND c2>=t22.c1) AND t22.c2>=5 AND t12.c2<SOME(select c1 from t1 where c2=3 AND c2<10 AND c3<=t12.c1); 

================================================================================
|ID|OPERATOR                              |NAME                 |EST. ROWS|COST|
--------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                       |                     |1        |230 |
|1 | NESTED-LOOP JOIN                     |                     |14       |227 |
|2 |  SUBPLAN SCAN                        |VIEW3                |1        |38  |
|3 |   SCALAR GROUP BY                    |                     |1        |38  |
|4 |    SUBPLAN SCAN                      |VIEW4                |1        |38  |
|5 |     LIMIT                            |                     |1        |37  |
|6 |      PX COORDINATOR MERGE SORT       |                     |1        |37  |
|7 |       EXCHANGE OUT DISTR             |:EX10000             |1        |37  |
|8 |        SORT                          |                     |1        |37  |
|9 |         PX PARTITION ITERATOR        |                     |1        |36  |
|10|          TABLE SCAN                  |t1(idx_t1_c2,Reverse)|1        |36  |
|11|  PX COORDINATOR                      |                     |42       |174 |
|12|   EXCHANGE OUT DISTR                 |:EX20002             |42       |154 |
|13|    NESTED-LOOP JOIN                  |                     |42       |154 |
|14|     EXCHANGE IN DISTR                |                     |1        |93  |
|15|      EXCHANGE OUT DISTR (BC2HOST)    |:EX20001             |1        |93  |
|16|       MATERIAL                       |                     |1        |93  |
|17|        NESTED-LOOP JOIN              |                     |1        |92  |
|18|         EXCHANGE IN DISTR            |                     |1        |90  |
|19|          EXCHANGE OUT DISTR (BC2HOST)|:EX20000             |1        |90  |
|20|           TABLE GET                  |t1                   |1        |90  |
|21|         PX PARTITION ITERATOR        |                     |75       |109 |
|22|          TABLE SCAN                  |t22                  |75       |109 |
|23|     PX PARTITION ITERATOR            |                     |56       |46  |
|24|      TABLE SCAN                      |t12                  |56       |46  |
================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t12.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t12.c1)])
  1 - output([t12.c1]), filter(nil), 
      conds([t12.c2 < VIEW3.VIEW2.T_FUN_MAX(t1.c1)]), nl_params_(nil), batch_join=false
  2 - output([VIEW3.VIEW2.T_FUN_MAX(t1.c1)]), filter(nil), 
      access([VIEW3.VIEW2.T_FUN_MAX(t1.c1)])
  3 - output([T_FUN_MAX(VIEW4.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW4.c1)])
  4 - output([VIEW4.c1]), filter(nil), 
      access([VIEW4.c1])
  5 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC])
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC]), local merge sort
  9 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(3,MIN ; 3,MAX), 
      range_cond([t1.c2 = ?], [t1.c2 < ?])
  11 - output([t12.c1], [t12.c2]), filter(nil)
  12 - output([t12.c1], [t12.c2]), filter(nil), dop=1
  13 - output([t12.c1], [t12.c2]), filter(nil), 
      conds(nil), nl_params_([t22.c3]), batch_join=false
  14 - output([t22.c3]), filter(nil)
  15 - output([t22.c3]), filter(nil), dop=1
  16 - output([t22.c3]), filter(nil)
  17 - output([t22.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c2]), batch_join=false
  18 - output([t1.c2]), filter(nil)
  19 - output([t1.c2]), filter(nil), is_single, dop=1
  20 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range(MAX ; MIN)always false, 
      range_cond([t1.c1 = ?], [t1.c1 = ?])
  21 - output([t22.c3]), filter(nil), 
      access all, force partition granule, asc.
  22 - output([t22.c3]), filter([t22.c2 >= ?]), 
      access([t22.c3], [t22.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t22.c1]), range(MIN ; MAX), 
      range_cond([? >= t22.c1])
  23 - output([t12.c1], [t12.c2]), filter(nil), 
      access all, force partition granule, asc.
  24 - output([t12.c1], [t12.c2]), filter(nil), 
      access([t12.c1], [t12.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX), 
      range_cond([t12.c1 > ?], [? <= t12.c1])

*************** Case 785(end)  ************** 

***************   Case 786   ***************

SQL: select c1 from t7 group by c1, (select c2 from t7); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 786(end)  ************** 

***************   Case 787   ***************

SQL: select c1 from t7 order by c1, (select c2 from t7); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |192 |
|1 | TABLE SCAN   |t7  |100      |88  |
|2 | TABLE SCAN   |t7  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 787(end)  ************** 

***************   Case 788   ***************

SQL: select * from t7 where c2 in (select c2 from (select c2, sum(c1) from t7 group by c2) t); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |HASH JOIN      |     |100      |500 |
|1 | SUBPLAN SCAN  |VIEW1|100      |208 |
|2 |  HASH GROUP BY|     |100      |195 |
|3 |   TABLE SCAN  |t7   |100      |90  |
|4 | TABLE SCAN    |t7   |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c2 = VIEW1.c2]), other_conds(nil)
  1 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  2 - output([t7.c2]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t7.c2], [t7.c1]), filter(nil), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 788(end)  ************** 

***************   Case 789   ***************

SQL: select * from ts where c1 =1 and c2 > '2011-01-10' order by c2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |200      |175 |
|1 | EXCHANGE OUT DISTR       |:EX10000|200      |144 |
|2 |  PX PARTITION ITERATOR   |        |200      |144 |
|3 |   TABLE SCAN             |ts      |200      |144 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([ts.c1], [ts.c2]), filter(nil), sort_keys([ts.c2, ASC])
  1 - output([ts.c1], [ts.c2]), filter(nil), dop=1
  2 - output([ts.c1], [ts.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([ts.c1], [ts.c2]), filter(nil), 
      access([ts.c1], [ts.c2]), partitions(p1sp[0-1]), 
      is_index_back=false, 
      range_key([ts.c1], [ts.c2]), range(1,2011-01-10 00:00:00.000000 ; 1,MAX), 
      range_cond([ts.c1 = ?], [ts.c2 > ?])

*************** Case 789(end)  ************** 

***************   Case 790   ***************

SQL: select * from tr where c1 > 1 order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |300      |227 |
|1 | EXCHANGE OUT DISTR       |:EX10000|300      |198 |
|2 |  PX PARTITION ITERATOR   |        |300      |198 |
|3 |   TABLE SCAN             |tr      |300      |198 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([tr.c1], [tr.c2]), filter(nil), sort_keys([tr.c1, ASC])
  1 - output([tr.c1], [tr.c2]), filter(nil), dop=1
  2 - output([tr.c1], [tr.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([tr.c1], [tr.c2]), filter(nil), 
      access([tr.c1], [tr.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([tr.c1], [tr.c2]), range(1,MAX ; MAX,MAX), 
      range_cond([tr.c1 > ?])

*************** Case 790(end)  ************** 

***************   Case 791   ***************

SQL: select/*+index(t_idx_back t_idx_c2)*/ c3 from t_idx_back; 

===================================================
|ID|OPERATOR  |NAME                |EST. ROWS|COST|
---------------------------------------------------
|0 |TABLE SCAN|t_idx_back(t_idx_c2)|100      |90  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx_back.c3]), filter(nil), 
      access([t_idx_back.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_idx_back.c2], [t_idx_back.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 791(end)  ************** 

***************   Case 792   ***************

SQL: select /*+no_use_hash_aggregation*/ distinct c2 from t0; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE DISTINCT|    |100      |220 |
|1 | SORT         |    |100      |198 |
|2 |  TABLE SCAN  |t0  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.c2]), filter(nil), 
      distinct([t0.c2])
  1 - output([t0.c2]), filter(nil), sort_keys([t0.c2, ASC])
  2 - output([t0.c2]), filter(nil), 
      access([t0.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 792(end)  ************** 

***************   Case 793   ***************

SQL: select * from tidx where c3 = 1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tidx|1        |118 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter([tidx.c3 = ?]), 
      access([tidx.c3], [tidx.c1], [tidx.c2], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tidx.c1]), range(MIN ; MAX)always true

*************** Case 793(end)  ************** 

***************   Case 794   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 order by c2 limit 100; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |649 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c2], [tidx.c1], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(100), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 794(end)  ************** 

***************   Case 795   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 limit 100; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |649 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c2], [tidx.c1], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(100), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 795(end)  ************** 

***************   Case 796   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1098|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1013|
|2 |  WINDOW FUNCTION             |        |300      |1013|
|3 |   SORT                       |        |300      |955 |
|4 |    EXCHANGE IN DISTR         |        |300      |290 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |205 |
|6 |      PX PARTITION ITERATOR   |        |300      |205 |
|7 |       TABLE SCAN             |t2      |300      |205 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil)
  1 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 796(end)  ************** 

***************   Case 797   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3), max(c3) over (partition by c2) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1098|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1013|
|2 |  WINDOW FUNCTION             |        |300      |1013|
|3 |   SORT                       |        |300      |955 |
|4 |    EXCHANGE IN DISTR         |        |300      |290 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |205 |
|6 |      PX PARTITION ITERATOR   |        |300      |205 |
|7 |       TABLE SCAN             |t2      |300      |205 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [T_FUN_MAX(t2.c3)], [T_FUN_MAX(t2.c3)]), filter(nil)
  1 - output([t2.c1], [T_FUN_MAX(t2.c3)], [T_FUN_MAX(t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [T_FUN_MAX(t2.c3)], [T_FUN_MAX(t2.c3)]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 797(end)  ************** 

***************   Case 798   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and 2 following) from t2 order by c2,c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |300      |1098|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1013|
|2 |  WINDOW FUNCTION             |        |300      |1013|
|3 |   SORT                       |        |300      |955 |
|4 |    EXCHANGE IN DISTR         |        |300      |290 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |205 |
|6 |      PX PARTITION ITERATOR   |        |300      |205 |
|7 |       TABLE SCAN             |t2      |300      |205 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  1 - output([t2.c1], [T_FUN_MAX(t2.c3)], [t2.c3], [t2.c2]), filter(nil), dop=1
  2 - output([t2.c1], [T_FUN_MAX(t2.c3)], [t2.c3], [t2.c2]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(? FOLLOWING)
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 798(end)  ************** 

***************   Case 799   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and 2 following) from t2 order by c3,c2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |300      |2704|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |2618|
|2 |  SORT                         |        |300      |2618|
|3 |   WINDOW FUNCTION             |        |300      |1013|
|4 |    SORT                       |        |300      |955 |
|5 |     EXCHANGE IN DISTR         |        |300      |290 |
|6 |      EXCHANGE OUT DISTR (HASH)|:EX10000|300      |205 |
|7 |       PX PARTITION ITERATOR   |        |300      |205 |
|8 |        TABLE SCAN             |t2      |300      |205 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), sort_keys([t2.c3, ASC], [t2.c2, ASC])
  1 - output([t2.c1], [T_FUN_MAX(t2.c3)], [t2.c3], [t2.c2]), filter(nil), dop=1
  2 - output([t2.c1], [T_FUN_MAX(t2.c3)], [t2.c3], [t2.c2]), filter(nil), sort_keys([t2.c3, ASC], [t2.c2, ASC])
  3 - output([t2.c1], [T_FUN_MAX(t2.c3)], [t2.c3], [t2.c2]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(? FOLLOWING)
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  5 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 799(end)  ************** 

***************   Case 800   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and unbounded following) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1098|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1013|
|2 |  WINDOW FUNCTION             |        |300      |1013|
|3 |   SORT                       |        |300      |955 |
|4 |    EXCHANGE IN DISTR         |        |300      |290 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |205 |
|6 |      PX PARTITION ITERATOR   |        |300      |205 |
|7 |       TABLE SCAN             |t2      |300      |205 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil)
  1 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(UNBOUNDED FOLLOWING)
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 800(end)  ************** 

***************   Case 801   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and 2 following) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1098|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1013|
|2 |  WINDOW FUNCTION             |        |300      |1013|
|3 |   SORT                       |        |300      |955 |
|4 |    EXCHANGE IN DISTR         |        |300      |290 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |205 |
|6 |      PX PARTITION ITERATOR   |        |300      |205 |
|7 |       TABLE SCAN             |t2      |300      |205 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil)
  1 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [T_FUN_MAX(t2.c3)]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(? FOLLOWING)
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 801(end)  ************** 

***************   Case 802   ***************

SQL: select * from tg where c1 = 'bcde'; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|tg  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil), 
      access([tg.c1], [tg.c2], [tg.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([tg.c1]), range[bcde ; bcde], 
      range_cond([tg.c1 = ?])

*************** Case 802(end)  ************** 

***************   Case 803   ***************

SQL: select * from tg where c1 = 'baaaa'; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |53  |
|1 | EXCHANGE OUT REMOTE|    |1        |53  |
|2 |  TABLE GET         |tg  |1        |53  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil)
  1 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil)
  2 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil), 
      access([tg.c1], [tg.c2], [tg.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([tg.c1]), range[baaaa ; baaaa], 
      range_cond([tg.c1 = ?])

*************** Case 803(end)  ************** 

***************   Case 804   ***************

SQL: select * from tg where c1 = 'bcde' and (c2 = 'cde' or c2 = 'baaaa'); 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|tg  |1        |53  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([tg.c1], [tg.c2], [tg.c3]), filter([tg.c2 = ? OR tg.c2 = ?]), 
      access([tg.c1], [tg.c2], [tg.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg.c1]), range[bcde ; bcde], 
      range_cond([tg.c1 = ?])

*************** Case 804(end)  ************** 

***************   Case 805   ***************

SQL: select z1.a, z2.a from z1 full outer join z2 on z1.a = z2.a order by z1.a, z2.a; 

===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |SORT                  |    |100      |390 |
|1 | MERGE FULL OUTER JOIN|    |100      |262 |
|2 |  TABLE SCAN          |z1  |100      |88  |
|3 |  TABLE SCAN          |z2  |100      |88  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z2.a]), filter(nil), sort_keys([z1.a, ASC], [z2.a, ASC])
  1 - output([z1.a], [z2.a]), filter(nil), 
      equal_conds([z1.a = z2.a]), other_conds(nil)
  2 - output([z1.a]), filter(nil), 
      access([z1.a]), partitions(p0), 
      is_index_back=false, 
      range_key([z1.a]), range(MIN ; MAX)always true
  3 - output([z2.a]), filter(nil), 
      access([z2.a]), partitions(p0), 
      is_index_back=false, 
      range_key([z2.a]), range(MIN ; MAX)always true

*************** Case 805(end)  ************** 

***************   Case 806   ***************

SQL: select t7.c1 from t7,t8 where t7.c1 > (select t0.c1 from t0 where t7.c1); 

=======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST   |
-------------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |1043728|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7270   |
|2 |  TABLE SCAN               |t7  |100      |88     |
|3 |  MATERIAL                 |    |100      |106    |
|4 |   TABLE SCAN              |t8  |100      |88     |
|5 | TABLE SCAN                |t0  |100      |90     |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c1 > subquery(1)]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t0.c1]), filter(nil), startup_filter([?]), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 806(end)  ************** 

***************   Case 807   ***************

SQL: select t7.c1 from t7,t8 where t7.c1 > (select t0.c1 from t0 where t7.c1 + 1); 

=======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST   |
-------------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |1043728|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7270   |
|2 |  TABLE SCAN               |t7  |100      |88     |
|3 |  MATERIAL                 |    |100      |106    |
|4 |   TABLE SCAN              |t8  |100      |88     |
|5 | TABLE SCAN                |t0  |100      |90     |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c1 > subquery(1)]), 
      exec_params_([t7.c1 + ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t0.c1]), filter(nil), startup_filter([?]), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 807(end)  ************** 

***************   Case 808   ***************

SQL: select t7.c1 from t7,t8 where t7.c1 > (select t0.c1 from t0 where 1); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |3044|
|1 | NESTED-LOOP JOIN CARTESIAN|    |3334     |2494|
|2 |  TABLE SCAN               |t8  |100      |88  |
|3 |  MATERIAL                 |    |34       |48  |
|4 |   TABLE SCAN              |t7  |34       |42  |
|5 | TABLE SCAN                |t0  |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  5 - output([t0.c1]), filter(nil), startup_filter([1]), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 808(end)  ************** 

***************   Case 809   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1 in (select c3 from t1 where c1 = 5 AND c2 = t22.c1); 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR                   |        |1        |128 |
|1 | EXCHANGE OUT DISTR              |:EX10002|1        |128 |
|2 |  NESTED-LOOP JOIN               |        |1        |128 |
|3 |   EXCHANGE IN DISTR             |        |1        |91  |
|4 |    EXCHANGE OUT DISTR (BC2HOST) |:EX10001|1        |91  |
|5 |     MATERIAL                    |        |1        |91  |
|6 |      NESTED-LOOP JOIN           |        |1        |89  |
|7 |       EXCHANGE IN DISTR         |        |1        |53  |
|8 |        EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |52  |
|9 |         TABLE GET               |t1      |1        |52  |
|10|       PX PARTITION ITERATOR     |        |1        |36  |
|11|        TABLE GET                |t22     |1        |36  |
|12|   PX PARTITION ITERATOR         |        |1        |36  |
|13|    TABLE GET                    |t12     |1        |36  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil)
  1 - output([t12.c1]), filter(nil), dop=1
  2 - output([t12.c1]), filter(nil), 
      conds(nil), nl_params_([t22.c3]), batch_join=false
  3 - output([t22.c3]), filter(nil)
  4 - output([t22.c3]), filter(nil), dop=1
  5 - output([t22.c3]), filter(nil)
  6 - output([t22.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c2]), batch_join=false
  7 - output([t1.c2], [PARTITION_ID]), filter(nil)
  8 - (#keys=1, [t1.c2]), output([t1.c2], [PARTITION_ID]), filter(nil), is_single, dop=1
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])
  10 - output([t22.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  11 - output([t22.c3]), filter(nil), 
      access([t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX), 
      range_cond([? = t22.c1])
  12 - output([t12.c1]), filter(nil), 
      access all, force partition granule, asc.
  13 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX), 
      range_cond([t12.c1 = ?])

*************** Case 809(end)  ************** 

***************   Case 810   ***************

SQL: select * from t1 join t5 on t1.c1 = t5.c3 where t5.c3 > 0 and t5.c3 < 100 order by t5.c3 limit 100; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                           |        |100      |1610|
|1 | PX COORDINATOR MERGE SORT      |        |100      |1596|
|2 |  EXCHANGE OUT DISTR            |:EX10001|100      |1573|
|3 |   LIMIT                        |        |100      |1573|
|4 |    MERGE JOIN                  |        |100      |1559|
|5 |     SORT                       |        |294      |608 |
|6 |      PX PARTITION ITERATOR     |        |294      |197 |
|7 |       TABLE SCAN               |t1      |294      |197 |
|8 |     SORT                       |        |177      |827 |
|9 |      EXCHANGE IN DISTR         |        |300      |348 |
|10|       EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |305 |
|11|        PX PARTITION ITERATOR   |        |300      |305 |
|12|         TABLE SCAN             |t5      |300      |305 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t5.c3]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; 100), 
      range_cond([t1.c1 < ?], [t1.c1 > ?])
  8 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  9 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  10 - (#keys=1, [t5.c3]), output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  11 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t5.c2], [t5.c3], [t5.c1]), filter([t5.c3 > ?], [t5.c3 < ?]), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 810(end)  ************** 

***************   Case 811   ***************

SQL: select * from t1 join t5 on t1.c1 = t5.c3 where t5.c3 > 0 and t5.c3 < 100 order by t5.c3 limit 10000; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                           |        |290      |2332|
|1 | PX COORDINATOR MERGE SORT      |        |290      |2292|
|2 |  EXCHANGE OUT DISTR            |:EX10001|290      |2223|
|3 |   LIMIT                        |        |290      |2223|
|4 |    MERGE JOIN                  |        |290      |2183|
|5 |     SORT                       |        |500      |1074|
|6 |      PX PARTITION ITERATOR     |        |500      |342 |
|7 |       TABLE SCAN               |t1      |500      |342 |
|8 |     SORT                       |        |300      |827 |
|9 |      EXCHANGE IN DISTR         |        |300      |348 |
|10|       EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |305 |
|11|        PX PARTITION ITERATOR   |        |300      |305 |
|12|         TABLE SCAN             |t5      |300      |305 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), limit(10000), offset(nil)
  1 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), limit(10000), offset(nil)
  4 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t5.c3]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; 100), 
      range_cond([t1.c1 < ?], [t1.c1 > ?])
  8 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  9 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  10 - (#keys=1, [t5.c3]), output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  11 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t5.c2], [t5.c3], [t5.c1]), filter([t5.c3 > ?], [t5.c3 < ?]), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 811(end)  ************** 

***************   Case 812   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 order by c2 limit 10000; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |649 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c2], [tidx.c1], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(10000), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 812(end)  ************** 

***************   Case 813   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 limit 10000; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |649 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c2], [tidx.c1], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(10000), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 813(end)  ************** 

***************   Case 814   ***************

SQL: select c2 from (select c1, c2 from t1 group by 1) a; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |389 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |342 |
|2 |  PX PARTITION ITERATOR|        |500      |342 |
|3 |   TABLE SCAN          |t1      |500      |342 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 814(end)  ************** 

***************   Case 815   ***************

SQL: select c2 from (select c1, c2 from t1 order by 1) a; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |1122|
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |1074|
|2 |  SORT                    |        |500      |1074|
|3 |   PX PARTITION ITERATOR  |        |500      |342 |
|4 |    TABLE SCAN            |t1      |500      |342 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c2], [t1.c1]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 815(end)  ************** 

***************   Case 816   ***************

SQL: select c2 from (select c1 + c2, c2 from t1 order by 1) a; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |1122|
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |1074|
|2 |  SORT                    |        |500      |1074|
|3 |   PX PARTITION ITERATOR  |        |500      |342 |
|4 |    TABLE SCAN            |t1      |500      |342 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), sort_keys([t1.c1 + t1.c2, ASC])
  1 - output([t1.c2], [t1.c1 + t1.c2]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1 + t1.c2]), filter(nil), sort_keys([t1.c1 + t1.c2, ASC])
  3 - output([t1.c2], [t1.c1 + t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c2], [t1.c1 + t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 816(end)  ************** 

***************   Case 817   ***************

SQL: select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 = t2.c1); 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR                  |             |750      |1893|
|1 | EXCHANGE OUT DISTR             |:EX10001     |750      |1786|
|2 |  UNION ALL                     |             |750      |1786|
|3 |   PX PARTITION ITERATOR        |             |500      |342 |
|4 |    TABLE SCAN                  |t1(idx_t1_c2)|500      |342 |
|5 |   MERGE JOIN                   |             |251      |1158|
|6 |    SORT                        |             |250      |729 |
|7 |     PX PARTITION ITERATOR      |             |250      |384 |
|8 |      TABLE SCAN                |t1           |250      |384 |
|9 |    EXCHANGE IN MERGE SORT DISTR|             |300      |206 |
|10|     EXCHANGE OUT DISTR (PKEY)  |:EX10000     |300      |192 |
|11|      PX PARTITION ITERATOR     |             |300      |192 |
|12|       TABLE SCAN               |t2           |300      |192 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil), dop=1
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, partition wise, force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(5,MIN ; 5,MAX), 
      range_cond([t1.c2 = ?])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, partition wise, force partition granule, asc.
  8 - output([t1.c1], [t1.c2]), filter([lnnvl(t1.c2 = ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  10 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  11 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 817(end)  ************** 

***************   Case 818   ***************

SQL: select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 > t2.c1); 

============================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST |
------------------------------------------------------------
|0 |UNION ALL                |             |584      |10119|
|1 | PX COORDINATOR          |             |500      |389  |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |500      |342  |
|3 |   PX PARTITION ITERATOR |             |500      |342  |
|4 |    TABLE SCAN           |t1(idx_t1_c2)|500      |342  |
|5 | NESTED-LOOP SEMI JOIN   |             |84       |9507 |
|6 |  PX COORDINATOR         |             |250      |407  |
|7 |   EXCHANGE OUT DISTR    |:EX20000     |250      |384  |
|8 |    PX PARTITION ITERATOR|             |250      |384  |
|9 |     TABLE SCAN          |t1           |250      |384  |
|10|  PX COORDINATOR         |             |1        |36   |
|11|   EXCHANGE OUT DISTR    |:EX30000     |1        |36   |
|12|    PX PARTITION ITERATOR|             |1        |36   |
|13|     TABLE SCAN          |t2           |1        |36   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(5,MIN ; 5,MAX), 
      range_cond([t1.c2 = ?])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter([lnnvl(t1.c2 = ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), dop=1
  12 - output([1]), filter(nil), 
      force partition granule, asc.
  13 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? > t2.c1])

*************** Case 818(end)  ************** 

***************   Case 819   ***************

SQL: select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 < t2.c1); 

============================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST |
------------------------------------------------------------
|0 |UNION ALL                |             |584      |10119|
|1 | PX COORDINATOR          |             |500      |389  |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |500      |342  |
|3 |   PX PARTITION ITERATOR |             |500      |342  |
|4 |    TABLE SCAN           |t1(idx_t1_c2)|500      |342  |
|5 | NESTED-LOOP SEMI JOIN   |             |84       |9507 |
|6 |  PX COORDINATOR         |             |250      |407  |
|7 |   EXCHANGE OUT DISTR    |:EX20000     |250      |384  |
|8 |    PX PARTITION ITERATOR|             |250      |384  |
|9 |     TABLE SCAN          |t1           |250      |384  |
|10|  PX COORDINATOR         |             |1        |36   |
|11|   EXCHANGE OUT DISTR    |:EX30000     |1        |36   |
|12|    PX PARTITION ITERATOR|             |1        |36   |
|13|     TABLE SCAN          |t2           |1        |36   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(5,MIN ; 5,MAX), 
      range_cond([t1.c2 = ?])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t1.c1], [t1.c2]), filter([lnnvl(t1.c2 = ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([1]), filter(nil)
  11 - output([1]), filter(nil), dop=1
  12 - output([1]), filter(nil), 
      force partition granule, asc.
  13 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? < t2.c1])

*************** Case 819(end)  ************** 

***************   Case 820   ***************

SQL: select * from t1, t2 where t1.c1 > exists(select c1 from t2 where t2.c1 = t1.c1); 

===========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST   |
-----------------------------------------------------------
|0 |SUBPLAN FILTER             |        |50000    |5563672|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |108575 |
|2 |  PX COORDINATOR           |        |300      |290    |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |205    |
|4 |    PX PARTITION ITERATOR  |        |300      |205    |
|5 |     TABLE SCAN            |t2      |300      |205    |
|6 |  MATERIAL                 |        |500      |573    |
|7 |   PX COORDINATOR          |        |500      |389    |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |342    |
|9 |     PX PARTITION ITERATOR |        |500      |342    |
|10|      TABLE SCAN           |t1      |500      |342    |
|11| LIMIT                     |        |1        |37     |
|12|  PX COORDINATOR           |        |1        |36     |
|13|   EXCHANGE OUT DISTR      |:EX30000|1        |36     |
|14|    PX PARTITION ITERATOR  |        |1        |36     |
|15|     TABLE GET             |t2      |1        |36     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t1.c1 > (T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([1]), filter(nil), limit(1), offset(nil)
  12 - output([1]), filter(nil)
  13 - output([1]), filter(nil), dop=1
  14 - output([1]), filter(nil), 
      force partition granule, asc.
  15 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = ?])

*************** Case 820(end)  ************** 

***************   Case 821   ***************

SQL: select * from t1 where (select c1 from t2 limit 1)+1 in (select 2 from t3 where t1.c1=t3.c1); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |SUBPLAN FILTER                  |        |100      |1530|
|1 | PX COORDINATOR                 |        |200      |1467|
|2 |  EXCHANGE OUT DISTR            |:EX10001|200      |1438|
|3 |   MERGE JOIN                   |        |200      |1438|
|4 |    SORT                        |        |500      |1074|
|5 |     PX PARTITION ITERATOR      |        |500      |342 |
|6 |      TABLE SCAN                |t1      |500      |342 |
|7 |    EXCHANGE IN MERGE SORT DISTR|        |200      |149 |
|8 |     EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |140 |
|9 |      PX PARTITION ITERATOR     |        |200      |140 |
|10|       TABLE SCAN               |t3      |200      |140 |
|11| LIMIT                          |        |1        |37  |
|12|  PX COORDINATOR                |        |1        |36  |
|13|   EXCHANGE OUT DISTR           |:EX20000|1        |36  |
|14|    PX PARTITION ITERATOR       |        |1        |36  |
|15|     TABLE SCAN                 |t2      |1        |36  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  8 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  9 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  11 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  12 - output([t2.c1]), filter(nil)
  13 - output([t2.c1]), filter(nil), dop=1
  14 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 821(end)  ************** 

***************   Case 822   ***************

SQL: select * from t1 having count(*) > (select c1 from t2 where t1.c1=t2.c1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER            |        |1        |569 |
|1 | SCALAR GROUP BY          |        |1        |533 |
|2 |  PX COORDINATOR          |        |1        |437 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |437 |
|4 |    MERGE GROUP BY        |        |1        |437 |
|5 |     PX PARTITION ITERATOR|        |500      |342 |
|6 |      TABLE SCAN          |t1      |500      |342 |
|7 | PX COORDINATOR           |        |1        |36  |
|8 |  EXCHANGE OUT DISTR      |:EX20000|1        |36  |
|9 |   PX PARTITION ITERATOR  |        |1        |36  |
|10|    TABLE GET             |t2      |1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(*)) > subquery(1)]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  2 - output([t1.c1], [t1.c2], [T_FUN_COUNT(*)]), filter(nil)
  3 - output([t1.c1], [t1.c2], [T_FUN_COUNT(*)]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t2.c1])

*************** Case 822(end)  ************** 

***************   Case 823   ***************

SQL: select * from t1, t2 where t2.c1 = t1.c1 and t2.c1 = (select c1 from t3 where t3.c1 = t1.c1); 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |200      |2636|
|1 | EXCHANGE OUT DISTR               |:EX10002|200      |2550|
|2 |  MERGE JOIN                      |        |200      |2550|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |200      |1261|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|200      |1195|
|5 |     MERGE JOIN                   |        |200      |1195|
|6 |      SORT                        |        |300      |859 |
|7 |       PX PARTITION ITERATOR      |        |300      |205 |
|8 |        TABLE SCAN                |t2      |300      |205 |
|9 |      EXCHANGE IN MERGE SORT DISTR|        |200      |149 |
|10|       EXCHANGE OUT DISTR (PKEY)  |:EX10000|200      |140 |
|11|        PX PARTITION ITERATOR     |        |200      |140 |
|12|         TABLE SCAN               |t3      |200      |140 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), Local Order
  10 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  11 - output([t3.c1]), filter(nil), 
      force partition granule, asc.
  12 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 823(end)  ************** 

***************   Case 824   ***************

SQL: select * from (select c1+1 as a1 from t1 where t1.c2 = 2) a, t2 where a.a1 = t2.c2 or t2.c1 = ANY(select c3 from t3 where t3.c1 > a.a1); 

===============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------
|0 |UNION ALL                  |             |9072     |129412|
|1 | HASH JOIN                 |             |300      |1641  |
|2 |  PX COORDINATOR           |             |500      |389   |
|3 |   EXCHANGE OUT DISTR      |:EX10000     |500      |342   |
|4 |    PX PARTITION ITERATOR  |             |500      |342   |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|500      |342   |
|6 |  PX COORDINATOR           |             |300      |290   |
|7 |   EXCHANGE OUT DISTR      |:EX20000     |300      |205   |
|8 |    PX PARTITION ITERATOR  |             |300      |205   |
|9 |     TABLE SCAN            |t2           |300      |205   |
|10| HASH RIGHT SEMI JOIN      |             |8772     |123345|
|11|  PX COORDINATOR           |             |200      |191   |
|12|   EXCHANGE OUT DISTR      |:EX30000     |200      |144   |
|13|    PX PARTITION ITERATOR  |             |200      |144   |
|14|     TABLE SCAN            |t3           |200      |144   |
|15|  NESTED-LOOP JOIN         |             |75000    |82932 |
|16|   PX COORDINATOR          |             |300      |290   |
|17|    EXCHANGE OUT DISTR     |:EX40000     |300      |205   |
|18|     PX PARTITION ITERATOR |             |300      |205   |
|19|      TABLE SCAN           |t2           |300      |205   |
|20|   MATERIAL                |             |500      |573   |
|21|    PX COORDINATOR         |             |500      |389   |
|22|     EXCHANGE OUT DISTR    |:EX50000     |500      |342   |
|23|      PX PARTITION ITERATOR|             |500      |342   |
|24|       TABLE SCAN          |t1(idx_t1_c2)|500      |342   |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil)
  1 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c2]), other_conds(nil)
  2 - output([t1.c1 + ?]), filter(nil)
  3 - output([t1.c1 + ?]), filter(nil), dop=1
  4 - output([t1.c1 + ?]), filter(nil), 
      force partition granule, asc.
  5 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ?])
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c3]), other_conds([t3.c1 > t1.c1 + ?])
  11 - output([t3.c1], [t3.c3]), filter(nil)
  12 - output([t3.c1], [t3.c3]), filter(nil), dop=1
  13 - output([t3.c1], [t3.c3]), filter(nil), 
      force partition granule, asc.
  14 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  15 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1 + ?]), filter(nil), 
      conds([lnnvl(t1.c1 + ? = t2.c2)]), nl_params_(nil), batch_join=false
  16 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  17 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  18 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  19 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  20 - output([t1.c1]), filter(nil)
  21 - output([t1.c1]), filter(nil)
  22 - output([t1.c1]), filter(nil), dop=1
  23 - output([t1.c1]), filter(nil), 
      force partition granule, asc.
  24 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 824(end)  ************** 

***************   Case 825   ***************

SQL: select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |1477|
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |1462|
|2 |  MERGE JOIN                   |        |100      |1462|
|3 |   SORT                        |        |500      |1074|
|4 |    PX PARTITION ITERATOR      |        |500      |342 |
|5 |     TABLE SCAN                |t1      |500      |342 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |100      |246 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|100      |242 |
|8 |     PX PARTITION ITERATOR     |        |100      |242 |
|9 |      TABLE SCAN               |t2      |100      |242 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1]), filter([t2.c1 > cast(t2.c1, DECIMAL(11, 0))]), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 825(end)  ************** 

***************   Case 826   ***************

SQL: select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1 and t2.c2 > (select max(c2) from t3 where t3.c1 = t2.c1)); 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |34       |1930|
|1 | EXCHANGE OUT DISTR               |:EX10002|34       |1921|
|2 |  MERGE JOIN                      |        |34       |1921|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |34       |754 |
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|34       |747 |
|5 |     MERGE JOIN                   |        |34       |747 |
|6 |      EXCHANGE IN MERGE SORT DISTR|        |100      |258 |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|100      |248 |
|8 |        PX PARTITION ITERATOR     |        |100      |248 |
|9 |         TABLE SCAN               |t2      |100      |248 |
|10|      SORT                        |        |200      |415 |
|11|       PX PARTITION ITERATOR      |        |200      |144 |
|12|        TABLE SCAN                |t3      |200      |144 |
|13|   SORT                           |        |500      |1074|
|14|    PX PARTITION ITERATOR         |        |500      |342 |
|15|     TABLE SCAN                   |t1      |500      |342 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds([t2.c2 > t3.c2])
  6 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  7 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule, asc.
  9 - output([t2.c1], [t2.c2]), filter([t2.c1 > cast(t2.c1, DECIMAL(11, 0))]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t3.c2], [t3.c1]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  11 - output([t3.c1], [t3.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  12 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule, asc.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 826(end)  ************** 

***************   Case 827   ***************

SQL: select * from t1 where t1.c2 in (select avg(c1) from t2 where t2.c1 = t1.c1 union select count(1) from t3 where t3.c1 = t1.c1); 

=========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST |
---------------------------------------------------------
|0 |SUBPLAN FILTER             |        |250      |37313|
|1 | PX COORDINATOR            |        |500      |389  |
|2 |  EXCHANGE OUT DISTR       |:EX10000|500      |342  |
|3 |   PX PARTITION ITERATOR   |        |500      |342  |
|4 |    TABLE SCAN             |t1      |500      |342  |
|5 | MERGE UNION DISTINCT      |        |2        |74   |
|6 |  SCALAR GROUP BY          |        |1        |37   |
|7 |   PX COORDINATOR          |        |1        |37   |
|8 |    EXCHANGE OUT DISTR     |:EX20000|1        |37   |
|9 |     MERGE GROUP BY        |        |1        |37   |
|10|      PX PARTITION ITERATOR|        |1        |36   |
|11|       TABLE GET           |t2      |1        |36   |
|12|  SCALAR GROUP BY          |        |1        |37   |
|13|   PX COORDINATOR          |        |1        |37   |
|14|    EXCHANGE OUT DISTR     |:EX30000|1        |37   |
|15|     MERGE GROUP BY        |        |1        |37   |
|16|      PX PARTITION ITERATOR|        |1        |36   |
|17|       TABLE GET           |t3      |1        |36   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c2 = ANY(subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([UNION([1])]), filter(nil)
  6 - output([T_FUN_SUM(T_FUN_SUM(t2.c1)) / T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t2.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  7 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil)
  8 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil), dop=1
  9 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)])
  10 - output([t2.c1]), filter(nil), 
      force partition granule, asc.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = ?])
  12 - output([cast(T_FUN_COUNT_SUM(T_FUN_COUNT(?)), DECIMAL(24, 4))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(?))])
  13 - output([T_FUN_COUNT(?)]), filter(nil)
  14 - output([T_FUN_COUNT(?)]), filter(nil), dop=1
  15 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  16 - output([1]), filter(nil), 
      force partition granule, asc.
  17 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true, 
      range_cond([t3.c1 = ?])

*************** Case 827(end)  ************** 

***************   Case 828   ***************

SQL: select * from t1 where t1.c1 != (select c2 from t2 where t2.c1 = (select max(c2) from t3 where t3.c1 = t1.c1) order by t2.c2 limit 1); 

==========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST |
----------------------------------------------------------
|0 |SUBPLAN FILTER              |        |499      |36879|
|1 | PX COORDINATOR             |        |500      |389  |
|2 |  EXCHANGE OUT DISTR        |:EX10000|500      |342  |
|3 |   PX PARTITION ITERATOR    |        |500      |342  |
|4 |    TABLE SCAN              |t1      |500      |342  |
|5 | LIMIT                      |        |1        |73   |
|6 |  SUBPLAN FILTER            |        |1        |73   |
|7 |   PX COORDINATOR           |        |1        |37   |
|8 |    EXCHANGE OUT DISTR      |:EX20000|1        |36   |
|9 |     PX PARTITION ITERATOR  |        |1        |36   |
|10|      TABLE GET             |t2      |1        |36   |
|11|   SCALAR GROUP BY          |        |1        |37   |
|12|    PX COORDINATOR          |        |1        |37   |
|13|     EXCHANGE OUT DISTR     |:EX30000|1        |37   |
|14|      MERGE GROUP BY        |        |1        |37   |
|15|       PX PARTITION ITERATOR|        |1        |36   |
|16|        TABLE GET           |t3      |1        |36   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 != subquery(1)]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule, asc.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil), limit(1), offset(nil)
  6 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  7 - output([t2.c2]), filter(nil)
  8 - output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule, asc.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = ?])
  11 - output([T_FUN_MAX(T_FUN_MAX(t3.c2))]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(T_FUN_MAX(t3.c2))])
  12 - output([T_FUN_MAX(t3.c2)]), filter(nil)
  13 - output([T_FUN_MAX(t3.c2)]), filter(nil), dop=1
  14 - output([T_FUN_MAX(t3.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t3.c2)])
  15 - output([t3.c2]), filter(nil), 
      force partition granule, asc.
  16 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true, 
      range_cond([t3.c1 = ?])

*************** Case 828(end)  ************** 

***************   Case 829   ***************

SQL: select /*both need not sort*/ * from t7 left join t8 on t7.c2 = t8.c2 where t8.c2 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |214 |
|1 | TABLE SCAN               |t7  |1        |107 |
|2 | MATERIAL                 |    |1        |107 |
|3 |  TABLE SCAN              |t8  |1        |107 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c2], [t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c2], [t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 829(end)  ************** 

***************   Case 830   ***************

SQL: select /*both need sort*/ * from t7 left join t8 on t7.c2 = t8.c2 where t8.c2 IS NULL; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH OUTER JOIN|    |99       |400 |
|1 | TABLE SCAN    |t7  |100      |90  |
|2 | TABLE SCAN    |t8  |100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([(T_OP_IS, t8.c2, NULL, 0)]), 
      equal_conds([t7.c2 = t8.c2]), other_conds(nil)
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c2], [t8.c1]), filter(nil), 
      access([t8.c2], [t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 830(end)  ************** 

***************   Case 831   ***************

SQL: select /*both need not sort*/* from t7 left join t8 on t7.c2 = t8.c1 where t8.c1 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |160 |
|1 | TABLE GET                |t8  |1        |52  |
|2 | TABLE SCAN               |t7  |1        |107 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=true
  1 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[5 ; 5], 
      range_cond([t8.c1 = ?])
  2 - output([t7.c2], [t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 831(end)  ************** 

***************   Case 832   ***************

SQL: select /*left need sort*/ * from t7 left join t8 on t7.c2 = t8.c1 where t8.c1 IS NULL; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |99       |394 |
|1 | SORT           |    |100      |217 |
|2 |  TABLE SCAN    |t7  |100      |90  |
|3 | TABLE SCAN     |t8  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter([(T_OP_IS, t8.c1, NULL, 0)]), 
      equal_conds([t7.c2 = t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), sort_keys([t7.c2, ASC])
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      access([t7.c2], [t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 832(end)  ************** 

***************   Case 833   ***************

SQL: select /*both need not sort*/ * from t2 left join t3 on t2.c2 = t3.c2 where t3.c2 = 5; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |6        |444 |
|1 | PX COORDINATOR           |        |3        |256 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|3        |255 |
|3 |   PX PARTITION ITERATOR  |        |3        |255 |
|4 |    TABLE SCAN            |t2      |3        |255 |
|5 | MATERIAL                 |        |2        |185 |
|6 |  PX COORDINATOR          |        |2        |183 |
|7 |   EXCHANGE OUT DISTR     |:EX20000|2        |182 |
|8 |    PX PARTITION ITERATOR |        |2        |182 |
|9 |     TABLE SCAN           |t3      |2        |182 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter([t3.c2 = ?]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 833(end)  ************** 

***************   Case 834   ***************

SQL: select /*both need sort*/ * from t2 left join t3 on t2.c2 = t3.c2 where t3.c2 IS NULL; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH RIGHT OUTER JOIN   |        |298      |1323|
|1 | PX COORDINATOR         |        |200      |205 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|200      |149 |
|3 |   PX PARTITION ITERATOR|        |200      |149 |
|4 |    TABLE SCAN          |t3      |200      |149 |
|5 | PX COORDINATOR         |        |300      |290 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |205 |
|7 |   PX PARTITION ITERATOR|        |300      |205 |
|8 |    TABLE SCAN          |t2      |300      |205 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c2, NULL, 0)]), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule, asc.
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 834(end)  ************** 

***************   Case 835   ***************

SQL: select /*both need not sort*/* from t2 left join t3 on t2.c2 = t3.c1 where t3.c1 = 5; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |3        |310 |
|1 | PX COORDINATOR           |        |1        |53  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |53  |
|3 |   TABLE GET              |t3      |1        |53  |
|4 | PX COORDINATOR           |        |3        |256 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|3        |255 |
|6 |   PX PARTITION ITERATOR  |        |3        |255 |
|7 |    TABLE SCAN            |t2      |3        |255 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), is_single, dop=1
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t3.c1]), range[5 ; 5], 
      range_cond([t3.c1 = ?])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 835(end)  ************** 

***************   Case 836   ***************

SQL: select /*left need sort*/ * from t2 left join t3 on t2.c2 = t3.c1 where t3.c1 IS NULL; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |299      |1281|
|1 | EXCHANGE OUT DISTR          |:EX10001|299      |1111|
|2 |  HASH RIGHT OUTER JOIN      |        |299      |1111|
|3 |   PX PARTITION ITERATOR     |        |200      |149 |
|4 |    TABLE SCAN               |t3      |200      |149 |
|5 |   EXCHANGE IN DISTR         |        |300      |290 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |205 |
|7 |     PX PARTITION ITERATOR   |        |300      |205 |
|8 |      TABLE SCAN             |t2      |300      |205 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS, t3.c1, NULL, 0)]), 
      equal_conds([t2.c2 = t3.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule, asc.
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule, asc.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 836(end)  ************** 

***************   Case 837   ***************

SQL: select count(1) from rpt_adgroup_tag_realtime where thedate = '2017-09-25 00:00:00' and custid = '1102225352' and (custid,thedate,productlineid,campaignid,adgroupid,targetingtagid,tagvalue,pid,hour,traffictype,mechanism,productid) > (1102225352,'2017-09-25 00:00:00',-1,16138889,761211164,358940752715,358940752716,'420651_1007',12,1,2,-1); 

============================================================
|ID|OPERATOR       |NAME                    |EST. ROWS|COST|
------------------------------------------------------------
|0 |SCALAR GROUP BY|                        |1        |146 |
|1 | TABLE SCAN    |rpt_adgroup_tag_realtime|1        |146 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(?)])
  1 - output([1]), filter([rpt_adgroup_tag_realtime.thedate = ?], [rpt_adgroup_tag_realtime.custid = ?], [(rpt_adgroup_tag_realtime.custid, rpt_adgroup_tag_realtime.thedate, rpt_adgroup_tag_realtime.productlineid, rpt_adgroup_tag_realtime.campaignid, rpt_adgroup_tag_realtime.adgroupid, rpt_adgroup_tag_realtime.targetingtagid, rpt_adgroup_tag_realtime.tagvalue, rpt_adgroup_tag_realtime.pid, rpt_adgroup_tag_realtime.hour, rpt_adgroup_tag_realtime.traffictype, rpt_adgroup_tag_realtime.mechanism, rpt_adgroup_tag_realtime.productid) > (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]), 
      access([rpt_adgroup_tag_realtime.thedate], [rpt_adgroup_tag_realtime.custid], [rpt_adgroup_tag_realtime.productlineid], [rpt_adgroup_tag_realtime.campaignid], [rpt_adgroup_tag_realtime.adgroupid], [rpt_adgroup_tag_realtime.targetingtagid], [rpt_adgroup_tag_realtime.tagvalue], [rpt_adgroup_tag_realtime.pid], [rpt_adgroup_tag_realtime.hour], [rpt_adgroup_tag_realtime.traffictype], [rpt_adgroup_tag_realtime.mechanism], [rpt_adgroup_tag_realtime.productid]), partitions(p4sp2), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([rpt_adgroup_tag_realtime.custid], [rpt_adgroup_tag_realtime.thedate], [rpt_adgroup_tag_realtime.productlineid], [rpt_adgroup_tag_realtime.campaignid], [rpt_adgroup_tag_realtime.adgroupid], [rpt_adgroup_tag_realtime.targetingtagid], [rpt_adgroup_tag_realtime.tagvalue], [rpt_adgroup_tag_realtime.pid], [rpt_adgroup_tag_realtime.hour], [rpt_adgroup_tag_realtime.traffictype], [rpt_adgroup_tag_realtime.mechanism], [rpt_adgroup_tag_realtime.productid]), range(1102225352,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN ; 1102225352,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX)

*************** Case 837(end)  ************** 

***************   Case 838   ***************

SQL: select * from query_range where c1=3 and (c1, c2, c3)>(1, 2, 3) and (c1, c2, c3)>(2, 1, 2); 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|query_range|1        |130 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([query_range.c1 = ?], [(query_range.c1, query_range.c2, query_range.c3) > (?, ?, ?)], [(query_range.c1, query_range.c2, query_range.c3) > (?, ?, ?)]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range(3,MIN,MIN ; 3,MAX,MAX)

*************** Case 838(end)  ************** 

***************   Case 839   ***************

SQL: select * from cb_loan_acctbal_01 a where (a.balcatcd, a.baltypcd) in (('NOTE', 'BAL'), ('NOTE', 'GINT'), ('ODP', 'GINT'), ('RCVB', 'INT'), ('RCVB', 'ODPI')) and a.preeffdate and '2017-10-16' < a.effdate; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |600 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.acctnbr], [a.balcatcd], [a.baltypcd], [a.preeffdate], [a.preamt], [a.effdate], [a.amt], [a.mainttellerid], [a.maintbranchnbr], [a.gmt_create], [a.gmt_modified], [a.oddfreqnextduedate], [a.nextrcvbnbr], [a.nextratechangedate]), filter([(a.balcatcd, a.baltypcd) IN ((?, ?), (?, ?), (?, ?), (?, ?), (?, ?))], [? < a.effdate], [a.preeffdate]), 
      access([a.balcatcd], [a.baltypcd], [a.preeffdate], [a.effdate], [a.acctnbr], [a.preamt], [a.amt], [a.mainttellerid], [a.maintbranchnbr], [a.gmt_create], [a.gmt_modified], [a.oddfreqnextduedate], [a.nextrcvbnbr], [a.nextratechangedate]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([a.balcatcd], [a.baltypcd], [a.effdate], [a.acctnbr]), range(NOTE,BAL,2017-10-16,MAX ; NOTE,BAL,MAX,MAX), (NOTE,GINT,2017-10-16,MAX ; NOTE,GINT,MAX,MAX), (ODP,GINT,2017-10-16,MAX ; ODP,GINT,MAX,MAX), (RCVB,INT,2017-10-16,MAX ; RCVB,INT,MAX,MAX), (RCVB,ODPI,2017-10-16,MAX ; RCVB,ODPI,MAX,MAX)

*************** Case 839(end)  ************** 

***************   Case 840   ***************

SQL: use query_range; 
***************   Case 841   ***************

SQL: select * from range_t1 where (a, b)>(1, 1) and (a, b)=(1, 2); 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|range_t1|1        |132 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([range_t1.a], [range_t1.b]), filter([range_t1.a = ?], [range_t1.b = ?], [(range_t1.a, range_t1.b) > (?, ?)]), 
      access([range_t1.a], [range_t1.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([range_t1.a], [range_t1.b]), range(1,MIN ; 1,MAX)

*************** Case 841(end)  ************** 

***************   Case 842   ***************

SQL: select * from range_t1 where (a, b)>(1, 1) and a=1; 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|range_t1|1        |115 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([range_t1.a], [range_t1.b]), filter([range_t1.a = ?], [(range_t1.a, range_t1.b) > (?, ?)]), 
      access([range_t1.a], [range_t1.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([range_t1.a], [range_t1.b]), range(1,MIN ; 1,MAX)

*************** Case 842(end)  ************** 

***************   Case 843   ***************

SQL: select * from range_t1 where (a, b)>(1, 1) and b=2; 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|range_t1|1        |115 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([range_t1.a], [range_t1.b]), filter([range_t1.b = ?], [(range_t1.a, range_t1.b) > (?, ?)]), 
      access([range_t1.a], [range_t1.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([range_t1.a], [range_t1.b]), range(1,1 ; MAX,MAX)

*************** Case 843(end)  ************** 

***************   Case 844   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-02') and (id, dt) <= (1, '2017-01-03'); 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|8        |107 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([(test1.id, test1.dt) <= (?, ?)], [(test1.id, test1.dt) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([test1.id], [test1.dt]), range(0,2017-01-02 00:00:00.000000 ; 1,2017-01-03 00:00:00.000000]

*************** Case 844(end)  ************** 

***************   Case 845   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-02') and (id, dt) <= (1, '2017-01-03') and dt < '2017-01-02'; 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|2        |115 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([(test1.id, test1.dt) <= (?, ?)], [test1.dt < ?], [(test1.id, test1.dt) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([test1.id], [test1.dt]), range(0,2017-01-02 00:00:00.000000 ; 1,2017-01-03 00:00:00.000000]

*************** Case 845(end)  ************** 

***************   Case 846   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-01') and (id, dt) <= (1, '2017-01-03') and dt = '2017-01-02'; 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|1        |115 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([test1.dt = ?], [(test1.id, test1.dt) <= (?, ?)], [(test1.id, test1.dt) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([test1.id], [test1.dt]), range(0,2017-01-01 00:00:00.000000 ; 1,2017-01-03 00:00:00.000000]

*************** Case 846(end)  ************** 

***************   Case 847   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-02') and (id, dt) <= (1, '2017-01-03') and dt = '2017-01-02'; 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|1        |115 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([test1.dt = ?], [(test1.id, test1.dt) <= (?, ?)], [(test1.id, test1.dt) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([test1.id], [test1.dt]), range(0,2017-01-02 00:00:00.000000 ; 1,2017-01-03 00:00:00.000000]

*************** Case 847(end)  ************** 

